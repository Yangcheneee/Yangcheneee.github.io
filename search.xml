<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Web安全-XSS</title>
      <link href="/2023/11/06/web_xss/"/>
      <url>/2023/11/06/web_xss/</url>
      
        <content type="html"><![CDATA[<h1 id="一-XSS"><a href="#一-XSS" class="headerlink" title="一. XSS"></a>一. XSS</h1><h2 id="1-反射-DOM"><a href="#1-反射-DOM" class="headerlink" title="1. 反射&amp;DOM"></a>1. 反射&amp;DOM</h2><h2 id="2-存储"><a href="#2-存储" class="headerlink" title="2. 存储"></a>2. 存储</h2>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> XSS </tag>
            
            <tag> Web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dga域名检测</title>
      <link href="/2023/10/26/ai_dgadetection/"/>
      <url>/2023/10/26/ai_dgadetection/</url>
      
        <content type="html"><![CDATA[<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> LSTM </tag>
            
            <tag> Keras </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验：shellcode</title>
      <link href="/2023/10/22/os_shellcode/"/>
      <url>/2023/10/22/os_shellcode/</url>
      
        <content type="html"><![CDATA[<h1 id="一-shellcode"><a href="#一-shellcode" class="headerlink" title="一. shellcode"></a>一. shellcode</h1><p>shellcode广泛用于许多涉及代码注入的攻击中。编写shellcode是相当有挑战性的。虽然我们可以很容易地从互联网上找到现有的shellcode，但是能够从头开始编写我们自己的shellcode总是令人兴奋的。shellcode中涉及到几种有趣的技术。本实验室的目的是帮助学生理解这些技术，以便他们能够编写自己的shellcode。</p><p>编写shellcode有几个挑战，一个是确保二进制文件中没有0x00，另一个是找出命令中使用的数据的地址。第一个挑战不是很难解决，有几种方法可以解决它。第二个挑战的解决方案导致了编写外壳代码的两种典型方法。在一种方法中，数据在执行期间被推入堆栈，因此可以从堆栈指针获得它们的地址。在第二种方法中，数据存储在代码区域中，就在调用指令之后，因此在调用调用函数时，其地址被推入堆栈（作为返回地址）。两种解决方案都非常优雅，我们希望学生能够学习这两种技术。 </p><h1 id="二-实验"><a href="#二-实验" class="headerlink" title="二. 实验"></a>二. 实验</h1><h2 id="1-Task1-Writing-Shellcode"><a href="#1-Task1-Writing-Shellcode" class="headerlink" title="1. Task1 Writing Shellcode"></a>1. Task1 Writing Shellcode</h2><h3 id="1-1-Task1-a-The-Entire-Process"><a href="#1-1-Task1-a-The-Entire-Process" class="headerlink" title="1.1. Task1.a The Entire Process"></a>1.1. Task1.a The Entire Process</h3><h3 id="Compiling-to-object-code"><a href="#Compiling-to-object-code" class="headerlink" title="Compiling to object code"></a>Compiling to object code</h3><p>使用汇编软件nasm将mysh.s（汇编程序）汇编为mysh.o（目标文件）：<br> <img src="/img/os_shellcode/image-1.png" alt="Alt text"></p><h3 id="Linking-to-generate-final-binary"><a href="#Linking-to-generate-final-binary" class="headerlink" title="Linking to generate final binary"></a>Linking to generate final binary</h3><p>使用链接程序ld链接mysh.o（目标文件）为mysh（ELF可执行文件）：<br> <img src="/img/os_shellcode/image-2.png" alt="Alt text"><br>使用命令”echo $$”获取shellcode进程PID：<br> <img src="/img/os_shellcode/image-3.png" alt="Alt text"></p><h3 id="Getting-the-machine-code"><a href="#Getting-the-machine-code" class="headerlink" title="Getting the machine code"></a>Getting the machine code</h3><p>使用objdump命令反汇编mysh.o文件，并使用intel格式显示汇编代码，左边一列为机器码，右边一列为汇编代码：<br><img src="/img/os_shellcode/image-4.png" alt="Alt text"></p><p>使用xxd命令获取目标文件数据内容。这里-p代表16进制显示，-c 20代表一行显示20字节数据（这里截取了前三行内容）：<br> <img src="/img/os_shellcode/image-5.png" alt="Alt text"><br>可以发现的是xxd命令显示了目标文件全部的16进制数据，然而objdump命令反汇编内容只是目标文件的机器代码部分，这是因为目标文件协议包括其他字段内容：<br> <img src="/img/os_shellcode/image-6.png" alt="Alt text"></p><h3 id="Using-the-shellcode-in-attacking-code"><a href="#Using-the-shellcode-in-attacking-code" class="headerlink" title="Using the shellcode in attacking code"></a>Using the shellcode in attacking code</h3><p>打开文件convert.py，将上面16进制数据中的机器码部分复制到代码中的ori_sh变量中（这个程序将这个字符串转化为shellcode）：<br> <img src="/img/os_shellcode/image-7.png" alt="Alt text"><br>运行convert.py将字符串转化为shellcode：<br> <img src="/img/os_shellcode/image-8.png" alt="Alt text"></p><h3 id="1-2-Task1-b-Eliminating-Zero-from-the-Code"><a href="#1-2-Task1-b-Eliminating-Zero-from-the-Code" class="headerlink" title="1.2. Task1.b Eliminating Zero from the Code"></a>1.2. Task1.b Eliminating Zero from the Code</h3><p>字符串复制是注入恶意代码的一个常用手段，然而字符串复制例如函数strcpy通常会从零截断。因此，为了保证shellcode不被截断，更加范用，要对一般的shellcode做去零的处理。<br>去零方式：自异或；使用短位寄存器；移位</p><h3 id="找出mysh-s中的去零操作"><a href="#找出mysh-s中的去零操作" class="headerlink" title="找出mysh.s中的去零操作"></a>找出mysh.s中的去零操作</h3><p>汇编指令xor eax eax将eax置零，之后push eax相当于push 0，但是不会像push 0一样将shellcode引入0。<br> <img src="/img/os_shellcode/image-9.png" alt="Alt text"><br>同理，在下面eax的值没有发生改变，push eax相当于push 0：<br> <img src="/img/os_shellcode/image-10.png" alt="Alt text"><br>指令xor edx,edx将edx置零：<br> <img src="/img/os_shellcode/image-11.png" alt="Alt text"><br>由于al寄存器占eax寄存器的低8位，因此将0xb存入寄存器al，相当于将0x000b存入寄存器eax，push eax则避免了eax高位为零的情况：<br> <img src="/img/os_shellcode/image-12.png" alt="Alt text"></p><h3 id="Task：编写shellcode执行程序-bin-bash，不能有多余的“-”"><a href="#Task：编写shellcode执行程序-bin-bash，不能有多余的“-”" class="headerlink" title="Task：编写shellcode执行程序&#x2F;bin&#x2F;bash，不能有多余的“&#x2F;”"></a>Task：编写shellcode执行程序&#x2F;bin&#x2F;bash，不能有多余的“&#x2F;”</h3><p>这里使用al寄存器存储“h”，push eax相当于push 0x000h。<br> <img src="/img/os_shellcode/image-13.png" alt="Alt text"><br>对编译后的shellcode进行查看，没有字节为0，即没有出现0x00：<br> <img src="/img/os_shellcode/image-14.png" alt="Alt text"></p><h3 id="1-3-Task1-c-Providing-Arguments-for-System-Calls"><a href="#1-3-Task1-c-Providing-Arguments-for-System-Calls" class="headerlink" title="1.3. Task1.c Providing Arguments for System Calls"></a>1.3. Task1.c Providing Arguments for System Calls</h3><p>对于执行程序&#x2F;bin&#x2F;sh的shellcode，这里给出了参数argv数组需要填写的值：&#x2F;bin&#x2F;sh；-c；ls -la；0。也就是说我们需要将这些参数构造在堆栈上，然后执行系统调用即可。<br>首先使用eax寄存器将字符串压入栈中，中间使用0分隔；然后使用寄存器寄存器将argv数组的值压入栈中；最后将ecx指向argv即可。<br> <img src="/img/os_shellcode/image-15.png" alt="Alt text"><br> <img src="/img/os_shellcode/image-16.png" alt="Alt text"><br>编译链接以后成功执行&#x2F;bin&#x2F;sh -c ls -la：<br> <img src="/img/os_shellcode/image-17.png" alt="Alt text"></p><h3 id="1-4-Task1-d-Providing-Environment-Variables-for-execve"><a href="#1-4-Task1-d-Providing-Environment-Variables-for-execve" class="headerlink" title="1.4 Task1.d Providing Environment Variables for execve()"></a>1.4 Task1.d Providing Environment Variables for execve()</h3><p>对比上一个任务，这个任务压入四个环境变量aaa,bbb,cccc,0并将edx指向env数组即可。然后argv的参数少了几个。</p><p> <img src="/img/os_shellcode/image-18.png" alt="Alt text"><br> <img src="/img/os_shellcode/image-19.png" alt="Alt text"><br> <img src="/img/os_shellcode/image-20.png" alt="Alt text"><br><img src="/img/os_shellcode/image-21.png" alt="Alt text"></p><h2 id="2-Task2-Using-Code-Segment"><a href="#2-Task2-Using-Code-Segment" class="headerlink" title="2. Task2 Using Code Segment"></a>2. Task2 Using Code Segment</h2><h3 id="解释mysh2-s为什么能够成功执行程序-bin-sh："><a href="#解释mysh2-s为什么能够成功执行程序-bin-sh：" class="headerlink" title="解释mysh2.s为什么能够成功执行程序&#x2F;bin&#x2F;sh："></a>解释mysh2.s为什么能够成功执行程序&#x2F;bin&#x2F;sh：</h3><p> <img src="/img/os_shellcode/image-22.png" alt="Alt text"><br>程序mysh2.s通过构造db字符串实现shellcode注入。首先构造db字符串占位；其次替换掉字符串中的零，写入参数地址；最后将ecx指向参数地址，执行系统调用。</p><h3 id="使用mysh2-s中的方法执行程序-usr-bin-env"><a href="#使用mysh2-s中的方法执行程序-usr-bin-env" class="headerlink" title="使用mysh2.s中的方法执行程序&#x2F;usr&#x2F;bin&#x2F;env"></a>使用mysh2.s中的方法执行程序&#x2F;usr&#x2F;bin&#x2F;env</h3><p>重新编写mysh2.s：<br> <img src="/img/os_shellcode/image-23.png" alt="Alt text"><br> <img src="/img/os_shellcode/image-24.png" alt="Alt text"><br>编译并链接汇编程序mysh2.s，需要注意的是这里链接时需要加入“–omagic”指示代码区可修改，否则会出现segment fault<br> <img src="/img/os_shellcode/image-25.png" alt="Alt text"></p><h2 id="3-Task3-Writing-64-bit-Shellcode"><a href="#3-Task3-Writing-64-bit-Shellcode" class="headerlink" title="3. Task3 Writing 64-bit Shellcode"></a>3. Task3 Writing 64-bit Shellcode</h2><p>对于64位系统架构：寄存器存储8字节数据；系统调用的参数使用寄存器rdx，rsi，rdi。</p><h3 id="编写程序mysh-64-s，执行程序-bin-bash（即在64位环境下完成Task1-b中的Task）"><a href="#编写程序mysh-64-s，执行程序-bin-bash（即在64位环境下完成Task1-b中的Task）" class="headerlink" title="编写程序mysh_64.s，执行程序&#x2F;bin&#x2F;bash（即在64位环境下完成Task1.b中的Task）"></a>编写程序mysh_64.s，执行程序&#x2F;bin&#x2F;bash（即在64位环境下完成Task1.b中的Task）</h3><p>思路和mysh.s的编写一致，只有寄存器使用变化。使用rax寄存器将“&#x2F;bin&#x2F;bash”入栈，使用寄存器rdi作为argv直指向字符串，rsi寄存器指向argv即可。<br> <img src="/img/os_shellcode/image-26.png" alt="Alt text"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> shellcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web 登录实现&amp;身份认证</title>
      <link href="/2023/10/16/web_login/"/>
      <url>/2023/10/16/web_login/</url>
      
        <content type="html"><![CDATA[<h2 id="开发工具-环境"><a href="#开发工具-环境" class="headerlink" title="开发工具&amp;环境"></a>开发工具&amp;环境</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>vue集成html，css，javascript</p><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>SpringBoot集成mybatis，java，tomcat</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>Mysql以及图形化界面SQLyogEnt</p><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><p>数据库数据-java对象&#x2F;Dao(mapper)—&gt; 程序数据 (controller)—&gt; 后端数据 —tomcat—&gt; 前端数据 -vue-&gt; html数据</p><h1 id="数据结构-接口文档"><a href="#数据结构-接口文档" class="headerlink" title="数据结构&amp;接口文档"></a>数据结构&amp;接口文档</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库"></a>数据库</h3><p>user表id，username，password；将id设置为主键</p><h3 id="Java类"><a href="#Java类" class="headerlink" title="Java类"></a>Java类</h3><p>新建User类：int id，String username，String password</p><h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><h3 id="1-用户注册："><a href="#1-用户注册：" class="headerlink" title="1. 用户注册："></a>1. 用户注册：</h3><p>POST localhost&#x2F;auth&#x2F;register</p><p>username: “xxx”</p><p>hash_password: “xxx” </p><h3 id="2-用户登录："><a href="#2-用户登录：" class="headerlink" title="2. 用户登录："></a>2. 用户登录：</h3><p>POST localhost&#x2F;auth&#x2F;login</p><p>username: “xxx”</p><p>password: “xxx”</p><p>return token</p><h3 id="2-拉取用户信息："><a href="#2-拉取用户信息：" class="headerlink" title="2. 拉取用户信息："></a>2. 拉取用户信息：</h3><p>GET localhost&#x2F;user</p><p>token: “xxx”</p><p>return：id,username,password</p><h3 id="3-修改用户信息："><a href="#3-修改用户信息：" class="headerlink" title="3. 修改用户信息："></a>3. 修改用户信息：</h3><p>PUT localhost&#x2F;user</p><p>token: “xxx”</p><p>username: “xxx”</p><p>hash_password: “xxx”</p><h1 id="后端实现"><a href="#后端实现" class="headerlink" title="后端实现"></a>后端实现</h1><h2 id="数据库实现"><a href="#数据库实现" class="headerlink" title="数据库实现"></a>数据库实现</h2><p>user表id，username，password；将id设置为主键</p><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><h3 id="application-properties文件："><a href="#application-properties文件：" class="headerlink" title="application.properties文件："></a>application.properties文件：</h3><pre><code class="java">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource# ????spring.datasource.driver-class-name=com.mysql.jdbc.Driver# ?????spring.datasource.url=jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTCspring.datasource.username=rootspring.datasource.password=root</code></pre><h2 id="Dao层实现"><a href="#Dao层实现" class="headerlink" title="Dao层实现"></a>Dao层实现</h2><pre><code class="java">package com.example.bbb.entity;public class User &#123;    private int id;    private String username;    private String password;    public int getId() &#123;        return id;    &#125;    public String getUsername()&#123;        return username;    &#125;    public String getPassword()&#123;        return password;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, username=&#39;&quot; + username + &#39;\&#39;&#39; +                &quot;, password=&#39;&quot; + password + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><h2 id="Mapper层实现"><a href="#Mapper层实现" class="headerlink" title="Mapper层实现"></a>Mapper层实现</h2><pre><code class="java">package com.example.bbb.mapper;import java.util.List;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.example.bbb.entity.User;import org.apache.ibatis.annotations.*;@Mapperpublic interface UserMapper&#123;    @Select(&quot;select id from user where username = #&#123;username&#125;&quot;)    public int getId(String username);    //返回查询对象的集合    @Select(&quot;select * from user&quot;)    public List&lt;User&gt; findAll();    //返回查询对象    @Select(&quot;select * from user where id = #&#123;id&#125;&quot;)    public User getInfo(int id);    @Select(&quot;select username from user&quot;)    public List&lt;String&gt; getAllUsername();    @Select(&quot;select * from user where username = #&#123;username&#125;&quot;)    public User findByUsername(String username);    //将数据库insert语句映射到java程序的insert方法    //返回值为插入语句影响的记录数目    @Insert(&quot;insert into user values (#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;)    public int insert(int id, String name,String password);    //将数据库delete语句映射到java程序的delete方法    //返回值为删除语句影响的记录数目    @Delete(&quot;delete  from user where id = #&#123;id&#125;&quot;)    public int delete(int id);    //将数据库update语句映射到java程序的update方法    //返回值为更新语句影响的记录数目    @Update(&quot;update user set username = #&#123;newName&#125;,password= #&#123;newPassword&#125; where id = #&#123;id&#125;&quot;)    public int update(int id,String newName,String newPassword);    @Select(&quot;select username from user where username != #&#123;username&#125;&quot;)    public List&lt;String&gt; otherUserName(String username);&#125;</code></pre><h2 id="Controller层实现"><a href="#Controller层实现" class="headerlink" title="Controller层实现"></a>Controller层实现</h2><pre><code class="java">package com.example.bbb.controller;import com.example.bbb.entity.User;import com.example.bbb.mapper.UserMapper;import com.fasterxml.jackson.core.JsonProcessingException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.List;import com.fasterxml.jackson.databind.ObjectMapper;import static com.example.bbb.utils.JwtUtils.*;@RestController@CrossOriginpublic class UserController &#123;    @Autowired    private UserMapper userMapper;    //登录    @PostMapping(&quot;/auth/login&quot;)    public String login(@RequestParam(&quot;username&quot;) String username,@RequestParam(&quot;password&quot;) String password)&#123;        //权限标识        int verify = 0;        //检查账号，密码        List&lt;User&gt; list = userMapper.findAll();        for(int i=0; i&lt;list.size(); i++)&#123;            User useri = list.get(i);            if(useri.getUsername().equals(username) &amp;&amp; useri.getPassword().equals(password))&#123;                verify = 1;                break;            &#125;        &#125;        //权限判断        if(verify==1)&#123;            String token = generateToken(username);            int id = userMapper.getId(username);            System.out.println(&quot;用户&quot;+id+&quot;登录成功！&quot;);            return token;        &#125;else&#123;            System.out.println(&quot;用户&quot;+username+&quot;登录失败！！&quot;);            return &quot;error&quot;;        &#125;    &#125;    //返回用户个人信息    @GetMapping(&quot;/user&quot;)    public String info(@RequestParam String token) throws JsonProcessingException &#123;        if(verifyToken(token)) &#123;            String username = getUsernameFromToken(token);            int id = userMapper.getId(username);            User user = userMapper.getInfo(id);            ObjectMapper objectMapper = new ObjectMapper();            String userJson = objectMapper.writeValueAsString(user);            System.out.println(&quot;用户&quot;+id+&quot;查看个人信息！&quot;);            return userJson;        &#125; else&#123;            System.out.println(&quot;错误的token！！！&quot;);            return &quot;error&quot;;        &#125;    &#125;    //用户注册    @PostMapping(&quot;/auth/register&quot;)    public String register(@RequestParam(&quot;username&quot;) String newusername,@RequestParam String password)&#123;        int id = 0;        List&lt;String&gt; usernameList = userMapper.getAllUsername();        for(int i=0; i&lt;usernameList.size(); i++)&#123;            String username = usernameList.get(i);            if(username.equals(newusername))&#123;                System.out.println(&quot;注册存在的用户名！&quot;);                return(&quot;error&quot;);            &#125;        &#125;        userMapper.insert(id,newusername,password);        int newid = userMapper.getId(newusername);        System.out.println(&quot;用户&quot;+newid+&quot;注册成功！！&quot;);        return &quot;用户名：&quot;+newusername + &#39;\n&#39; +&quot;密码（hash）：&quot;+password;    &#125;//    //用户注销//    @DeleteMapping(&quot;/user&quot;)//    public String delete(@RequestParam int id)&#123;//        userMapper.delete(id);//        return &quot;delete&quot;;//    &#125;    //修改个人信息    @PutMapping(&quot;/user&quot;)    public String update(@RequestParam String token,@RequestParam String newUsername,@RequestParam String newPassword) &#123;        if(verifyToken(token)) &#123;            String username = getUsernameFromToken(token);            int id = userMapper.getId(username);            List&lt;String&gt; list = userMapper.otherUserName(username);            for (int i = 0; i &lt; list.size(); i++) &#123;                String usernamei = list.get(i);                if (usernamei.equals(newUsername)) &#123;                    System.out.println(&quot;用户&quot; + id + &quot;使用重复的用户名！&quot;);                    return &quot;error&quot;;                &#125;            &#125;            userMapper.update(id, newUsername, newPassword);            System.out.println(&quot;用户&quot; + id + &quot;更新用户名&quot; + username + &quot;为&quot; + newUsername);            return &quot;ok&quot;;        &#125; else&#123;            System.out.println(&quot;错误的token！！！&quot;);            return &quot;error&quot;;        &#125;    &#125;&#125;</code></pre><h2 id="JWT实现"><a href="#JWT实现" class="headerlink" title="JWT实现"></a>JWT实现</h2><pre><code class="java">package com.example.bbb.utils;import io.jsonwebtoken.Claims;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import java.util.Date;public class JwtUtils &#123;    //token有效时间    private static long expire = 604800;    //token秘钥    private static String key = &quot;aaaabbbbccccddddaaaabbbbccccdddd&quot;;    //生成token    public static String generateToken(String username)&#123;        Date now = new Date();        Date expiration = new Date(now.getTime()+1000*expire);        return Jwts.builder()                .setSubject(username)                .setIssuedAt(now)                .setExpiration(expiration)                .signWith(SignatureAlgorithm.HS512,key)                .compact();    &#125;    // 校验token合法性    public static boolean verifyToken(String token) &#123;        try &#123;            Jwts.parser().setSigningKey(key).parseClaimsJws(token);            return true;        &#125; catch (Exception e) &#123;            // 处理异常            System.out.println(&quot;错误的token&quot;);        &#125;        return false;    &#125;    //提取token中的username    public static String getUsernameFromToken(String token)&#123;        Claims claims = Jwts.parser()                .setSigningKey(key)                .parseClaimsJws(token)                .getBody();        return claims.getSubject();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈溢出</title>
      <link href="/2023/10/15/os_stackoverflow/"/>
      <url>/2023/10/15/os_stackoverflow/</url>
      
        <content type="html"><![CDATA[<h1 id="实验：Buffer-Overflow-Attack-Lab"><a href="#实验：Buffer-Overflow-Attack-Lab" class="headerlink" title="实验：Buffer Overflow Attack Lab"></a>实验：Buffer Overflow Attack Lab</h1><h2 id="1-Task1-Get-Familiar-with-the-Shellcode"><a href="#1-Task1-Get-Familiar-with-the-Shellcode" class="headerlink" title="1. Task1 Get Familiar with the Shellcode"></a>1. Task1 Get Familiar with the Shellcode</h2><h3 id="修改shellcode-32-py文件，使其能够删除文件。"><a href="#修改shellcode-32-py文件，使其能够删除文件。" class="headerlink" title="修改shellcode_32.py文件，使其能够删除文件。"></a>修改shellcode_32.py文件，使其能够删除文件。</h3><p> <img src="/img/os_stackoverflow/image.png" alt="Alt text"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在该目录下创建文件task1，通过ls命令发现task1文件创建成功。<br> <img src="/img/os_stackoverflow/image-1.png" alt="Alt text"><br>可以看到执行a32.out文件后，通过ls命令发现task1文件被删除。<br> <img src="/img/os_stackoverflow/image-2.png" alt="Alt text"></p><h2 id="2-Task2-Level-1-Attack"><a href="#2-Task2-Level-1-Attack" class="headerlink" title="2. Task2 Level-1 Attack"></a>2. Task2 Level-1 Attack</h2><h3 id="attack-code传入hello，获取server的堆栈信息。"><a href="#attack-code传入hello，获取server的堆栈信息。" class="headerlink" title="attack-code传入hello，获取server的堆栈信息。"></a>attack-code传入hello，获取server的堆栈信息。</h3><p> <img src="/img/os_stackoverflow/image-3.png" alt="Alt text"><br>Buf基地址为：0xffffd598<br>Ebp地址为：0xffffd608</p><h3 id="编写exploit-py文件。"><a href="#编写exploit-py文件。" class="headerlink" title="编写exploit.py文件。"></a>编写exploit.py文件。</h3><p>在32位环境下，ret地址为ebp地址+4（单位为字节），已知buf基地址，则偏移量为ebp地址+4-buf基地址。<br>ret的值存储指令地址，要执行shellcode，因此要将ret指向shellcode地址。而shellcode使用了Nop填充，所以ret指向ret+4即可空转跳转到shellcode。<br><img src="/img/os_stackoverflow/image-4.png" alt="Alt text"></p><h3 id="生成badfile，获取服务器权限"><a href="#生成badfile，获取服务器权限" class="headerlink" title="生成badfile，获取服务器权限"></a>生成badfile，获取服务器权限</h3><p> <img src="/img/os_stackoverflow/image-5.png" alt="Alt text"><br>3. Task3 Level-2 Attack</p><h3 id="attack-code传入hello，获取server堆栈信息。"><a href="#attack-code传入hello，获取server堆栈信息。" class="headerlink" title="attack-code传入hello，获取server堆栈信息。"></a>attack-code传入hello，获取server堆栈信息。</h3><p> <img src="/img/os_stackoverflow/image-6.png" alt="Alt text"><br>Buf基地址：0xffffd548<br>Ebp地址：由于buf大小在100-300字节，因此ebp地址在buf基地址+100到buf基地址+300之间。</p><h3 id="编写exploit-py文件。-1"><a href="#编写exploit-py文件。-1" class="headerlink" title="编写exploit.py文件。"></a>编写exploit.py文件。</h3><p>Ret地址等于ebp地址+4，因此ret地址可能在buf基地址+104到buf基地址+304之间，所以offset的值可能在104到304之间。将这段content都填入ret指向地址即可。<br>Ret的值需要指向shellcode，而buf大小不确定，因此ret指向地址必须大于buf最大值+8，以执行ret上方的shellcode，避免从下面空转到ret陷入循环。<br> <img src="/img/os_stackoverflow/image-7.png" alt="Alt text"></p><h3 id="生成badfile，获取服务器权限。"><a href="#生成badfile，获取服务器权限。" class="headerlink" title="生成badfile，获取服务器权限。"></a>生成badfile，获取服务器权限。</h3><h2 id="4-Task4-Level-3-Attack"><a href="#4-Task4-Level-3-Attack" class="headerlink" title="4. Task4 Level-3 Attack"></a>4. Task4 Level-3 Attack</h2><h3 id="attack-code传入hello获取server堆栈信息。"><a href="#attack-code传入hello获取server堆栈信息。" class="headerlink" title="attack-code传入hello获取server堆栈信息。"></a>attack-code传入hello获取server堆栈信息。</h3><p> <img src="/img/os_stackoverflow/image-8.png" alt="Alt text"><br>Rbp指针：0x00007fffffffe540<br>Buf基地址：0x00007fffffffe470</p><h3 id="编写exploit-py文件。-2"><a href="#编写exploit-py文件。-2" class="headerlink" title="编写exploit.py文件。"></a>编写exploit.py文件。</h3><p>首先插入64位的shellcode，并把执行命令改为反弹shell。<br>start的值设置为0，此时shellcode在content头部，位置为content[0,len(shellcode)]。<br>Ret地址为rbp地址+8（64位环境），offset的值为ret地址-buf基地址。<br>ret的值指向shellcode地址，此时shellcode代码在content头部，即buf基地址0x470。<br> <img src="/img/os_stackoverflow/image-9.png" alt="Alt text"></p><h3 id="生成badfile，获取服务器权限-1"><a href="#生成badfile，获取服务器权限-1" class="headerlink" title="生成badfile，获取服务器权限"></a>生成badfile，获取服务器权限</h3><p> <img src="/img/os_stackoverflow/image-10.png" alt="Alt text"></p><h2 id="5-Task5-Level-4-Attack"><a href="#5-Task5-Level-4-Attack" class="headerlink" title="5. Task5 Level-4 Attack"></a>5. Task5 Level-4 Attack</h2><h3 id="attack-code传入hello，获取server堆栈信息。-1"><a href="#attack-code传入hello，获取server堆栈信息。-1" class="headerlink" title="attack-code传入hello，获取server堆栈信息。"></a>attack-code传入hello，获取server堆栈信息。</h3><p> <img src="/img/os_stackoverflow/image-11.png" alt="Alt text"><br>Rbp指针：0x00007fffffffe540<br>Buf基地址：0x00007fffffffe470</p><h3 id="编写exploit-py文件"><a href="#编写exploit-py文件" class="headerlink" title="编写exploit.py文件"></a>编写exploit.py文件</h3><p>相比于上一个task，这个task实行shellcode依靠于Return-to-libc，因此需要改变ret指向地址。<br>        经过尝试以后，ret为rbp+1400的时候能够实现反弹shell。<br><img src="/img/os_stackoverflow/image-12.png" alt="Alt text"> </p><h3 id="生成badfile，获取服务器权限。-1"><a href="#生成badfile，获取服务器权限。-1" class="headerlink" title="生成badfile，获取服务器权限。"></a>生成badfile，获取服务器权限。</h3><p> <img src="/img/os_stackoverflow/image-13.png" alt="Alt text"></p><h2 id="6-Task6-Level-5-Attack"><a href="#6-Task6-Level-5-Attack" class="headerlink" title="6. Task6 Level-5 Attack"></a>6. Task6 Level-5 Attack</h2><h3 id="打开地址随机化。"><a href="#打开地址随机化。" class="headerlink" title="打开地址随机化。"></a>打开地址随机化。</h3><p> <img src="/img/os_stackoverflow/image-14.png" alt="Alt text"></p><h3 id="attack-code传入hello，获取server堆栈信息。-2"><a href="#attack-code传入hello，获取server堆栈信息。-2" class="headerlink" title="attack-code传入hello，获取server堆栈信息。"></a>attack-code传入hello，获取server堆栈信息。</h3><p>可以发现随着地址随机化的打开，server堆栈地址发生改变。<br> <img src="/img/os_stackoverflow/image-15.png" alt="Alt text"><br> <img src="/img/os_stackoverflow/image-16.png" alt="Alt text"></p><h3 id="编写exploit-py文件。-3"><a href="#编写exploit-py文件。-3" class="headerlink" title="编写exploit.py文件。"></a>编写exploit.py文件。</h3><p> <img src="/img/os_stackoverflow/image-17.png" alt="Alt text"></p><h3 id="生成badfile，运行脚本brute-force-sh不断向server传入badfile。"><a href="#生成badfile，运行脚本brute-force-sh不断向server传入badfile。" class="headerlink" title="生成badfile，运行脚本brute-force.sh不断向server传入badfile。"></a>生成badfile，运行脚本brute-force.sh不断向server传入badfile。</h3><p>当server程序满足badfile的堆栈条件时，脚本停止，成功获取服务器权限。<br> <img src="/img/os_stackoverflow/image-18.png" alt="Alt text"><br> <img src="/img/os_stackoverflow/image-19.png" alt="Alt text"><br> <img src="/img/os_stackoverflow/image-20.png" alt="Alt text"></p><h2 id="7-Task7-Level-6-Attack"><a href="#7-Task7-Level-6-Attack" class="headerlink" title="7.Task7 Level-6 Attack"></a>7.Task7 Level-6 Attack</h2><h3 id="在server-code目录下："><a href="#在server-code目录下：" class="headerlink" title="在server-code目录下："></a>在server-code目录下：</h3><p>去除-fon-stack-protector选项（即打开栈保护机制）编译stack.c，将badfile输入。<br>Server成功检测到stack smashing（堆栈溢出漏洞）<br> <img src="/img/os_stackoverflow/image-21.png" alt="Alt text"></p><h3 id="在shellcode目录下："><a href="#在shellcode目录下：" class="headerlink" title="在shellcode目录下："></a>在shellcode目录下：</h3><p>去除-z execstack（这个选项会认为栈空间的指令可以被执行，因此我们才能之前的实验运行栈溢出的shellcode和空转指令）编译call_shellcode.c编译并运行。<br><img src="/img/os_stackoverflow/image-22.png" alt="Alt text"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈溢出</title>
      <link href="/2023/10/15/os_setuid/"/>
      <url>/2023/10/15/os_setuid/</url>
      
        <content type="html"><![CDATA[<h1 id="实验：Buffer-Overflow-Attack-Lab"><a href="#实验：Buffer-Overflow-Attack-Lab" class="headerlink" title="实验：Buffer Overflow Attack Lab"></a>实验：Buffer Overflow Attack Lab</h1><h2 id="1-Task1-Get-Familiar-with-the-Shellcode"><a href="#1-Task1-Get-Familiar-with-the-Shellcode" class="headerlink" title="1. Task1 Get Familiar with the Shellcode"></a>1. Task1 Get Familiar with the Shellcode</h2><h3 id="修改shellcode-32-py文件，使其能够删除文件。"><a href="#修改shellcode-32-py文件，使其能够删除文件。" class="headerlink" title="修改shellcode_32.py文件，使其能够删除文件。"></a>修改shellcode_32.py文件，使其能够删除文件。</h3><p> <img src="/img/os_stackoverflow/image.png" alt="Alt text"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在该目录下创建文件task1，通过ls命令发现task1文件创建成功。<br> <img src="/img/os_stackoverflow/image-1.png" alt="Alt text"><br>可以看到执行a32.out文件后，通过ls命令发现task1文件被删除。<br> <img src="/img/os_stackoverflow/image-2.png" alt="Alt text"></p><h2 id="2-Task2-Level-1-Attack"><a href="#2-Task2-Level-1-Attack" class="headerlink" title="2. Task2 Level-1 Attack"></a>2. Task2 Level-1 Attack</h2><h3 id="attack-code传入hello，获取server的堆栈信息。"><a href="#attack-code传入hello，获取server的堆栈信息。" class="headerlink" title="attack-code传入hello，获取server的堆栈信息。"></a>attack-code传入hello，获取server的堆栈信息。</h3><p> <img src="/img/os_stackoverflow/image-3.png" alt="Alt text"><br>Buf基地址为：0xffffd598<br>Ebp地址为：0xffffd608</p><h3 id="编写exploit-py文件。"><a href="#编写exploit-py文件。" class="headerlink" title="编写exploit.py文件。"></a>编写exploit.py文件。</h3><p>在32位环境下，ret地址为ebp地址+4（单位为字节），已知buf基地址，则偏移量为ebp地址+4-buf基地址。<br>ret的值存储指令地址，要执行shellcode，因此要将ret指向shellcode地址。而shellcode使用了Nop填充，所以ret指向ret+4即可空转跳转到shellcode。<br><img src="/img/os_stackoverflow/image-4.png" alt="Alt text"></p><h3 id="生成badfile，获取服务器权限"><a href="#生成badfile，获取服务器权限" class="headerlink" title="生成badfile，获取服务器权限"></a>生成badfile，获取服务器权限</h3><p> <img src="/img/os_stackoverflow/image-5.png" alt="Alt text"><br>3. Task3 Level-2 Attack</p><h3 id="attack-code传入hello，获取server堆栈信息。"><a href="#attack-code传入hello，获取server堆栈信息。" class="headerlink" title="attack-code传入hello，获取server堆栈信息。"></a>attack-code传入hello，获取server堆栈信息。</h3><p> <img src="/img/os_stackoverflow/image-6.png" alt="Alt text"><br>Buf基地址：0xffffd548<br>Ebp地址：由于buf大小在100-300字节，因此ebp地址在buf基地址+100到buf基地址+300之间。</p><h3 id="编写exploit-py文件。-1"><a href="#编写exploit-py文件。-1" class="headerlink" title="编写exploit.py文件。"></a>编写exploit.py文件。</h3><p>Ret地址等于ebp地址+4，因此ret地址可能在buf基地址+104到buf基地址+304之间，所以offset的值可能在104到304之间。将这段content都填入ret指向地址即可。<br>Ret的值需要指向shellcode，而buf大小不确定，因此ret指向地址必须大于buf最大值+8，以执行ret上方的shellcode，避免从下面空转到ret陷入循环。<br> <img src="/img/os_stackoverflow/image-7.png" alt="Alt text"></p><h3 id="生成badfile，获取服务器权限。"><a href="#生成badfile，获取服务器权限。" class="headerlink" title="生成badfile，获取服务器权限。"></a>生成badfile，获取服务器权限。</h3><h2 id="4-Task4-Level-3-Attack"><a href="#4-Task4-Level-3-Attack" class="headerlink" title="4. Task4 Level-3 Attack"></a>4. Task4 Level-3 Attack</h2><h3 id="attack-code传入hello获取server堆栈信息。"><a href="#attack-code传入hello获取server堆栈信息。" class="headerlink" title="attack-code传入hello获取server堆栈信息。"></a>attack-code传入hello获取server堆栈信息。</h3><p> <img src="/img/os_stackoverflow/image-8.png" alt="Alt text"><br>Rbp指针：0x00007fffffffe540<br>Buf基地址：0x00007fffffffe470</p><h3 id="编写exploit-py文件。-2"><a href="#编写exploit-py文件。-2" class="headerlink" title="编写exploit.py文件。"></a>编写exploit.py文件。</h3><p>首先插入64位的shellcode，并把执行命令改为反弹shell。<br>start的值设置为0，此时shellcode在content头部，位置为content[0,len(shellcode)]。<br>Ret地址为rbp地址+8（64位环境），offset的值为ret地址-buf基地址。<br>ret的值指向shellcode地址，此时shellcode代码在content头部，即buf基地址0x470。<br> <img src="/img/os_stackoverflow/image-9.png" alt="Alt text"></p><h3 id="生成badfile，获取服务器权限-1"><a href="#生成badfile，获取服务器权限-1" class="headerlink" title="生成badfile，获取服务器权限"></a>生成badfile，获取服务器权限</h3><p> <img src="/img/os_stackoverflow/image-10.png" alt="Alt text"></p><h2 id="5-Task5-Level-4-Attack"><a href="#5-Task5-Level-4-Attack" class="headerlink" title="5. Task5 Level-4 Attack"></a>5. Task5 Level-4 Attack</h2><h3 id="attack-code传入hello，获取server堆栈信息。-1"><a href="#attack-code传入hello，获取server堆栈信息。-1" class="headerlink" title="attack-code传入hello，获取server堆栈信息。"></a>attack-code传入hello，获取server堆栈信息。</h3><p> <img src="/img/os_stackoverflow/image-11.png" alt="Alt text"><br>Rbp指针：0x00007fffffffe540<br>Buf基地址：0x00007fffffffe470</p><h3 id="编写exploit-py文件"><a href="#编写exploit-py文件" class="headerlink" title="编写exploit.py文件"></a>编写exploit.py文件</h3><p>相比于上一个task，这个task实行shellcode依靠于Return-to-libc，因此需要改变ret指向地址。<br>        经过尝试以后，ret为rbp+1400的时候能够实现反弹shell。<br><img src="/img/os_stackoverflow/image-12.png" alt="Alt text"> </p><h3 id="生成badfile，获取服务器权限。-1"><a href="#生成badfile，获取服务器权限。-1" class="headerlink" title="生成badfile，获取服务器权限。"></a>生成badfile，获取服务器权限。</h3><p> <img src="/img/os_stackoverflow/image-13.png" alt="Alt text"></p><h2 id="6-Task6-Level-5-Attack"><a href="#6-Task6-Level-5-Attack" class="headerlink" title="6. Task6 Level-5 Attack"></a>6. Task6 Level-5 Attack</h2><h3 id="打开地址随机化。"><a href="#打开地址随机化。" class="headerlink" title="打开地址随机化。"></a>打开地址随机化。</h3><p> <img src="/img/os_stackoverflow/image-14.png" alt="Alt text"></p><h3 id="attack-code传入hello，获取server堆栈信息。-2"><a href="#attack-code传入hello，获取server堆栈信息。-2" class="headerlink" title="attack-code传入hello，获取server堆栈信息。"></a>attack-code传入hello，获取server堆栈信息。</h3><p>可以发现随着地址随机化的打开，server堆栈地址发生改变。<br> <img src="/img/os_stackoverflow/image-15.png" alt="Alt text"><br> <img src="/img/os_stackoverflow/image-16.png" alt="Alt text"></p><h3 id="编写exploit-py文件。-3"><a href="#编写exploit-py文件。-3" class="headerlink" title="编写exploit.py文件。"></a>编写exploit.py文件。</h3><p> <img src="/img/os_stackoverflow/image-17.png" alt="Alt text"></p><h3 id="生成badfile，运行脚本brute-force-sh不断向server传入badfile。"><a href="#生成badfile，运行脚本brute-force-sh不断向server传入badfile。" class="headerlink" title="生成badfile，运行脚本brute-force.sh不断向server传入badfile。"></a>生成badfile，运行脚本brute-force.sh不断向server传入badfile。</h3><p>当server程序满足badfile的堆栈条件时，脚本停止，成功获取服务器权限。<br> <img src="/img/os_stackoverflow/image-18.png" alt="Alt text"><br> <img src="/img/os_stackoverflow/image-19.png" alt="Alt text"><br> <img src="/img/os_stackoverflow/image-20.png" alt="Alt text"></p><h2 id="7-Task7-Level-6-Attack"><a href="#7-Task7-Level-6-Attack" class="headerlink" title="7.Task7 Level-6 Attack"></a>7.Task7 Level-6 Attack</h2><h3 id="在server-code目录下："><a href="#在server-code目录下：" class="headerlink" title="在server-code目录下："></a>在server-code目录下：</h3><p>去除-fon-stack-protector选项（即打开栈保护机制）编译stack.c，将badfile输入。<br>Server成功检测到stack smashing（堆栈溢出漏洞）<br> <img src="/img/os_stackoverflow/image-21.png" alt="Alt text"></p><h3 id="在shellcode目录下："><a href="#在shellcode目录下：" class="headerlink" title="在shellcode目录下："></a>在shellcode目录下：</h3><p>去除-z execstack（这个选项会认为栈空间的指令可以被执行，因此我们才能之前的实验运行栈溢出的shellcode和空转指令）编译call_shellcode.c编译并运行。<br><img src="/img/os_stackoverflow/image-22.png" alt="Alt text"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恶意URL检测</title>
      <link href="/2023/10/11/ai_maliciousurldetection/"/>
      <url>/2023/10/11/ai_maliciousurldetection/</url>
      
        <content type="html"><![CDATA[<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><pre><code class="python"># 数据提取&amp;处理（csv）import pandas as pdfrom sklearn.utils import shuffle# 特征提取import refrom sklearn.feature_extraction.text import TfidfVectorizer# 训练集和测试集划分from sklearn.model_selection import train_test_split# 逻辑回归算法训练模型from sklearn.linear_model import LogisticRegression# 模型评估报告打印from sklearn.metrics import classification_report# 模型保存import pickledef read_dmoz0409(file_path, lable):    normal_pd = pd.read_csv(file_path, header=None, names=[&quot;url&quot;], usecols=[1], nrows=14989)    normal_pd[&quot;lable&quot;] = lable    # print(normal_pd)    return normal_pddef read_phishing_verified_online(file_path, lable):    malicious_pd = pd.read_csv(file_path, usecols=[1], nrows=14989)    malicious_pd[&quot;lable&quot;] = lable    # print(malicious_pd)    return malicious_pddef data_process(normal, malicious):    all = pd.concat([normal, malicious])    data = all[&quot;url&quot;]    lable = all[&quot;lable&quot;]    data, lable = shuffle(data, lable, random_state=42)    return data, labledef data_tokenizer(data):    return re.findall(r&#39;\w+&#39;, data)def data_vectorizer(data, lable):    vectorizer = TfidfVectorizer(tokenizer=data_tokenizer)    x = vectorizer.fit_transform(data)    y = lable    return x, y, vectorizerdef model_train(x_train, y_train):    model = LogisticRegression()    model.fit(x_train, y_train)    return modeldef model_test(model, x_test, y_test):    # accuracy = model.score(x_test, y_test)    # print(&quot;模型准确率:&quot;, accuracy)    y_predict = model.predict(x_test)    report = classification_report(y_test, y_predict, labels=[&quot;malicious&quot;, &quot;normal&quot;], target_names=[&quot;恶意URL&quot;, &quot;正常URL&quot;],digits=2)    return reportdef model_save(model, vectorizer, report):    save = input(&quot;是否保存训练的模型（y/n）：&quot;)    if save == &quot;y&quot; or save == &quot;Y&quot;:        with open(&#39;model.pkl&#39;, &#39;wb&#39;) as f:            pickle.dump(model, f)        with open(&#39;vectorizer.pkl&#39;, &#39;wb&#39;) as f:            pickle.dump(vectorizer, f)        with open(&#39;report.txt&#39;, &#39;w&#39;) as f:            f.write(report)        print(&quot;保存成功！&quot;)        return True    else:        return Falsedef new_model():    # 数据提取    print(&quot;数据提取...&quot;)    normal = read_dmoz0409(&quot;dmoz0409.csv&quot;, &quot;normal&quot;)    malicious = read_phishing_verified_online(&quot;phishing_verified_online.csv&quot;, &quot;malicious&quot;)    # 数据处理（合并，打乱数据集）    print(&quot;数据处理...&quot;)    data, lable = data_process(normal, malicious)    # 特征提取    print(&quot;向量化...&quot;)    x, y, vectorizer = data_vectorizer(data, lable)    # print(vectorizer.vocabulary_)    # print(x.toarray)    # 数据集划分    x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3)    # 模型训练    print(&quot;模型训练...&quot;)    model = model_train(x_train, y_train)    # 模型评估    report = model_test(model, x_test, y_test)    print(&quot;模型评估报告：&quot; + &quot;\n&quot;, report)    # 模型保存?    model_save(model, vectorizer, report)def use_model():    while True:        url_list = input(&quot;输入需要测试的url：&quot;).split(&quot;\n&quot;)        with open(&quot;vectorizer.pkl&quot;, &quot;rb&quot;) as f:            vectorizer = pickle.load(f)        x = vectorizer.transform(url_list)        with open(&quot;model.pkl&quot;, &quot;rb&quot;) as f:            model = pickle.load(f)        y_predict = model.predict(x)        for i in range(len(url_list)):            print(url_list[i], y_predict[i])if __name__ == &quot;__main__&quot;:    choice = input(&quot;训练新的模型或是使用已经训练的模型（train/use）：&quot;)    if choice == &quot;train&quot;:        new_model()    elif choice==&quot;use&quot;:        print(&quot;-------恶意URL检测-------&quot;)        use_model()    else:        print(&quot;无效的输入！&quot;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> AI </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> sklearn </tag>
            
            <tag> url </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS注入检测</title>
      <link href="/2023/10/10/ai_xssdetection/"/>
      <url>/2023/10/10/ai_xssdetection/</url>
      
        <content type="html"><![CDATA[<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><p><em><strong>pd对象和python字典类似，行为属性，列为列表</strong></em></p><h3 id="pd-read-csv-函数："><a href="#pd-read-csv-函数：" class="headerlink" title="pd.read_csv()函数："></a>pd.read_csv()函数：</h3><ul><li>参数header：pandas是否选择csv文件第一行作为列名</li><li>参数usecols：pandas读取csv文件列</li></ul><h3 id="pd-to-csv-函数："><a href="#pd-to-csv-函数：" class="headerlink" title="pd.to_csv()函数："></a>pd.to_csv()函数：</h3><ul><li>参数header：pandas是否将属性名写入csv文件</li><li>参数columns：pandas写入csv文件的属性（<em>影响写入的顺序</em>）</li><li>参数index：pandas是否写入序号</li></ul><pre><code class="python"># 数据提取&amp;处理import pandas as pdfrom sklearn.utils import shuffle# 特征提取import refrom sklearn.feature_extraction.text import TfidfVectorizer# 训练集和测试集划分from sklearn.model_selection import train_test_split# 逻辑回归算法训练模型from sklearn.linear_model import LogisticRegression# 模型评估报告打印from sklearn.metrics import classification_report# 模型保存import pickledef read_csv(file_path, lable):    data = pd.read_csv(file_path, header=None, names=[&quot;str&quot;], usecols=[0])    data[&quot;lable&quot;] = lable    return data# normal = read_csv(&quot;dmzo_nomal.csv&quot;, &quot;normal&quot;)# xss = read_csv(&quot;xssed.csv&quot;, &quot;xss&quot;)def data_process(normal, xss):    all = pd.concat([normal, xss])    data = all[&quot;str&quot;]    lable = all[&quot;lable&quot;]    data, lable = shuffle(data, lable, random_state=42)    return data, lable# data ,lable = data_process(normal, xss)def data_tokenizer(data):    return re.findall(r&#39;\w+&#39;, data)def data_vectorizer(data,lable):    vectorizer = TfidfVectorizer(tokenizer=data_tokenizer)    x = vectorizer.fit_transform(data)    y = lable    return x, y, vectorizer# x, y ,vectorizer = data_vectorizer(data, lable)# x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3)def model_train(x_train, y_train):    model = LogisticRegression()    model.fit(x_train, y_train)    return model# model = model_train(x_train, y_train)def model_evaluate(x_test,y_test):    y_predict = model.predict(x_test)    report = classification_report(y_test, y_predict, labels=[&quot;xss&quot;, &quot;normal&quot;], target_names=[&quot;xss字符串&quot;, &quot;正常字符串&quot;],digits=2)    return report# report = model_evaluate(x_test, y_test)# print(report)def model_save(model, vectorizer):    save = input(&quot;是否保存训练的模型（y/n）：&quot;)    if save == &quot;y&quot; or &quot;Y&quot;:        print(save)        with open(&#39;model.pkl&#39;, &#39;wb&#39;) as f:            pickle.dump(model, f)        with open(&#39;vectorizer.pkl&#39;, &#39;wb&#39;) as f:            pickle.dump(vectorizer, f)        print(&quot;保存成功！&quot;)        return True    else:        return False# model_save(model, vectorizer)if __name__ == &quot;__main__&quot;:    print(&quot;-------XSS检测-------&quot;)    while True:        with open(&quot;model.pkl&quot;, &#39;rb&#39;) as f:            model = pickle.load(f)        with open(&#39;vectorizer.pkl&#39;, &#39;rb&#39;) as f:            vectorizer = pickle.load(f)        str_list = input(&quot;输入需要检测的字符串:&quot;).split(&quot;\n&quot;)        x = vectorizer.transform(str_list)        y_predict = model.predict(x)        print(&quot;检测结果为：&quot;,y_predict)</code></pre>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> AI </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> sklearn </tag>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习：写在前面</title>
      <link href="/2023/10/10/ai_pre/"/>
      <url>/2023/10/10/ai_pre/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><p>在很多场景，</p><h2 id="分类-回归"><a href="#分类-回归" class="headerlink" title="分类&amp;回归"></a>分类&amp;回归</h2><p>简单来说，分类解决离散问题；回归解决连续问题。</p><p>分类（Binary Classification）：一个例子，对于给定的一个字符串，检测是否为恶意的，那么这种就是分类问题，一般来说二分类问题比较常见。</p><p>回归（Regression）：给定一个人的各方面信息，评估他的个人收入，他的收入显然是有大量可能的，因此这是回归问题。</p><h2 id="分类模型"><a href="#分类模型" class="headerlink" title="分类模型"></a>分类模型</h2><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><h2 id="回归模型"><a href="#回归模型" class="headerlink" title="回归模型"></a>回归模型</h2><h3 id="Logist回归"><a href="#Logist回归" class="headerlink" title="Logist回归"></a>Logist回归</h3><h3 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h3><p><a href="https://zhuanlan.zhihu.com/p/26262151">了解更多</a></p><h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><h2 id="机器学习一般步骤："><a href="#机器学习一般步骤：" class="headerlink" title="机器学习一般步骤："></a>机器学习一般步骤：</h2><ul><li>文件读取</li><li>数据处理</li><li>特征提取&amp;向量化</li><li>训练集&amp;测试集划分</li><li>模型训练</li><li>模型测试</li><li>模型保存</li><li>模型使用</li></ul><h3 id="1-文件读取"><a href="#1-文件读取" class="headerlink" title="1. 文件读取"></a>1. 文件读取</h3><p>一般来说，数据集存储在txt或者csv文件中，它包括数据和标签两个部分。</p><p>需要注意的是数据集的并没有统一格式，需要根据具体情况便携代码。</p><p>首先将其读入程序，以便我们能够处理，可以将其读入列表，字典或者pd对象当中。</p><p>下面提供pandas读取csv文件的代码，并将数据集存储到pd对象中：</p><pre><code class="python">def read_file(file_path):    file_pd = pd.read_csv(file_path, usecols=[&quot;data&quot;,&quot;lable&quot;])    return file_pd</code></pre><ul><li>程序数据处理</li></ul><pre><code class="Python">def data_process(normal, malicious):    all = pd.concat([normal, malicious])    data = all[&quot;data&quot;]    lable = all[&quot;lable&quot;]    data, lable = shuffle(data, lable, random_state=42)    return data, labledata, lable = data_process(normal, malicious)</code></pre><ul><li>特征向量</li></ul><pre><code class="Python">def data_tokenizer(data):    return re.findall(r&#39;\w+&#39;, data)def data_vectorizer(data, lable):    vectorizer = TfidfVectorizer(stop_words=None, tokenizer=data_tokenizer)    x = vectorizer.fit_transform(data)    y = lable    return x, y, vectorizer</code></pre><ul><li>训练集&amp;测试集</li></ul><pre><code class="Python">    x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3)</code></pre><ul><li>模型训练</li></ul><pre><code class="Python">def model_train(x_train, y_train):    # 在这里选择适合适的模型    model = modelname()    model.fit(x_train, y_train)    return model</code></pre><ul><li>模型测试</li></ul><pre><code class="Python">def model_test(model, x_test, y_test):    y_predict = model.predict(x_test)    report = classification_report(y_test, y_predict, labels=[&quot;malicious&quot;, &quot;normal&quot;], target_names=[&quot;恶意URL&quot;, &quot;正常URL&quot;],digits=2)    return report</code></pre><ul><li>优化</li></ul>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> sklearn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾邮件检测</title>
      <link href="/2023/10/07/ai_spamdetection/"/>
      <url>/2023/10/07/ai_spamdetection/</url>
      
        <content type="html"><![CDATA[<h2 id="1-数据集"><a href="#1-数据集" class="headerlink" title="1. 数据集"></a>1. 数据集</h2><h3 id="tre06c"><a href="#tre06c" class="headerlink" title="tre06c"></a>tre06c</h3><p>tre06c&#x2F;data：邮件数据，包括真实世界的正常邮件和垃圾邮件</p><p>tre06c&#x2F;full：标签</p><h2 id="2-数据提取-处理"><a href="#2-数据提取-处理" class="headerlink" title="2. 数据提取&amp;处理"></a>2. 数据提取&amp;处理</h2><p><em><strong><a href="https://github.com/fxsjy/jieba/blob/master/README.md">jieba官方文档</a></strong></em></p><p><em><strong>列表推导式（expression for li in list if condition）</strong></em></p><h3 id="读取邮件数据"><a href="#读取邮件数据" class="headerlink" title="读取邮件数据"></a>读取邮件数据</h3><p>递归读取目录trec06c&#x2F;data的文件，获取邮件数据并进行分词处理，返回处理后的邮件列表。</p><pre><code class="python"># 读取邮件数据def read_file(file_path):    # print(file_path)    email_list = []    files = os.listdir(file_path)    for file in files:        if os.path.isdir(file_path + &#39;/&#39; + file):            email_list = email_list + read_file(file_path + &#39;/&#39; + file)        else:            with open(file_path + &#39;/&#39; + file, &#39;r&#39;, encoding=&#39;gbk&#39;, errors=&#39;ignore&#39;) as f:                email = f.read()            # 替换非汉字字符            email = re.sub(r&quot;[^\u4e00-\u9fff]&quot;, &quot; &quot;, email)            # 替换连续的空格            email = re.sub(r&quot;\s&#123;2,&#125;&quot;, &quot; &quot;, email)            # 去除首尾的空格            email = email.strip()            # 结巴分词            email = [word for word in jieba.lcut(email) if word.strip() != &#39; &#39;]            email = &#39; &#39;.join(email)            email_list.append(email)    return email_list# email = read_file(&quot;trec06c/data&quot;)</code></pre><h3 id="读取标签数据"><a href="#读取标签数据" class="headerlink" title="读取标签数据"></a>读取标签数据</h3><p>读取文件trec06c&#x2F;full&#x2F;index，获取邮件标签列表。</p><pre><code class="python"># 读取标签数据def read_lable(file_path):    lable = []    with open(file_path, &quot;r&quot;) as f:        for l in f.readlines():            if &quot;s&quot; in l:                lable.append(&quot;spam&quot;)            else:                lable.append(&quot;ham&quot;)    return lable# lable = read_lable(&quot;trec06c/full/index&quot;)</code></pre><h3 id="打乱数据顺序"><a href="#打乱数据顺序" class="headerlink" title="打乱数据顺序"></a>打乱数据顺序</h3><pre><code class="python">def data_process(email, lable):    email, lable = shuffle(email, lable, random_state=42)    return email, lable# email, lable = data_process(email, lable)</code></pre><h2 id="3-词云"><a href="#3-词云" class="headerlink" title="3. 词云"></a>3. 词云</h2><p>随便写写，感觉词云有一些bug，同一个词重复出现</p><pre><code class="python"># 词云def word_cloud(text):    wc = WordCloud(        background_color = &quot;white&quot;,        max_words = 200,        # 可以使用其他字体        # 但是如果无法正常显示，需要更换字体        font_path = &quot;C:\Windows\Fonts\SIMYOU.ttf&quot;,        min_font_size = 15,        max_font_size = 50,        width = 600    )    wordcloud = wc.generate(text)    wordcloud.to_file(&#39;jieba.jpg&#39;)with open(&#39;./jieba.txt&#39;, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:    txt = f.readlines()showWordCloud(&#39; &#39;.join(txt))</code></pre><p>全部邮件词云：</p><p><img src="/img/ai_spamdetection/email.jpg" alt="Alt text"></p><pre><code class="python">spam_list = []ham_list = []with open(&quot;./full.txt&quot;, &quot;r&quot;, encoding=&#39;utf-8&#39;) as f:    tag_list = f.readlines()    with open(&quot;./jb.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;) as g:        email_list = g.readlines()        i = 0        for tag in tag_list:            if tag[0] == &#39;1&#39;:                spam = email_list[i]                spam_list.append(spam)            elif tag[0] == &#39;0&#39;:                ham = email_list[i]                ham_list.append(ham)            i = i + 1</code></pre><p>垃圾邮件词云：</p><p><img src="/img/ai_spamdetection/ham.jpg" alt="Alt text"></p><p>正常邮件词云：</p><p><img src="/img/ai_spamdetection/spam.jpg" alt="Alt text"></p><h2 id="4-特征提取"><a href="#4-特征提取" class="headerlink" title="4. 特征提取"></a>4. 特征提取</h2><pre><code class="python">def data_vectorizer(email,lable):    # 邮件样本已经分好了词，词之间用空格隔开，所以 tokenizer=tokenizer_space    vectoring = TfidfVectorizer(input=&#39;content&#39;, analyzer=&#39;word&#39;)    x = vectoring.fit_transform(email)    y = lable    return x, y, vectoring# x, y, vectorizer = data_vectorizer(email, lable)</code></pre><h2 id="5-换分数据集"><a href="#5-换分数据集" class="headerlink" title="5. 换分数据集"></a>5. 换分数据集</h2><pre><code class="python"># x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3)</code></pre><h2 id="6-模型训练"><a href="#6-模型训练" class="headerlink" title="6. 模型训练"></a>6. 模型训练</h2><pre><code class="python">def model_train(x_train, y_train):    model = svm.LinearSVC()    model.fit(x_train, y_train)    return model# model = model_train(x_train, y_train)</code></pre><h2 id="7-模型测试"><a href="#7-模型测试" class="headerlink" title="7. 模型测试"></a>7. 模型测试</h2><pre><code class="python">def model_test(x_test, y_test):    y_pred = model.predict(x_test)    report = classification_report(y_test, y_pred, digits=2)    return report# report = model_test(model)</code></pre><h2 id="8-模型保存"><a href="#8-模型保存" class="headerlink" title="8. 模型保存"></a>8. 模型保存</h2><pre><code class="python">def model_save(model,vectorizer,report):    save = input(&quot;是否保存训练的模型（y/n）：&quot;)    if save == &quot;y&quot; or &quot;Y&quot;:        with open(&#39;model.pkl&#39;, &#39;wb&#39;) as f:            pickle.dump(model, f)        with open(&#39;vectorizer.pkl&#39;, &#39;wb&#39;) as f:            pickle.dump(vectorizer, f)        with open(&#39;report.txt&#39;, &#39;w&#39;) as f:            f.write(report)        print(&quot;保存成功！&quot;)        return True    else:        return False# model_save(model, vectorizer, report)</code></pre><h2 id="9-模型使用"><a href="#9-模型使用" class="headerlink" title="9. 模型使用"></a>9. 模型使用</h2><pre><code class="python">if __name__ == &quot;__main__&quot;:    print(&quot;-------垃圾邮件检测-------&quot;)    while True:        with open(&quot;model.pkl&quot;, &#39;rb&#39;) as f:            model = pickle.load(f)        with open(&#39;vectorizer.pkl&#39;, &#39;rb&#39;) as f:            vectorizer = pickle.load(f)        file_path = input(&quot;输入需要检测的邮件文件的路径:&quot;)        with open(file_path, &quot;r&quot;, encoding=&quot;gbk&quot;, errors=&quot;ignore&quot;) as f:            email = f.read()        email_list = [email]        print(email)        x = vectorizer.transform(email_list)        y_predict = model.predict(x)        print(&quot;检测结果为：&quot;, y_predict[0])</code></pre><h2 id="源代码-数据集"><a href="#源代码-数据集" class="headerlink" title="源代码&amp;数据集"></a>源代码&amp;数据集</h2><p>注释的代码用于生成模型。</p><p>如果已经生成了模型，main函数用于调用模型检测邮件。</p><pre><code class="python"># 数据提取import os# 数据处理from sklearn.utils import shuffleimport reimport jieba# 提取特征from sklearn.feature_extraction.text import TfidfVectorizer# 划分训练集，测试集from sklearn.model_selection import train_test_split# 训练模型from sklearn import svm# 模型评估报告from sklearn import metrics# 模型保存import pickle# # 递归读取文件夹内所有文件# def list_file(file_path):#     file_list = []#     files = os.listdir(file_path)#     for file in files:#         if os.path.isdir(file_path + &#39;/&#39; + file):#             file_list = file_list + list_file(file_path + &#39;/&#39; + file)#         else:#             file_list.append(file_path + &#39;/&#39; + file)##     return file_list# # 读取邮件数据# def read_email(file_list):#     email = []#     for file in file_list:#         with open(file, &quot;r&quot;, encoding=&#39;gbk&#39;, errors=&#39;ignore&#39;) as f:#             email = email + f.readlines()##     return email# 读取邮件数据def read_file(file_path):    # print(file_path)    email_list = []    files = os.listdir(file_path)    for file in files:        if os.path.isdir(file_path + &#39;/&#39; + file):            email_list = email_list + read_file(file_path + &#39;/&#39; + file)        else:            with open(file_path + &#39;/&#39; + file, &#39;r&#39;, encoding=&#39;gbk&#39;, errors=&#39;ignore&#39;) as f:                email = f.read()            # 替换连续的空格            email = re.sub(r&quot;[^\u4e00-\u9fff]&quot;, &quot; &quot;, email)            # 替换非汉字字符            email = re.sub(r&quot;\s&#123;2,&#125;&quot;, &quot; &quot;, email)            # 去除首尾的空格            email = email.strip()            # 结巴分词            email = [word for word in jieba.lcut(email) if word.strip() != &#39; &#39;]            email = &#39; &#39;.join(email)            email_list.append(email)    return email_list# email = read_file(&quot;trec06c/data&quot;)# 读取标签数据def read_lable(file_path):    lable = []    with open(file_path, &quot;r&quot;) as f:        for l in f.readlines():            if &quot;s&quot; in l:                lable.append(&quot;spam&quot;)            else:                lable.append(&quot;ham&quot;)    return lable# lable = read_lable(&quot;trec06c/full/index&quot;)# 数据处理def data_process(email, lable):    email, lable = shuffle(email, lable, random_state=42)    return email, lable# email, lable = data_process(email, lable)# 特征提取def data_vectorizer(email,lable):    # 邮件样本已经分好了词，词之间用空格隔开，所以 tokenizer=tokenizer_space    vectoring = TfidfVectorizer(input=&#39;content&#39;, analyzer=&#39;word&#39;)    x = vectoring.fit_transform(email)    y = lable    return x, y, vectoring# x, y, vectorizer = data_vectorizer(email, lable)# 划分训练集和测试集# x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3)def model_train(x_train, y_train):    model = svm.LinearSVC()    model.fit(x_train, y_train)    return model# model = model_train(x_train, y_train)def model_test(x_test, y_test):    y_pred = model.predict(x_test)    print(&quot;模型评估报告：\n&quot;, metrics.classification_report(y_test, y_pred, digits=2))# model_test(model)def model_save(model, vectorizer):    save = input(&quot;是否保存训练的模型（y/n）：&quot;)    if save == &quot;y&quot; or &quot;Y&quot;:        with open(&#39;model.pkl&#39;, &#39;wb&#39;) as f:            pickle.dump(model, f)        with open(&#39;vectorizer.pkl&#39;, &#39;wb&#39;) as f:            pickle.dump(vectorizer, f)        print(&quot;保存成功！&quot;)        return True    else:        return False# model_save(model, vectorizer)if __name__ == &quot;__main__&quot;:    print(&quot;-------垃圾邮件检测-------&quot;)    while True:        with open(&quot;model.pkl&quot;, &#39;rb&#39;) as f:            model = pickle.load(f)        with open(&#39;vectorizer.pkl&#39;, &#39;rb&#39;) as f:            vectorizer = pickle.load(f)        file_path = input(&quot;输入需要检测的邮件文件的路径:&quot;)        with open(file_path, &quot;r&quot;, encoding=&quot;gbk&quot;, errors=&quot;ignore&quot;) as f:            email = f.read()        email_list = [email]        print(email)        x = vectorizer.transform(email_list)        y_predict = model.predict(x)        print(&quot;检测结果为：&quot;, y_predict[0])</code></pre>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> spam </tag>
            
            <tag> jieba </tag>
            
            <tag> AI </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> sklearn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MD5碰撞试验</title>
      <link href="/2023/10/01/cipher_md5/"/>
      <url>/2023/10/01/cipher_md5/</url>
      
        <content type="html"><![CDATA[<h1 id="一、作业题目"><a href="#一、作业题目" class="headerlink" title="一、作业题目"></a>一、作业题目</h1><p>本次实验主要是加深大家对MD5碰撞及其原理的理解，使用SEED实验环境中的工具及编程语言，完成以下任务：</p><p><em><strong>1.使用md5collgen生成两个MD5值相同的文件，并利用bless十六进制编辑器查看输出的两个文件，描述你观察到的情况；</strong></em></p><p><em><strong>2.参考Lab3_task2.c的代码，生成两个MD5值相同但输出不同的两个可执行文件。</strong></em></p><p><em><strong>3.参考Lab3_task3.c的代码，生成两个MD5值相同但代码行为不相同的可执行文件。</strong></em></p><p><em><strong>4.回答问题：通过上面的实验，请解释为什么可以做到不同行为的两个可执行文件具有相同的MD5值？</strong></em></p><h1 id="二、实验步骤及结果"><a href="#二、实验步骤及结果" class="headerlink" title="二、实验步骤及结果"></a>二、实验步骤及结果</h1><h2 id="1-md5collgen生成碰撞文件"><a href="#1-md5collgen生成碰撞文件" class="headerlink" title="1.md5collgen生成碰撞文件"></a>1.md5collgen生成碰撞文件</h2><h3 id="新建前缀文件prefix-txt"><a href="#新建前缀文件prefix-txt" class="headerlink" title="新建前缀文件prefix.txt"></a>新建前缀文件prefix.txt</h3><p> <img src="/img/cipher_md5/image.png" alt="Alt text"><br>###用md5collgen生成碰撞文件out1.bin和out2.bin<br>.&#x2F;md5collgen -p prefix.txt -o out1.bin out2.bin<br> <img src="/img/cipher_md5/image-1.png" alt="Alt text"><br>###使用bless比较两个文件内容<br>两个文件小部分内容不同。<br> <img src="/img/cipher_md5/image-2.png" alt="Alt text"><br> <img src="/img/cipher_md5/image-3.png" alt="Alt text"><br>###比价两个文件md5值<br>md5sum xxx检查文件md5值，发现这两个不同内容的文件有相同的md5值。（md5算法将文件压缩到128位）<br> <img src="/img/cipher_md5/image-4.png" alt="Alt text"><br>###分析<br>首先，out1.bin和out2.bin文件前面部分都是prefix.txt文件内容，但进行了补全，补全的部分是前64字节。</p><p>其次，out1,bin和out2.bin文件后半部分都是128字节，且这部分包含了这两个文件的差异，并且两个文件的差异比较小。</p><h2 id="2-Lab3-task2-c文件碰撞"><a href="#2-Lab3-task2-c文件碰撞" class="headerlink" title="2.Lab3_task2.c文件碰撞"></a>2.Lab3_task2.c文件碰撞</h2><h3 id="新建文件task2-c"><a href="#新建文件task2-c" class="headerlink" title="新建文件task2.c"></a>新建文件task2.c</h3><p> <img src="/img/cipher_md5/image-5.png" alt="Alt text"><br> <img src="/img/cipher_md5/image-6.png" alt="Alt text"><br>###编译文件<br>gcc task.c -o task<br>###寻找替换程序字符串部分<br>因为md5collgen的prefix部分需要是64字节的倍数，否则补全可能会造成task程序无法运行。因此在task程序找到字符串部分中64字节倍数作为前缀。<br> <img src="/img/cipher_md5/image-7.png" alt="Alt text"><br>（0x3040 &#x3D;&gt; 12352；12352&#x2F;64 &#x3D; 193）<br>###剪切出前缀文件，并生成替换文件<br>从12352字节开始剪切，注意的是生成文件会额外占据128字节，因此要将中间的128字节去掉。<br> <img src="/img/cipher_md5/image-8.png" alt="Alt text"><br>生成替换文件task_out1.bin和task_out2.bin文件<br> <img src="/img/cipher_md5/image-9.png" alt="Alt text"><br>###拼接生成的文件和后缀，并执行这两个文件。<br>可以发现这两个文件输出是不一样的，原因就是md5collgen生成的两个文件128字节不同导致输出字符发生改变。<br> <img src="/img/cipher_md5/image-10.png" alt="Alt text"><br>###分析<br>查看两个文件md5值，发现一样，但是输出不一样（也就是程序中的字符串不一样）。原理就是md5collgen生成的文件改变了字符串，但是没有让md5值发生改变。<br> <img src="/img/cipher_md5/image-11.png" alt="Alt text"></p><h2 id="3-Lab3-task3-c文件碰撞"><a href="#3-Lab3-task3-c文件碰撞" class="headerlink" title="3.Lab3_task3.c文件碰撞"></a>3.Lab3_task3.c文件碰撞</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>题目分析：代码判断两个变量是否相等导致不同的输出路径；构造两个程序相同md5值有不同输出路径。</p><p>思路：源程序A构造两个相同变量x，y；程序B利用md5构造两个相同变量，输出路径为：&#x3D;&#x3D;；程序C利用md5collgen构造两个不同变量保持和程序A相同的md5值，输出路径为：!&#x3D;，<br>###编写程序task3_a.c<br>上面未显示的部分定义了两个相同的字符串x和y，都是200个0x41（“A”）。<br> <img src="/img/cipher_md5/image-12.png" alt="Alt text"><br>###这里task3_a程序与之前程序类似，我们定位到字符串内容依旧可以选取0x3040进行截取（对应下一个字符串0x3120）。截取的程序头部为task3_pre。<br> <img src="/img/cipher_md5/image-13.png" alt="Alt text"></p><p>利用截取的头部tsak3_pre生成程序头task3_b，task3_c<br> <img src="/img/cipher_md5/image-14.png" alt="Alt text"><br>###拼接字符串x得到程序task3_b，task3_c<br> <img src="/img/cipher_md5/image-15.png" alt="Alt text"><br>###在bless调整字符串y得到task3_b，task3_c<br>Task3_b的x，y字符串相同<br> <img src="/img/cipher_md5/image-16.png" alt="Alt text"><br> <img src="/img/cipher_md5/image-17.png" alt="Alt text"><br>task3_c的x，y字符串不同，y字符串来自task3_b<br> <img src="/img/cipher_md5/image-18.png" alt="Alt text"><br>###运行两个文件<br>检查两个程序md5值<br> <img src="/img/cipher_md5/image-19.png" alt="Alt text"></p><p>可以发现这两个程序走向了两个不同的方向。因为程序B字符串x，y都是md5collgen生成的同一个，然而程序C的x，y字符串则是md5collgen生成的两个不同的。但是它们的md5值相等。<br> <img src="/img/cipher_md5/image-20.png" alt="Alt text"></p><h2 id="4-相同md5值，不同行为的程序？"><a href="#4-相同md5值，不同行为的程序？" class="headerlink" title="4.相同md5值，不同行为的程序？"></a>4.相同md5值，不同行为的程序？</h2><p>从本质上来说，md5值是有限的（2的128次方个），然而程序是无穷的，因此两个不同行为程序完全可能有相同的md5值，碰撞不可避免。</p><p>就这道题分析：使用md5collgen可以生成两个相同md5值但是不同的文件。利用这个特性去替换程序中的字符串，使得一个程序是同一个md5collgen生成值替换，所以两个字符串一样，判断为same；另一个程序使用不同md5collgen生成值，两个字符串不一致，判断为diff，然而同为一个前缀生成，两个md5collgen生成值md5相等，两个程序的md5值也相等。</p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
            <tag> MD5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARP毒化</title>
      <link href="/2023/09/26/network_ARP/"/>
      <url>/2023/09/26/network_ARP/</url>
      
        <content type="html"><![CDATA[<h1 id="一-ARP协议概述"><a href="#一-ARP协议概述" class="headerlink" title="一. ARP协议概述"></a>一. ARP协议概述</h1><p>建议你先学习计算机网络以及ARP协议部分。</p><h2 id="1-arp缓存"><a href="#1-arp缓存" class="headerlink" title="1. arp缓存"></a>1. arp缓存</h2><h3 id="查看你的主机arp缓存"><a href="#查看你的主机arp缓存" class="headerlink" title="查看你的主机arp缓存"></a>查看你的主机arp缓存</h3><p>arp缓存表存储在主机的内存中。</p><ul><li>对于Windows操作系统，你可以在终端中使用命令 <em><strong>arp -a</strong></em> 查看电脑的arp缓存表。</li><li>对于Linux操作系统，使用命令 <em><strong>arp</strong></em> 即可。</li></ul><h3 id="你的arp缓存表的内容"><a href="#你的arp缓存表的内容" class="headerlink" title="你的arp缓存表的内容"></a>你的arp缓存表的内容</h3><p>一般来说，arp缓存只关心子网下其他主机。</p><ul><li>对于路由器下的子网，arp缓存其他主机的MAC地址为路由器（网关）的MAC地址，因为主机访问其他主机的下一跳是路由器。</li><li>对于交换机下的子网，arp缓存其他主机的真实MAC地址。</li><li>当你访问子网外的IP地址时，MAC地址默认为网关地址。</li></ul><h2 id="2-arp报文"><a href="#2-arp报文" class="headerlink" title="2. arp报文"></a>2. arp报文</h2><p>你可以使用python的scapy库写一个arp请求函数，这非常简单。</p><pre><code class="python">def arp(ipy):    dst_ip_list = IPY(ipy)    alive_ip_list = []    for dst_ip in dst_ip_list:        pkt = ARP(pdst=str(dst_ip))        # pkt.show()        ans = sr1(pkt, timeout=1, verbose=False)        if ans is not None:            # ans.summary()            # ans.show()            alive_ip_list.append(dst_ip)            print(dst_ip, &#39;is up&#39;)        else:            print(dst_ip, &#39;is closed&#39;)    return alive_ip_list</code></pre><p>构造一个请求，通过warsahrk抓包，你可以对协议的实现有更多了解。</p><h1 id="二-断断室友的网？刑"><a href="#二-断断室友的网？刑" class="headerlink" title="二. 断断室友的网？刑"></a>二. 断断室友的网？刑</h1><p><em><strong>本次实验在虚拟环境中完成，你需要知道未被授权的攻击不被允许。</strong></em></p><p>当你了解arp缓存和arp报文相关内容以后，下面这一步非常简单。</p><p>这里有两台虚拟机。Ubuntu（20.04）发起arp攻击；Windows（7）作为被攻击对象，并查看被攻击后的结果。</p><p>下面是实操部分：</p><h2 id="1-Ubuntu发起攻击"><a href="#1-Ubuntu发起攻击" class="headerlink" title="1. Ubuntu发起攻击"></a>1. Ubuntu发起攻击</h2><h3 id="安装dsniff"><a href="#安装dsniff" class="headerlink" title="安装dsniff"></a>安装dsniff</h3><p>在终端输入命令 <em><strong>sudo apt install dsniff</strong></em>，这里我已经安装完成。<br><img src="/img/network_arp/image.png" alt="Alt text"></p><h3 id="使用dsniff毒化目标主机"><a href="#使用dsniff毒化目标主机" class="headerlink" title="使用dsniff毒化目标主机"></a>使用dsniff毒化目标主机</h3><p><em><strong>网关IP：192.168.59.2</strong></em></p><p><em><strong>目标主机IP：192.168.59.137</strong></em></p><p><img src="/img/network_arp/image-2.png" alt="Alt text"></p><h2 id="2-Windows受到攻击"><a href="#2-Windows受到攻击" class="headerlink" title="2. Windows受到攻击"></a>2. Windows受到攻击</h2><h3 id="受到攻击之前"><a href="#受到攻击之前" class="headerlink" title="受到攻击之前"></a>受到攻击之前</h3><p>Windows虚拟机可以正常访问网络，这里访问百度作为测试</p><p><img src="/img/network_arp/image-1.png" alt="Alt text"></p><h3 id="受到攻击之后"><a href="#受到攻击之后" class="headerlink" title="受到攻击之后"></a>受到攻击之后</h3><p>Windows虚拟机无法正常访问网络</p><p><img src="/img/network_arp/image-3.png" alt="Alt text"></p><h3 id="看看Windows虚拟机arp缓存表"><a href="#看看Windows虚拟机arp缓存表" class="headerlink" title="看看Windows虚拟机arp缓存表"></a>看看Windows虚拟机arp缓存表</h3><p>可以看到Windows主机arp缓存被毒化之后网关IP映射的MAC地址变成了发起攻击Ubuntu的MAC地址。因此Windows虚拟机访问其他主机时，流量指向发起攻击的Ubuntu主机。利用这一点我们还可以做一些事情，比如中间人攻击。</p><p><img src="/img/network_arp/image-4.png" alt="Alt text"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARP </tag>
            
            <tag> internet </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> Protocol </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DHCP安全性分析</title>
      <link href="/2023/09/26/network_DHCP/"/>
      <url>/2023/09/26/network_DHCP/</url>
      
        <content type="html"><![CDATA[<h1 id="一-DHCP协议概述"><a href="#一-DHCP协议概述" class="headerlink" title="一. DHCP协议概述"></a>一. DHCP协议概述</h1><h2 id="1-上网配置信息"><a href="#1-上网配置信息" class="headerlink" title="1. 上网配置信息"></a>1. 上网配置信息</h2><p>计算机在连入WIFI后，需要获取网络配置信息才能正常上网，这些信息包括以下：</p><ul><li>主机IP地址</li><li>子网掩码</li><li>网关IP地址</li><li>DNS服务器IP地址</li></ul><h2 id="2-DHCP报文"><a href="#2-DHCP报文" class="headerlink" title="2. DHCP报文"></a>2. DHCP报文</h2><p>当你连入WIFI之前，使用Warshark对进行抓包，可以捕获到到以下DHCP报文：</p><ul><li>DISCOVER</li><li>OFFER</li><li>REQUEST</li><li>ACK</li></ul><p>如果你已经接入WIFI，你可以在终端输入命令 <em><strong>ipconfig release</strong></em> 释放你已经获取的网络配置信息。重新接入WIFI。</p><p>如果你只是单纯断开WIFI，那么原来的网络配置信息并不会清空。相比正常的DHCP交互缺少 <em><strong>DISCOVER</strong></em> 和 <em><strong>OFFER</strong></em> 报文。</p><h1 id="二-DHCP饿死攻击"><a href="#二-DHCP饿死攻击" class="headerlink" title="二. DHCP饿死攻击"></a>二. DHCP饿死攻击</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>DHCP服务器根据DHCP报文中提供的MAC地址分发IP地址。</p><p>因此，使用主机伪造DHCP报文中的MAC地址，耗尽DHCP能够分配的IP地址，那么正常连接网络的主机将不能够接入网络，攻击完成。</p><h2 id="2-试试？"><a href="#2-试试？" class="headerlink" title="2. 试试？"></a>2. 试试？</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>Windows7（虚拟机）；Ubuntu20.04（虚拟机）</p><h3 id="下载Yersinia"><a href="#下载Yersinia" class="headerlink" title="下载Yersinia"></a>下载Yersinia</h3><p><em><strong>sudo apt install yersinia</strong></em></p><p><img src="/img/network_dhcp/image-6.png" alt="Alt text"></p><h3 id="打开Yersinia图形界面"><a href="#打开Yersinia图形界面" class="headerlink" title="打开Yersinia图形界面"></a>打开Yersinia图形界面</h3><p><em><strong>yersinia -G</strong></em></p><p>作者还挺幽默哈</p><p><img src="/img/network_dhcp/image-5.png" alt="Alt text"></p><h3 id="发起攻击"><a href="#发起攻击" class="headerlink" title="发起攻击"></a>发起攻击</h3><p><img src="/img/network_dhcp/image-9.png" alt="Alt text"></p><h3 id="攻击情况"><a href="#攻击情况" class="headerlink" title="攻击情况"></a>攻击情况</h3><p>warshark抓包分析<br>yersinia发包速度很快，电脑受不了没做太多测试。</p><p><img src="/img/network_dhcp/image-8.png" alt="Alt text"></p><h1 id="三-冒充DHCP服务器"><a href="#三-冒充DHCP服务器" class="headerlink" title="三. 冒充DHCP服务器"></a>三. 冒充DHCP服务器</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>当你向你的主机安装一个DHCP Server程序后，你的计算机也成为了一台DHCP服务器，但是你可以配置错误的网络配置信息，这可以使得接入网络的计算机无法获取正确的网络配置从而无法上网。</p><h2 id="2-试试？-1"><a href="#2-试试？-1" class="headerlink" title="2. 试试？"></a>2. 试试？</h2><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p><em><strong>Ubuntu20.04（虚拟机）：</strong></em></p><p><img src="/img/network_dhcp/image.png" alt="Alt text"></p><p><em><strong>Windows7（虚拟机）：</strong></em></p><p><img src="/img/network_dhcp/image-2.png" alt="Alt text"></p><h3 id="在Ubuntu中安装dhcp服务器："><a href="#在Ubuntu中安装dhcp服务器：" class="headerlink" title="在Ubuntu中安装dhcp服务器："></a>在Ubuntu中安装dhcp服务器：</h3><pre><code>sudo apt-get install isc-dhcp-server</code></pre><h3 id="配置dhcp服务器相关信息："><a href="#配置dhcp服务器相关信息：" class="headerlink" title="配置dhcp服务器相关信息："></a>配置dhcp服务器相关信息：</h3><p><em><strong>vim &#x2F;etc&#x2F;default&#x2F;isc-dhcp-server</strong></em></p><pre><code># Defaults for isc-dhcp-server (sourced by /etc/init.d/isc-dhcp-server)# Path to dhcpd&#39;s config file (default: /etc/dhcp/dhcpd.conf).#DHCPDv4_CONF=/etc/dhcp/dhcpd.conf#DHCPDv6_CONF=/etc/dhcp/dhcpd6.conf# Path to dhcpd&#39;s PID file (default: /var/run/dhcpd.pid).#DHCPDv4_PID=/var/run/dhcpd.pid#DHCPDv6_PID=/var/run/dhcpd6.pid# Additional options to start dhcpd with.#Don&#39;t use options -cf or -pf here; use DHCPD_CONF/ DHCPD_PID instead#OPTIONS=&quot;&quot;# On what interfaces should the DHCP server (dhcpd) serve DHCP requests?#Separate multiple interfaces with spaces, e.g. &quot;eth0 eth1&quot;.INTERFACESv4=&quot;ens33&quot;INTERFACESv6=&quot;&quot;</code></pre><p><em><strong>vim &#x2F;etc&#x2F;dhcp&#x2F;dhcpd.conf</strong></em></p><pre><code># dhcpd.conf## Sample configuration file for ISC dhcpd## Attention: If /etc/ltsp/dhcpd.conf exists, that will be used as# configuration file instead of this file.## option definitions common to all supported networks...option domain-name &quot;example.org&quot;;option domain-name-servers 8.8.8.8;# option domain-name-servers ns1.example.org, ns2.example.org;default-lease-time 600;max-lease-time 7200;# The ddns-updates-style parameter controls whether or not the server will# attempt to do a DNS update when a lease is confirmed. We default to the# behavior of the version 2 packages (&#39;none&#39;, since DHCP v2 didn&#39;t# have support for DDNS.)ddns-update-style none;# If this DHCP server is the official DHCP server for the local# network, the authoritative directive should be uncommented.authoritative;# Use this to send dhcp log messages to a different log file (you also# have to hack syslog.conf to complete the redirection).# log-facility local7;# No service will be given on this subnet, but declaring it helps the # DHCP server to understand the network topology.#subnet 10.152.187.0 netmask 255.255.255.0 &#123;#&#125;# This is a very basic subnet declaration.subnet 192.168.59.0 netmask 255.255.255.0 &#123;   range 192.168.59.50 192.168.59.200;   option routers 192.168.59.2;   option subnet-mask 255.255.255.0;   option broadcast-address 192.168.59.255;&#125;# This declaration allows BOOTP clients to get dynamic addresses,# which we don&#39;t really recommend.#subnet 10.254.239.32 netmask 255.255.255.224 &#123;#  range dynamic-bootp 10.254.239.40 10.254.239.60;#  option broadcast-address 10.254.239.31;#  option routers rtr-239-32-1.example.org;#&#125;# A slightly different configuration for an internal subnet.#subnet 10.5.5.0 netmask 255.255.255.224 &#123;#  range 10.5.5.26 10.5.5.30;#  option domain-name-servers ns1.internal.example.org;#  option domain-name &quot;internal.example.org&quot;;#  option subnet-mask 255.255.255.224;#  option routers 10.5.5.1;#  option broadcast-address 10.5.5.31;#  default-lease-time 600;#  max-lease-time 7200;#&#125;# Hosts which require special configuration options can be listed in# host statements.   If no address is specified, the address will be# allocated dynamically (if possible), but the host-specific information# will still come from the host declaration.#host passacaglia &#123;#  hardware ethernet 0:0:c0:5d:bd:95;#  filename &quot;vmunix.passacaglia&quot;;#  server-name &quot;toccata.example.com&quot;;#&#125;# Fixed IP addresses can also be specified for hosts.   These addresses# should not also be listed as being available for dynamic assignment.# Hosts for which fixed IP addresses have been specified can boot using# BOOTP or DHCP.   Hosts for which no fixed address is specified can only# be booted with DHCP, unless there is an address range on the subnet# to which a BOOTP client is connected which has the dynamic-bootp flag# set.#host fantasia &#123;#  hardware ethernet 08:00:07:26:c0:a5;#  fixed-address fantasia.example.com;#&#125;# You can declare a class of clients and then do address allocation# based on that.   The example below shows a case where all clients# in a certain class get addresses on the 10.17.224/24 subnet, and all# other clients get addresses on the 10.0.29/24 subnet.#class &quot;foo&quot; &#123;#  match if substring (option vendor-class-identifier, 0, 4) = &quot;SUNW&quot;;#&#125;#shared-network 224-29 &#123;#  subnet 10.17.224.0 netmask 255.255.255.0 &#123;#    option routers rtr-224.example.org;#  &#125;#  subnet 10.0.29.0 netmask 255.255.255.0 &#123;#    option routers rtr-29.example.org;#  &#125;#  pool &#123;#    allow members of &quot;foo&quot;;#    range 10.17.224.10 10.17.224.250;#  &#125;#  pool &#123;#    deny members of &quot;foo&quot;;#    range 10.0.29.10 10.0.29.230;#  &#125;#&#125;</code></pre><h3 id="启动DHCP服务器"><a href="#启动DHCP服务器" class="headerlink" title="启动DHCP服务器"></a>启动DHCP服务器</h3><p><em><strong>启动DHCP服务器：sudo systemctl start isc-dhcp-server.service</strong></em></p><p><em><strong>查看DHCP服务器运行状态：sudo systemctl status isc-dhcp-server.service</strong></em></p><p><em><strong>关闭DHCP服务器：sudo systemctl stop isc-dhcp-server.service</strong></em></p><p><img src="/img/network_dhcp/image-1.png" alt="Alt text"></p><h3 id="Windows7获取Ubuntu20-04的DHCP服务器网络配置"><a href="#Windows7获取Ubuntu20-04的DHCP服务器网络配置" class="headerlink" title="Windows7获取Ubuntu20.04的DHCP服务器网络配置"></a>Windows7获取Ubuntu20.04的DHCP服务器网络配置</h3><p>如果你已经连接网络，使用 <em><strong>ipconfig &#x2F;release</strong></em> 释放获取的网络配置</p><p>然后，使用 <em><strong>ipconfig &#x2F;renew</strong></em> 重新连接DHCP服务器获取网络配置</p><p><img src="/img/network_dhcp/image-3.png" alt="Alt text"></p><p>可以看见Windows7网络配置发生了改变</p><p><img src="/img/network_dhcp/image-4.png" alt="Alt text"></p><h1 id="四-DHCP中间人攻击"><a href="#四-DHCP中间人攻击" class="headerlink" title="四. DHCP中间人攻击"></a>四. DHCP中间人攻击</h1><p>这部分原理与ARP中间人攻击一致…</p><p>中间人攻击基本都是用ARP实现吗？…</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> internet </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> Protocol </tag>
            
            <tag> DHCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络：协议</title>
      <link href="/2023/09/25/network_protocol/"/>
      <url>/2023/09/25/network_protocol/</url>
      
        <content type="html"><![CDATA[<p>基础部分实在懒得写，如果你想学习，这只是一个目录。</p><p>以后的文章应该都是面向实际问题和操作。</p><h1 id="一-协议"><a href="#一-协议" class="headerlink" title="一. 协议"></a>一. 协议</h1><h2 id="1-IP协议"><a href="#1-IP协议" class="headerlink" title="1. IP协议"></a>1. IP协议</h2><h2 id="2-ARP协议"><a href="#2-ARP协议" class="headerlink" title="2. ARP协议"></a>2. ARP协议</h2><h2 id="3-TCP-UDP协议"><a href="#3-TCP-UDP协议" class="headerlink" title="3. TCP&#x2F;UDP协议"></a>3. TCP&#x2F;UDP协议</h2><h2 id="4-ICMP协议"><a href="#4-ICMP协议" class="headerlink" title="4. ICMP协议"></a>4. ICMP协议</h2><h2 id="6-DHCP协议"><a href="#6-DHCP协议" class="headerlink" title="6. DHCP协议"></a>6. DHCP协议</h2><h2 id="7-DNS协议"><a href="#7-DNS协议" class="headerlink" title="7. DNS协议"></a>7. DNS协议</h2><h2 id="7-其他各种应用层协议"><a href="#7-其他各种应用层协议" class="headerlink" title="7. 其他各种应用层协议"></a>7. 其他各种应用层协议</h2>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> network </tag>
            
            <tag> internet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络：扫描工具</title>
      <link href="/2023/09/24/network_scanner/"/>
      <url>/2023/09/24/network_scanner/</url>
      
        <content type="html"><![CDATA[<h1 id="一-扫描工具"><a href="#一-扫描工具" class="headerlink" title="一. 扫描工具"></a>一. 扫描工具</h1><p>下面是代码</p><p>文档等有空上传</p><pre><code class="python">from scapy.all import *from IPy import IP as IPYfrom scapy.layers.inet import ICMP, IP, TCPfrom scapy.layers.l2 import ARPdef preview(list):    preview = input(&quot;预览（y/n）:&quot;)    if preview == &#39;y&#39; or &#39;Y&#39;:        for li in list:            print(li)def arp(ipy):    dst_ip_list = IPY(ipy)    alive_ip_list = []    for dst_ip in dst_ip_list:        pkt = ARP(pdst=str(dst_ip))        ans = sr1(pkt, timeout=1, verbose=False)        if ans is not None:            # ans.summary()            # ans.show()            alive_ip_list.append(dst_ip)            print(dst_ip, &#39;is up&#39;)        else:            print(dst_ip, &#39;is closed&#39;)    return alive_ip_listdef ping(ipy):    dst_ip_list = IPY(ipy)    alive_ip_list = []    for dst_ip in dst_ip_list:        pkt = IP(dst=str(dst_ip)) / ICMP() / b&#39;hello&#39;        ans = sr1(pkt, timeout=1, verbose=False)        if ans is not None:            if ans[ICMP].type == 0:                if ans[IP].ttl &lt;= 64:                    print(dst_ip, &#39;(Linux)&#39;, &#39;is up&#39;)                elif ans[IP].ttl &lt;= 128:                    print(dst_ip, &#39;(Windows)&#39;, &#39;is up&#39;)                else:                    print(dst_ip, &#39;(Mac/Unix)&#39;, &#39;is up&#39;)                alive_ip_list.append(dst_ip)            elif ans[ICMP].type == 11:                print(dst_ip, &#39;is timeout&#39;)            elif ans[ICMP].type == 3:                print(dst_ip, &#39;is unreachable&#39;)            elif ans[ICMP].type == 4:                print(dst_ip, &#39;source quench&#39;)            elif ans[ICMP].type == 5:                print(dst_ip, &#39;redirect&#39;)            elif ans[ICMP].type == 12:                print(dst_ip, &#39;参数问题&#39;)            else:                print(dst_ip, &#39;其他问题：[ICMP].type&#39;, ans[ICMP].type)        else:            print(dst_ip, &#39;is probably filtered(no response)&#39;)    return alive_ip_listdef syn_scan(dst_ip, n, m):    alive_port_list = []    for i in range(n, m):        pkt = IP(dst=str(dst_ip)) / TCP(dport=int(i))        # pkt = IP(dst=str(dst_ip)) / TCP(sport=random.randint(1,65536),dport=int(i))        # pkt.show()        ans = sr1(pkt, timeout=1, verbose=False)        if ans is not None:            # ans.summary()            # ans.show()            if ans[TCP].flags == &#39;SA&#39;:                print(i, &#39;port is open&#39;)                alive_port_list.append(i)                rst = IP(dst=str(dst_ip)) / TCP(dport=int(i), flags=&#39;R&#39;)                sr1(rst, timeout=1, verbose=False)            else:                print(i, &#39;port is closed&#39;)        else:            print(i, &#39;port is filtered&#39;)    return alive_port_listdef ack_scan(dst_ip, n, m):    alive_port_list = []    for i in range(n, m):        pkt = IP(dst=str(dst_ip)) / TCP(dport=int(i), flags=&#39;A&#39;)        # pkt.show()        ans = sr1(pkt, timeout=0.2, verbose=False)        if ans is None:            print(i, &#39;port is filtered&#39;)        else:            # ans.summary()            # ans.show()            print(i, &#39;port is closed&#39;)    return alive_port_listdef fin_scan(dst_ip, n, m):    alive_port_list = []    for i in range(n, m):        pkt = IP(dst=str(dst_ip)) / TCP(dport=int(i), flags=&#39;F&#39;)        # pkt.show()        ans = sr1(pkt, timeout=1, verbose=False)        if ans is None:            print(i, &#39;port is open or filtered&#39;)            alive_port_list.append(i)        else:            # ans.summary()            # ans.show()            print(i, &#39;port is closed&#39;)    return alive_port_listdef null_scan(dst_ip, n, m):    alive_port_list = []    for i in range(n, m):        pkt = IP(dst=str(dst_ip)) / TCP(dport=int(i), flags=0)        # pkt.show()        ans = sr1(pkt, timeout=1, verbose=False)        if ans is None:            print(i, &#39;port is open or filtered&#39;)            alive_port_list.append(i)        else:            # ans.summary()            # ans.show()            print(i, &#39;port is closed&#39;)    return alive_port_listdef xmas_scan(dst_ip, n, m):    alive_port_list = []    for i in range(n, m):        pkt = IP(dst=str(dst_ip)) / TCP(dport=int(i), flags=1)        # pkt.show()        ans = sr1(pkt, timeout=1, verbose=False)        if ans is None:            print(i, &#39;port is open or filtered&#39;)            alive_port_list.append(i)        else:            # ans.summary()            # ans.show()            print(i, &#39;port is closed&#39;)    return alive_port_listdef windows_scan(dst_ip, n, m):    alive_port_list = []    for i in range(n, m):        pkt = IP(dst=str(dst_ip)) / TCP(dport=int(i), flags=&#39;S&#39;)        # pkt.show()        ans = sr1(pkt, timeout=1, verbose=False)        if ans is not None:            # ans.summary()            # ans.show()            if ans[TCP].window != 0:                print(i, &#39;port is open&#39;)                alive_port_list.append(i)                rst = IP(dst=str(dst_ip)) / TCP(dport=int(i), flags=&#39;R&#39;)                sr1(rst, timeout=1, verbose=False)            else:                print(i, &#39;port is closed&#39;)        else:            print(i, &#39;port is filtered&#39;)    return alive_port_listif __name__ == &#39;__main__&#39;:    # 主机ip（移动）    # dst_ip = &#39;10.132.68.173&#39;    # 网关ip    # dst_ip = &#39;10.132.168.1&#39;    # 子网    # dst_ip = &#39;10.132.168.0/21&#39;    # Windows虚拟机ip    # dst_ip = &#39;192.168.59.132&#39;    # Linux虚拟机ip    # dst_ip = &#39;192.168.59.131&#39;    while True:        print(&#39;-------net scanner-------&#39;)        service = input(&#39;你选择主机扫描或是端口扫描?（host/port）：&#39;)        if service == &#39;host&#39;:            way = input(&#39;请输入扫描方式（arp/ping）：&#39;)            if way == &#39;ping&#39;:                dst_ip = input(&#39;请输入你要查询的主机或者范围：&#39;)                alive_ip_list = ping(dst_ip)                preview(alive_ip_list)            elif way == &#39;arp&#39;:                dst_ip = input(&#39;请输入你要查询的主机或者范围：&#39;)                alive_ip_list = arp(dst_ip)                preview(alive_ip_list)        elif service == &#39;port&#39;:            way = input(&#39;请输入扫描方式（syn/windows/ack/fin/null/xmas）：&#39;)            if way == &#39;syn&#39;:                dst_ip = input(&#39;请输入你要查询的主机：&#39;)                alive_port_list = syn_scan(dst_ip, 1, 1024)                preview(alive_port_list)            elif way == &#39;windows&#39;:                dst_ip = input(&#39;请输入你要查询的主机：&#39;)                alive_port_list = windows_scan(dst_ip, 1, 1024)                preview(alive_port_list)            elif way == &#39;ack&#39;:                dst_ip = input(&#39;请输入你要查询的主机：&#39;)                alive_port_list = ack_scan(dst_ip, 1, 1024)                preview(alive_port_list)            elif way == &#39;fin&#39;:                dst_ip = input(&#39;请输入你要查询的主机：&#39;)                alive_port_list = fin_scan(dst_ip, 1, 1024)                preview(alive_port_list)            elif way == &#39;null&#39;:                dst_ip = input(&#39;请输入你要查询的主机：&#39;)                alive_port_list = null_scan(dst_ip, 1, 1024)                preview(alive_port_list)            elif way == &#39;xmas&#39;:                dst_ip = input(&#39;请输入你要查询的主机：&#39;)                alive_port_list = xmas_scan(dst_ip, 1, 1024)                preview(alive_port_list)        else:            print(&#39;i am a teapot&#39;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Scapy </tag>
            
            <tag> TCP </tag>
            
            <tag> ICMP </tag>
            
            <tag> ARP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微博爬虫实例</title>
      <link href="/2023/09/16/spider_weibo/"/>
      <url>/2023/09/16/spider_weibo/</url>
      
        <content type="html"><![CDATA[<p><em>你需要先了解…</em></p><p><em>关于此文章…</em></p><h1 id="一-帖子"><a href="#一-帖子" class="headerlink" title="一. 帖子"></a>一. 帖子</h1><p>懒得写，贴个源码。<br>爬不了的话，传入你的cookie</p><pre><code class="python">import requests  # 网络请求import random  # 与time控制网络请求频率import time  # 与random控制网络请求频率import json  # 响应的json数据分析from tqdm import tqdm  # 进度条# 由此函数完成 请求-响应解析 的过程# 接收评论json文件的url，解析json文件并返回评论信息字典（max，total_number,max_id，max_id_type，commentlist[]）def getCommentTnfo(commenturl):    # 请求评论json文件    # print(commenturl)    headers = &#123;        &quot;cookie&quot;: &quot;&quot;,        &#39;user-agent&#39;: &#39;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Mobile Safari/537.36 Edg/116.0.1938.76&#39;    &#125;    response = requests.get(commenturl, headers=headers)    # 解析json文件内容：max_id，max_id_type，commentlist[]    # max,total_number是第一次请求要获取的信息    dic = &#123;        &#39;max&#39;: 0,        &#39;total_number&#39;: 0,        &#39;max_id&#39;: 0,        &#39;max_id_type&#39;: 0,        &#39;comment_list&#39;: []    &#125;    comment_json = json.loads(response.text)    if (comment_json[&quot;ok&quot;] == 1):        data = comment_json[&quot;data&quot;]        dic[&quot;max&quot;] = data[&quot;max&quot;]        dic[&quot;total_number&quot;] = data[&quot;total_number&quot;]        dic[&quot;max_id&quot;] = data[&quot;max_id&quot;]        dic[&quot;max_id_type&quot;] = data[&quot;max_id_type&quot;]        list = data[&quot;data&quot;]        for li in list:            user = li[&quot;user&quot;]            name = user[&quot;screen_name&quot;]            gender = user[&quot;gender&quot;]            source = li[&quot;source&quot;]            text = li[&quot;text&quot;]            # print(name + &quot;(&quot; + gender + &quot;|&quot; + source + &quot;)&quot; + &quot;:&quot; + text)            dic[&quot;comment_list&quot;].append(name + &quot;(&quot; + gender + &quot;|&quot; + source + &quot;)&quot; + &quot;:&quot; + text)        return dic    # 如果不写else，那么python默认函数返回None    else:        return dic# 此函数调用getCommentList函数,输入不同的max_id# 输入文章url，返回评论信息def getcomments():    blog = input(&quot;请输入帖子的url:&quot;)    id = blog.split(&#39;/&#39;)[-1]    mid = blog.split(&#39;/&#39;)[-1]    max_id_type = 0    comment_list = []    print(&quot;正在分析中...&quot;)    comment_url = &quot;https://m.weibo.cn/comments/hotflow?id=&quot; + id + &quot;&amp;mid=&quot; + mid + &quot;&amp;max_id_type=&quot; + str(max_id_type)    dic = getCommentTnfo(comment_url)    # max，total_number第一次请求时赋值，分析有多少页和多少评论    max = dic[&quot;max&quot;]    total_number = dic[&quot;total_number&quot;]    max_id = dic[&quot;max_id&quot;]    max_id_type = dic[&quot;max_id_type&quot;]    comment_list = comment_list + dic[&quot;comment_list&quot;]    print(&quot;查询到&quot; + str(max) + &quot;页内容，共计&quot; + str(total_number) + &quot;条评论&quot;)    print(&quot;正在爬取中...&quot;)    for i in tqdm(range(max-1)):    # for i in range(max - 1):        time.sleep(random.uniform(1.0, 3.0))        comment_url = &quot;https://m.weibo.cn/comments/hotflow?id=&quot; + id + &quot;&amp;mid=&quot; + mid + &quot;&amp;max_id=&quot; + str(max_id) + &quot;&amp;max_id_type=&quot; + str(max_id_type)        if(dic[&quot;max_id&quot;]!=0):            dic = getCommentTnfo(comment_url)            max_id = dic[&quot;max_id&quot;]            max_id_type = dic[&quot;max_id_type&quot;]            comment_list = comment_list + dic[&quot;comment_list&quot;]    # 是否预览    preview = input(&quot;共&quot; + str(len(comment_list)) + &quot;条记录，预览（y/n）：&quot;)    if (preview == &quot;y&quot; or preview == &quot;Y&quot;):        for comment in comment_list:            print(comment)    # 是否保存    save = input(&quot;共&quot; + str(len(comment_list)) + &quot;条记录，保存（y/n）：&quot;)    if (save == &quot;y&quot; or save == &quot;Y&quot;):        print(&quot;正在写入中...&quot;)        with open(&quot;comment.txt&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:            for comment in tqdm(comment_list):                f.writelines(comment + &quot;\n&quot;)if __name__ == &#39;__main__&#39;:    while (True):        print(&quot;-------微博评论爬虫-------&quot;)        print(&quot;             by liangyue&quot;)        getcomments()</code></pre><h1 id="二-评论"><a href="#二-评论" class="headerlink" title="二. 评论"></a>二. 评论</h1><pre><code class="python">import requests  # 网络请求import random  # 与time控制网络请求频率import time  # 与random控制网络请求频率import json  # 响应的json数据分析from tqdm import tqdm  # 进度条def analyse(blogurl):    # 请求&amp;响应    headers = &#123;        &#39;user-agent&#39;: &#39;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Mobile Safari/537.36 Edg/116.0.1938.76&#39;    &#125;    response = requests.get(blogurl, headers=headers)    # 响应解析    list_dic_blog = []    response_json = json.loads(response.text)    if (response_json[&quot;ok&quot;] == 1):        data = response_json[&quot;data&quot;]        cards = data[&quot;cards&quot;]        for card in cards:            dic_blog = &#123;                &quot;user_name&quot;: &quot;&quot;,                &quot;user_gender&quot;: &quot;&quot;,                &quot;user_region&quot;: &quot;&quot;,                &quot;blog_text&quot;: &quot;&quot;,                &quot;blog_url&quot;: &quot;&quot;            &#125;            if &quot;mblog&quot; in card:                myblog = card[&quot;mblog&quot;]                user = myblog[&quot;user&quot;]                dic_blog[&quot;user_name&quot;] = user[&quot;screen_name&quot;]                dic_blog[&quot;user_gender&quot;] = user[&quot;gender&quot;]                if (&quot;status_province&quot; in myblog):                    dic_blog[&quot;user_region&quot;] = myblog[&quot;status_province&quot;]                mid = myblog[&quot;mid&quot;]                dic_blog[&quot;blog_text&quot;] = myblog[&quot;text&quot;]                dic_blog[&quot;blog_url&quot;] = &quot;https://m.weibo.cn/detail/&quot; + mid                list_dic_blog.append(dic_blog)            if &quot;card_group&quot; in card:                card_grop = card[&quot;card_group&quot;]                if &quot;mblog&quot; in card_grop[0]:                    myblog = (card_grop[0])[&quot;mblog&quot;]                    user = myblog[&quot;user&quot;]                    dic_blog[&quot;user_name&quot;] = user[&quot;screen_name&quot;]                    dic_blog[&quot;user_gender&quot;] = user[&quot;gender&quot;]                    if (&quot;status_province&quot; in myblog):                        dic_blog[&quot;user_region&quot;] = myblog[&quot;status_province&quot;]                    mid = myblog[&quot;mid&quot;]                    dic_blog[&quot;blog_text&quot;] = myblog[&quot;text&quot;]                    dic_blog[&quot;blog_url&quot;] = &quot;https://m.weibo.cn/detail/&quot; + mid                list_dic_blog.append(dic_blog)        return list_dic_blog    else:        return list_dic_blogdef getblog():    keyword = input(&quot;请输入关键字：&quot;)    page = input(&quot;请输入爬取页码（1-100）：&quot;)    page = int(page)    if (page &lt; 1 or page &gt; 100):        exit(418)    print(&quot;正在爬取中...&quot;)    list_dic_blog = []    for i in tqdm(range(page)):        if (page == 0):            blogurl = &quot;https://m.weibo.cn/api/container/getIndex?containerid=100103type%3D1%26q%3D&quot; + keyword + &quot;&amp;page_type=searchall&quot;            list_dic_blog = list_dic_blog + analyse(blogurl)        else:            time.sleep(random.uniform(1, 2))            blogurl = &quot;https://m.weibo.cn/api/container/getIndex?containerid=100103type%3D1%26q%3D&quot; + keyword + &quot;&amp;page_type=searchall&quot; + &quot;&amp;page=&quot; + str(                i)            list_dic_blog = list_dic_blog + analyse(blogurl)    # 是否预览？    preview = input(&quot;共&quot; + str(len(list_dic_blog)) + &quot;条记录，你是否希望预览（y/n）：&quot;)    if (preview == &quot;y&quot; or preview == &quot;Y&quot;):        for dic_blog in list_dic_blog:            print(dic_blog)    # 是否保存？    save = input(&quot;共&quot; + str(len(list_dic_blog)) + &quot;条记录，保存到blog.txt（y/n）：&quot;)    if (save == &quot;y&quot; or save == &quot;Y&quot;):        with open(&quot;blog.txt&quot;, &quot;w&quot;, encoding=&#39;Utf-8&#39;) as f:            for dic_blog in tqdm(list_dic_blog):                f.writelines(str(dic_blog) + &quot;\n&quot;)if __name__ == &#39;__main__&#39;:    print(&quot;-------微博帖子-------&quot;)    print(&quot;           By liangyue&quot;)    while(True):        getblog()</code></pre>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
            <tag> Requests </tag>
            
            <tag> 微博 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>子域名查询</title>
      <link href="/2023/09/15/spider_subdomain/"/>
      <url>/2023/09/15/spider_subdomain/</url>
      
        <content type="html"><![CDATA[<p><em>如果你有任何问题，在评论提出</em></p><p>网络空间攻防技术的第一个作业，简单记录一下。</p><h2 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h2><p>百度将子域名存在 <em><strong>div</strong></em> 标签的 <em><strong>mu</strong></em> 属性中，你可以通过 <em><strong>class_&#x3D;’result c-container xpath-log new-pmd’</strong></em> 找到这个 <em><strong>div</strong></em> 标签。</p><pre><code class="python"># 定义一个采用baidu搜索的方法def baidu_search():    ### html request construct    print(&quot;-------Powered by baidu-------&quot;)    # 输入域名和查询页数    domain = input(&quot;input the domain you want to query:&quot;)    page = input(&quot;The more page,the more subdomain(not sure):&quot;)    page = int(page)    if(page&lt;1 or page&gt;100):        exit(418)    # 定义请求头，绕过反爬机制    hearders = &#123;        # 填入你的cookie        &#39;cookie&#39;: &#39;&#39;,        &#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36 Edg/90.0.818.56&#39;,    &#125;    ### html request    print(&quot;url requesting...&quot;)    resp_list = []    # for i in range(0,page):    for i in tqdm(range(page)):        time.sleep(random.uniform(0.3, 2.0))        if(i==0):            url = &quot;https://www.baidu.com/s?wd=domain%3A&quot;+ domain            resp = requests.get(url, headers=hearders)  # 访问url，获取网页源码            resp_list.append(resp)        else:            url = &quot;https://www.baidu.com/s?wd=domain%3A&quot;+ domain +&quot;&amp;pn=&quot;+ str(i*10)            resp = requests.get(url, headers=hearders)  # 访问url，获取网页源码            resp_list.append(resp)    ### html response analysis    print(&quot;response analying...&quot;)    subdomain_list = []  # 定义一个空列表用于存储收集到的子域名    # for resp in resp_list:    for resp in tqdm(resp_list):        soup = BeautifulSoup(resp.content, &#39;html.parser&#39;)  # 创建一个BeautifulSoup对象，第一个参数是网页源码，第二个参数是Beautiful Soup 使用的 HTML 解析器，        # 锁定含有子域名的标签        tag_div = soup.find_all(&quot;div&quot;,class_=&#39;result c-container xpath-log new-pmd&#39;)        for i in tag_div:            link = i.get(&#39;mu&#39;)  # 获取标签内mu属性值，即子域名            # urlparse是一个解析url的工具，scheme获取url的协议名，netloc获取url的网络位置            subdomain = str(urlparse(link).scheme + &quot;://&quot; + urlparse(link).netloc)            if (subdomain in subdomain_list) | (domain not in subdomain):  # 如果解析后的domain存在于Subdomain中则跳过，否则将domain存入子域名表中                pass            else:                subdomain_list.append(subdomain)    ### item pipline    # preview？    print(str(len(subdomain_list))+&quot; records total&quot;)    preview = input(&quot;preview or not(y/n):&quot;)    if(preview==&quot;y&quot; or preview==&quot;Y&quot;):        for subdomain in subdomain_list:            print(subdomain)    # isSave?    save = input(&quot;save or not(y/n):&quot;)    if(save==&quot;y&quot; or save==&quot;Y&quot;):        print(&quot;file writing...&quot;)        with open(&#39;subdomain.txt&#39;, &#39;w&#39;) as f:            # for subdomain in subdomain_list:            for subdomain in tqdm(subdomain_list):                f.writelines(subdomain + &quot;\n&quot;)</code></pre><h2 id="必应"><a href="#必应" class="headerlink" title="必应"></a>必应</h2><p>必应的子域名位于 <strong>h2</strong> 标签下的 <strong>a</strong> 标签的 <strong>href</strong> 属性，这是很常见的，很多链接都会放在a标签的href属性中。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><ul><li>如果你安装了python，你可以将源码复制然后安装相应的包以使用</li><li>当然我也将这个程序打包为可执行文件</li></ul><pre><code class="python">import randomimport requests  # 用于请求网页from bs4 import BeautifulSoup  # 用于处理获取的到的网页源码数据from urllib.parse import urlparse  # 用于处理urlfrom tqdm import tqdm   # 进度条import time     # 爬虫请求时停# 定义一个采用baidu搜索的方法def baidu_search():    ### html request construct    print(&quot;-------Powered by baidu-------&quot;)    # 输入域名和查询页数    domain = input(&quot;input the domain you want to query:&quot;)    page = input(&quot;The more page,the more subdomain(not sure):&quot;)    page = int(page)    if(page&lt;1 or page&gt;100):        exit(418)    # 定义请求头，绕过反爬机制    hearders = &#123;        # 别用我的cookie        &#39;cookie&#39;: &#39;&#39;,        &#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36 Edg/90.0.818.56&#39;,    &#125;    ### html request    print(&quot;url requesting...&quot;)    resp_list = []    # for i in range(0,page):    for i in tqdm(range(page)):        time.sleep(random.uniform(0.3, 2.0))        if(i==0):            url = &quot;https://www.baidu.com/s?wd=domain%3A&quot;+ domain            resp = requests.get(url, headers=hearders)  # 访问url，获取网页源码            resp_list.append(resp)        else:            url = &quot;https://www.baidu.com/s?wd=domain%3A&quot;+ domain +&quot;&amp;pn=&quot;+ str(i*10)            resp = requests.get(url, headers=hearders)  # 访问url，获取网页源码            resp_list.append(resp)    ### html response analysis    print(&quot;response analying...&quot;)    subdomain_list = []  # 定义一个空列表用于存储收集到的子域名    # for resp in resp_list:    for resp in tqdm(resp_list):        soup = BeautifulSoup(resp.content, &#39;html.parser&#39;)  # 创建一个BeautifulSoup对象，第一个参数是网页源码，第二个参数是Beautiful Soup 使用的 HTML 解析器，        # 锁定含有子域名的标签        tag_div = soup.find_all(&quot;div&quot;,class_=&#39;result c-container xpath-log new-pmd&#39;)        for i in tag_div:            link = i.get(&#39;mu&#39;)  # 获取标签内mu属性值，即子域名            # urlparse是一个解析url的工具，scheme获取url的协议名，netloc获取url的网络位置            subdomain = str(urlparse(link).scheme + &quot;://&quot; + urlparse(link).netloc)            if (subdomain in subdomain_list) | (domain not in subdomain):  # 如果解析后的domain存在于Subdomain中则跳过，否则将domain存入子域名表中                pass            else:                subdomain_list.append(subdomain)    ### item pipline    # preview？    print(str(len(subdomain_list))+&quot; records total&quot;)    preview = input(&quot;preview or not(y/n):&quot;)    if(preview==&quot;y&quot; or preview==&quot;Y&quot;):        for subdomain in subdomain_list:            print(subdomain)    # isSave?    save = input(&quot;save or not(y/n):&quot;)    if(save==&quot;y&quot; or save==&quot;Y&quot;):        print(&quot;file writing...&quot;)        with open(&#39;subdomain.txt&#39;, &#39;w&#39;) as f:            # for subdomain in subdomain_list:            for subdomain in tqdm(subdomain_list):                f.writelines(subdomain + &quot;\n&quot;)# 定义一个采用bing搜索的方法def bing_search():    #定义请求url    url = &quot;https://cn.bing.com/search?q=domain%3aqq.com&amp;qs=n&amp;sp=-1&amp;pq=domain%3abaidu.com&amp;sc=0-16&amp;sk=&amp;cvid=E6DAE965B2BD4FDC8DF857015E0499C1&amp;first=9&amp;FORM=PQRE1&quot;    #定义请求头，绕过反爬机制    hearders = &#123;        &#39;user-agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36 Edg/90.0.818.56&#39;,        # &#39;accept&#39;:&#39;*/*&#39;,        # &#39;referer&#39;:&#39;https://cn.bing.com/search?q=domain%3abaidu.com&amp;qs=HS&amp;pq=domain%3a&amp;sc=10-7&amp;cvid=B99CC286861647E79EF504A4D5B819F1&amp;FORM=QBLH&amp;sp=1&#39;,        # &#39;cookie&#39;:&#39;MUID=15F7A3347F9B66091BBBAC017EB56733&#39;    &#125;    # 访问url，获取网页源码    resp = requests.get(url,headers=hearders)    # 创建一个BeautifulSoup对象，第一个参数是网页源码，第二个参数是Beautiful Soup 使用的 HTML 解析器，    soup = BeautifulSoup(resp.content,&#39;html.parser&#39;)    # find_all()查找源码中所有&lt;h2&gt;标签的内容    job_bt = soup.find_all(&#39;h2&#39;)    # 定义一个空列表用于存储收集到的子域名    Subdomain = []    for i in job_bt:        link = i.a.get(&#39;href&#39;)                          #循环获取‘href’的内容        #urlparse是一个解析url的工具，scheme获取url的协议名，netloc获取url的网络位置        domain = str(urlparse(link).scheme + &quot;://&quot; + urlparse(link).netloc)        if domain in Subdomain:              #如果解析后的domain存在于Subdomain中则跳过，否则将domain存入子域名表中            pass        else:            Subdomain.append(domain)            print(domain)if __name__ == &#39;__main__&#39;:    print(&quot;-------Subdomain Getter-------&quot;)    print(&quot;                   by liangyue&quot;)    while (True):        engine = input(&quot;select a engine(baidu/bing):&quot;)        if (engine == &quot;baidu&quot;):            baidu_search()        elif (engine == &quot;bing&quot;):            bing_search()        else:            exit(418)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发（五）-JWT</title>
      <link href="/2023/09/11/web_jwt/"/>
      <url>/2023/09/11/web_jwt/</url>
      
        <content type="html"><![CDATA[<p><em>这篇文章将会向你介绍JWT的理论基础和程序实现</em></p><h1 id="一-JWT-理论"><a href="#一-JWT-理论" class="headerlink" title="一. JWT-理论"></a>一. JWT-理论</h1><h2 id="JWT基础"><a href="#JWT基础" class="headerlink" title="JWT基础"></a>JWT基础</h2><p><em>如果你没有任何基础，请耐心看完这一部分</em></p><p>想象一下你登录某个网站的场景。你从登录页面输入账号密码进入到该网站，同时该网站返回你的个人信息，包括你的昵称，头像，个性签名，显示到网页上。更重要的是，登录网站意味着你的身份得到服务器的验证，你获得了访问你的个人信息的权限。</p><p>服务器通过账号密码识别我们的身份吗？是，但不完全是。首先，你需要明白我们浏览器所依靠的http协议是无状态的。这就好像你和一个记忆力差劲的人交流，每一轮对话之后，他都会忘记你的名字。所以，你在每次和他说话之前，都需要重申你的身份。服务器就像这么一个人，尽管你对它说尽千言万语，而服务器只会在众多用户中迷失你的名字。</p><p>那么，这是否意味着我们必须在每一个请求之前都输入我们的账号密码来告知服务器我们的合法身份呢？答案是否定的，有更简单的解决方案。JWT（JSON WEB TOKEN）就是一种实现方式。</p><p>在输入账号密码之后，服务器会返回一个token给我们。以后在每次请求，我们带上token，服务器便会在用户中认出你。但是，如果你企图修改token，服务器能轻易检查出。这一部分是通过签名实现，当服务器用秘钥对token签名后，任何对token的更改都需要这个秘钥。</p><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JWT由三个部分组成：header，payload，signature。header标识类型和签名算法。payload一般会存放标识你的一些信息账号id，用户名等。signnature是服务器的签名，防止你篡改上一部分的信息冒充他人。</p><h3 id="header："><a href="#header：" class="headerlink" title="header："></a>header：</h3><pre><code>&#123;    &#39;typ&#39;: &#39;JWT&#39;,    &#39;alg&#39;: &#39;HS256&#39;&#125;</code></pre><p><em>类型是JWT；签名算法是HS256</em></p><h3 id="一般header会进行base64编码："><a href="#一般header会进行base64编码：" class="headerlink" title="一般header会进行base64编码："></a>一般header会进行base64编码：</h3><pre><code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</code></pre><h3 id="payload："><a href="#payload：" class="headerlink" title="payload："></a>payload：</h3><pre><code>&#123;    &quot;sub&quot;: &quot;1234567890&quot;,    &quot;name&quot;: &quot;John Doe&quot;,    &quot;admin&quot;: true&#125;</code></pre><p><em>iss: jwt签发者；sub: jwt所面向的用户；aud: 接收jwt的一方；exp: jwt的过期时间，这个过期时间必须要大于签发时间；nbf: 定义在什么时间之前，该jwt都是不可用的.；iat: jwt的签发时间；jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</em></p><h3 id="一般会对payload进行base64编码："><a href="#一般会对payload进行base64编码：" class="headerlink" title="一般会对payload进行base64编码："></a>一般会对payload进行base64编码：</h3><pre><code>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</code></pre><h2 id="signature："><a href="#signature：" class="headerlink" title="signature："></a>signature：</h2><p>signature对上面两部分的base64编码使用key进行签名</p><pre><code>HMACSHA256（base64(header) . base64(payload) , key）</code></pre><p>一般像这样：<br>      eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</p><h2 id="JWT-1"><a href="#JWT-1" class="headerlink" title="JWT"></a>JWT</h2><p>将这三部分合并，中间用“.”分隔，得到一个完整的JWT</p><pre><code>  eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</code></pre><h1 id="二-JWT-实现"><a href="#二-JWT-实现" class="headerlink" title="二. JWT-实现"></a>二. JWT-实现</h1><h2 id="0-添加依赖"><a href="#0-添加依赖" class="headerlink" title="0. 添加依赖"></a>0. 添加依赖</h2><pre><code>    &lt;!--JWT--&gt;    &lt;dependency&gt;        &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;        &lt;artifactId&gt;jjwt&lt;/artifactId&gt;        &lt;version&gt;0.9.1&lt;/version&gt;    &lt;/dependency&gt;</code></pre><h2 id="1-生成token"><a href="#1-生成token" class="headerlink" title="1. 生成token"></a>1. 生成token</h2><pre><code>//token有效时间private static long expire = 604800;//校验token有效性秘钥private static String key = &quot;aaaabbbbccccddddaaaabbbbccccdddd&quot;;//token生成public static String generateToken(String username)&#123;Date now = new Date();Date expiration = new Date(now.getTime()+1000*expire);return Jwts.builder()//          .setHeaderParams()            .setSubject(username)            .setIssuedAt(now)            .setExpiration(expiration)            .signWith(SignatureAlgorithm.HS512,key)            .compact();&#125;</code></pre><h2 id="2-token校验"><a href="#2-token校验" class="headerlink" title="2. token校验"></a>2. token校验</h2><pre><code>//token校验public static Claims getClaimsByToken(String token)&#123;    return Jwts.parser()            .setSigningKey(key)            .parseClaimsJws(token)            .getBody();&#125;</code></pre><h2 id="3-一个简单的例子"><a href="#3-一个简单的例子" class="headerlink" title="3. 一个简单的例子"></a>3. 一个简单的例子</h2><p>你可以将上面两个函数封装在JwtUtils的类中，在Controller中调用token相关的函数在网络请求中使用token。</p><pre><code>String token = generateToken(name);</code></pre><p>登录之后将token返回到客户端。</p><pre><code>getClaimsByToken(token).getSubject().equals(name)</code></pre><p>校验客户端的token后，允许其访问对应接口。</p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> web开发 </tag>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
            <tag> jwt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发（四）-MyBatis</title>
      <link href="/2023/09/10/web_mybatis/"/>
      <url>/2023/09/10/web_mybatis/</url>
      
        <content type="html"><![CDATA[<h1 id="一-MyBatis-理论"><a href="#一-MyBatis-理论" class="headerlink" title="一. MyBatis-理论"></a>一. MyBatis-理论</h1><p>这一部分我也不是很了解，简单的写点理解。</p><h2 id="1-MyBatis基础"><a href="#1-MyBatis基础" class="headerlink" title="1. MyBatis基础"></a>1. MyBatis基础</h2><p>MyBatis将数据库语句映射到java函数，将一个函数同SQL语句绑定后，当你调用这个函数，对应的SQL语句将会执行，并且返回参数到函数的返回值。</p><p>同时，MyBatis将数据库的表和java的对象做了很好的连接。在MyBatis的作用下，映射SQL查询语句的函数可以返回java对象。</p><h1 id="二-MyBatis实现"><a href="#二-MyBatis实现" class="headerlink" title="二. MyBatis实现"></a>二. MyBatis实现</h1><h2 id="1-依赖和配置"><a href="#1-依赖和配置" class="headerlink" title="1. 依赖和配置"></a>1. 依赖和配置</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>你可以直接使用MyBatis-plus版本，它支持MyBatis</p><pre><code>    &lt;!--mybatis-plus--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.baomidou&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;        &lt;version&gt;3.4.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--Mysql jdbc驱动--&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.47&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--druid 连接池--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid&lt;/artifactId&gt;        &lt;version&gt;1.1.20&lt;/version&gt;    &lt;/dependency&gt;</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><pre><code>spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTCspring.datasource.username=rootspring.datasource.password=root</code></pre><h2 id="2-新建实体类"><a href="#2-新建实体类" class="headerlink" title="2. 新建实体类"></a>2. 新建实体类</h2><p>这是一个简单的User类，定义了id，name，password三个属性，以及set，get，toString三个方法。</p><pre><code>public class User &#123;    private int id;    private String name;    private String password;    public int getId() &#123;        return id;    &#125;    public String getName()&#123;        return name;    &#125;    public String getPassword()&#123;        return password;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, password=&#39;&quot; + password + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><h2 id="新建Mapper接口"><a href="#新建Mapper接口" class="headerlink" title="新建Mapper接口"></a>新建Mapper接口</h2><p>在下面代码中，你可以阅读注释，你很容易明白这些@注解的作用。</p><pre><code>@Mapperpublic interface UserMapper&#123;    //返回查询对象的集合    @Select(&quot;select * from user&quot;)    public List&lt;User&gt; findAll();    //返回查询对象    @Select(&quot;select * from user where id = #&#123;id&#125;&quot;)    public User findById(int id);    //将数据库insert语句映射到java程序的insert方法    //返回值为插入语句影响的记录数目    @Insert(&quot;insert into user values (#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;)    public int insert(int id, String name,String password);    //将数据库delete语句映射到java程序的delete方法    //返回值为删除语句影响的记录数目    @Delete(&quot;delete  from user where id = #&#123;id&#125;&quot;)    public int delete(int id);    //将数据库update语句映射到java程序的update方法    //返回值为更新语句影响的记录数目    @Update(&quot;update user set name = #&#123;newName&#125;,password= #&#123;newPassword&#125; where id = #&#123;id&#125;&quot;)    public int update(int id,String newName,String newPassword);&#125;</code></pre><h2 id="3-编写Controller方法"><a href="#3-编写Controller方法" class="headerlink" title="3. 编写Controller方法"></a>3. 编写Controller方法</h2><p>通过Mapper类你可以将数据库表的数据轻松的赋给java对象或者对数据库进行操作。</p><p>下面是一个用户登录的例子</p><pre><code>@RestControllerpublic class UserController &#123;    @Autowired    private UserMapper userMapper;    //登录    @PostMapping(&quot;/&quot;)    public String login(@RequestParam String name,@RequestParam String password)&#123;        //权限标识        int verify = 0;        //检查账号，密码        List&lt;User&gt; list = userMapper.findAll();        for(int i=0; i&lt;list.size(); i++)&#123;            User useri = list.get(i);            if(useri.getName().equals(name) &amp;&amp; useri.getPassword().equals(password))&#123;                verify = 1;                break;            &#125;        &#125;        //权限判断        if(verify==1)&#123;            return &quot;login&quot;;        &#125;else&#123;            return &quot;error&quot;;        &#125;    &#125;    //返回用户个人信息    @GetMapping(&quot;/user&quot;)    public String info(@RequestParam int id,@RequestParam String name,@RequestParam String token) &#123;        if(getClaimsByToken(token).getSubject().equals(name))&#123;        User user = userMapper.findById(id);        return user.toString();        &#125;else&#123;            return &quot;error&quot;;        &#125;    &#125;    //用户注册    @PostMapping(&quot;/user&quot;)    public String register(@RequestParam String name,@RequestParam String password)&#123;        int id = 0;        userMapper.insert(id,name,password);        return &quot;register&quot;;    &#125;    //用户注销    @DeleteMapping(&quot;/user&quot;)    public String delete(@RequestParam int id)&#123;        userMapper.delete(id);        return &quot;delete&quot;;    &#125;    //修改个人信息    @PutMapping(&quot;/user&quot;)    public String update(@RequestParam int id,@RequestParam String newName,@RequestParam String newPassword) &#123;        userMapper.update(id,newName,newPassword);        return &quot;update&quot;;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> web开发 </tag>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
            <tag> mybatis </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫（三）：结果保存</title>
      <link href="/2023/09/10/spider_save/"/>
      <url>/2023/09/10/spider_save/</url>
      
        <content type="html"><![CDATA[<p><em><strong>一般来说会把爬取的结果存储到列表或者字典中，然后将结果写入文件中</strong></em></p><h1 id="一-TXT"><a href="#一-TXT" class="headerlink" title="一. TXT"></a>一. TXT</h1><p>代码比较简单,看一下应该就懂了…</p><p>对于列表</p><pre><code class="Python">    # 是否保存    save = input(&quot;共&quot; + str(len(comment_list)) + &quot;条记录，保存到commen.txt（y/n）：&quot;)    if (save == &quot;y&quot; or save == &quot;Y&quot;):        print(&quot;正在写入中...&quot;)        with open(&quot;comment.txt&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:            for comment in tqdm(comment_list):                f.writelines(comment + &quot;\n&quot;)</code></pre><p>对于字典</p><pre><code class="Python">    # 是否保存？    save = input(&quot;共&quot; + str(len(list_dic_blog)) + &quot;条记录，保存到blog.txt（y/n）：&quot;)    if (save == &quot;y&quot; or save == &quot;Y&quot;):        with open(&quot;blog.txt&quot;, &quot;w&quot;, encoding=&#39;Utf-8&#39;) as f:            for dic_blog in tqdm(list_dic_blog):                f.writelines(str(dic_blog) + &quot;\n&quot;)</code></pre><h1 id="二-JSON"><a href="#二-JSON" class="headerlink" title="二. JSON"></a>二. JSON</h1><pre><code class="Python">    json_str = json.dumps(the_dict,indent=4,ensure_ascii=False)    with open(file_name, &#39;w&#39;) as json_file:        json_file.write(json_str)</code></pre><h1 id="三-Excel"><a href="#三-Excel" class="headerlink" title="三. Excel"></a>三. Excel</h1><pre><code class="python"># -*- coding: utf-8 -*-import xlsxwriter as xw  def xw_toExcel(data, fileName):  # xlsxwriter库储存数据到excel    workbook = xw.Workbook(fileName)  # 创建工作簿    worksheet1 = workbook.add_worksheet(&quot;sheet1&quot;)  # 创建子表    worksheet1.activate()  # 激活表    title = [&#39;序号&#39;, &#39;酒店&#39;, &#39;价格&#39;]  # 设置表头    worksheet1.write_row(&#39;A1&#39;, title)  # 从A1单元格开始写入表头    i = 2  # 从第二行开始写入数据    for j in range(len(data)):        insertData = [data[j][&quot;id&quot;], data[j][&quot;name&quot;], data[j][&quot;price&quot;]]        row = &#39;A&#39; + str(i)        worksheet1.write_row(row, insertData)        i += 1    workbook.close()  # 关闭表  # &quot;-------------数据用例-------------&quot;testData = [    &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;立智&quot;, &quot;price&quot;: 100&#125;,    &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;维纳&quot;, &quot;price&quot;: 200&#125;,    &#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;如家&quot;, &quot;price&quot;: 300&#125;,]fileName = &#39;测试.xlsx&#39;xw_toExcel(testData, fileName)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
            <tag> txt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>车载U盘</title>
      <link href="/2023/09/09/other_u/"/>
      <url>/2023/09/09/other_u/</url>
      
        <content type="html"><![CDATA[<p>最近发现一个好玩的东西，车载U盘不知道大家有没有用过。</p><p>暑假，有个哥哥叫我帮他U盘下点歌，顺便删掉里面的一些DJ歌曲。</p><p>我想，这不简单吗？我接过U盘，插在电脑上，吓我一跳，提示我无法打开，需要格式化，这点错歌不全没了吗。</p><p>我才发现，事情没有我想象的那么简单。</p><p>于是，我马上搜索 <em><strong>“车载U盘”</strong></em> 相关信息。</p><p>互联网上信息很多，但是我的信息检索能力还算合格吧。不一会就发现了问题所在。</p><p>一般车子系统是Linux，车载U盘使用也是Linux系统的分区，因此我插入Windows系统的电脑并不能识别出U盘的音乐文件，而是直接提示我格式化U盘。</p><hr><p>原来如此，那么解决方案是什么呢？</p><ul><li><p>最简单的方法：买一根连接U盘的转接线，手机是Linux内核的Android操作系统，因此可以解析车载U盘中的音乐文件。</p></li><li><p>如果你的计算机内装有Linux虚拟机，那么你也可以通过虚拟机连接U盘来对其中的文件进行更改。</p></li></ul><hr><p>嗯，然后就熬夜下歌…最后发现搞错了，啊…joker</p><p>额，怎么说呢？</p><p>一个小小的车载U盘，即使学过操作系统，考试也觉得不难，但是倘若缺乏这次经历，可能我仍不知。</p><p>我就像井底之蛙，但还好没事折腾两下自己，能看看更广阔的天地。</p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 音乐 </tag>
            
            <tag> 车载U盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发（三）-TomCat</title>
      <link href="/2023/09/09/web_tomcat/"/>
      <url>/2023/09/09/web_tomcat/</url>
      
        <content type="html"><![CDATA[<h1 id="一-TomCat-理论"><a href="#一-TomCat-理论" class="headerlink" title="一. TomCat-理论"></a>一. TomCat-理论</h1><h2 id="1-Tomcat基础"><a href="#1-Tomcat基础" class="headerlink" title="1. Tomcat基础"></a>1. Tomcat基础</h2><p>TomCat是一个Web服务器，它默认活跃在电脑的8080端口，接收HTTP请求。</p><p>同时，TomCat提供规范的HTTP接口，它接收规范的HTTP请求，对于Response，你也不需要自己编写，因为TomCat帮助你返回标准的Response。</p><p>下面是具体实现：</p><ul><li><p>当你访问此localhost:8080时，浏览器或者其他代理发送的HTTP请求将会被TomCat截获，</p></li><li><p>如果你在SpringBoot框架中使用TomCat，你可以获取HTTP请求，对数据做处理。</p></li><li><p>最后，你希望对这个请求作出响应，TomCat帮助你构建标准的HTTP响应。</p></li></ul><h1 id="二-TomCat-实现"><a href="#二-TomCat-实现" class="headerlink" title="二. TomCat-实现"></a>二. TomCat-实现</h1><h2 id="1-依赖和配置"><a href="#1-依赖和配置" class="headerlink" title="1. 依赖和配置"></a>1. 依赖和配置</h2><p>当你新建一个SpringBoot项目时，该项目集成了TomCat。</p><p>因此，你不必要花时间去配置TomCat。</p><h2 id="2-Controller类"><a href="#2-Controller类" class="headerlink" title="2. Controller类"></a>2. Controller类</h2><p>一般来说，我们把对请求的处理封装在Controller类中。</p><h3 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h3><p>你可以在使用这个注解标注为Controller类，在这个类中你可以定义函数处理HTTP请求。</p><p>@RestController &#x3D; @Controller + @ResponseBody</p><p>@Controller：将当前修饰的类注入SpringBoot IOC容器，使得从该类所在的项目跑起来的过程中，这个类就被实例化。当然也有语义化的作用，即代表该类是充当Controller的作用</p><p>@ResponseBody：它的作用简短截说就是指该类中所有的API接口返回的数据，甭管你对应的方法返回Map或是其他Object，它会以Json字符串的形式返回给客户端，本人尝试了一下，如果返回的是String类型，则仍然是String。</p><h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p>你可以使用这个注解标注函数接收的HTTP请求类型和路径，这样函数对应一个接口。</p><p>@RequestMapping有两个参数，你可以指定HTTp方法，以及接收的参数。</p><p>更简单的方法是使用@GetMapping&#x2F;PostMapping&#x2F;DeleteMapping&#x2F;PutMapping这样你只需要指定接收路径。</p><h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>指定函数必须从HTTP请求中接收的参数，否则报错。</p><h2 id="3-代码实例"><a href="#3-代码实例" class="headerlink" title="3. 代码实例"></a>3. 代码实例</h2><pre><code>@RestControllerpublic class UserController &#123;    @GetMapping(&quot;/index&quot;)    public String getIndex(@RequestParam String name)&#123;        return &quot;Hello &quot;+name;    &#125;&#125;</code></pre><p>当你访问<a href="http://localhost:8080/index?name=tomcat">http://localhost:8080/index?name=tomcat</a>时，你传入name参数值为tomcat。Controller接收后，在响应中返回hello tomcat。</p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> web开发 </tag>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫（二）：响应解析</title>
      <link href="/2023/09/09/spider_analysis/"/>
      <url>/2023/09/09/spider_analysis/</url>
      
        <content type="html"><![CDATA[<p><em><strong>当你获取响应文件后，你需要做的就是收集其中的关键信息。对不同的响应文件格式你需要选择不同方式解析。</strong></em><br><em><strong>下面是一些常见的响应解析方式</strong></em></p><h1 id="一-Xpath"><a href="#一-Xpath" class="headerlink" title="一. Xpath"></a>一. Xpath</h1><h2 id="1-Xpath基础"><a href="#1-Xpath基础" class="headerlink" title="1. Xpath基础"></a>1. Xpath基础</h2><p>Xpath适用于解析HTML格式文件，并且语法及其简介。</p><h2 id="2-对str对象使用Xpath"><a href="#2-对str对象使用Xpath" class="headerlink" title="2. 对str对象使用Xpath"></a>2. 对str对象使用Xpath</h2><p>对于一般的HTML格式响应对象 <em><strong>response.text()</strong></em> 是字符串类型，因此在使用之前： <code>from lxml import etree</code> </p><h2 id="3-Xpath语法"><a href="#3-Xpath语法" class="headerlink" title="3. Xpath语法"></a>3. Xpath语法</h2><p>这里先举个例子（也是我开始学爬虫的测试网站）</p><p><img src="/img/spider_analysis/image.png" alt="Alt text"></p><p>如果你想拿到 <em><strong>a标签</strong></em> 的href属性：&#x2F;&#x2F;div&#x2F;ul&#x2F;li&#x2F;a&#x2F;@href</p><p>如果你想拿到 <em><strong>img标签</strong></em> 的src属性：&#x2F;&#x2F;div&#x2F;ul&#x2F;li&#x2F;a&#x2F;span&#x2F;img&#x2F;@src</p><p>如果你想拿到 <em><strong>b标签</strong></em> 的内容：&#x2F;&#x2F;div&#x2F;ul&#x2F;li&#x2F;a&#x2F;b&#x2F;text()</p><p>&#x2F;&#x2F;div能够锁定所有div标签，这也是经常使用的Xpath开头，当然你也可以明确定位一个标签&#x2F;&#x2F;div[@class&#x3D;’slist’]</p><p>下面是详细语法</p><p>&#x2F;:子标签<br>&#x2F;&#x2F;:子孙标签<br>@：取属性<br>text()：取内容</p><h1 id="二-JSON"><a href="#二-JSON" class="headerlink" title="二. JSON"></a>二. JSON</h1><h2 id="1-JSON基础"><a href="#1-JSON基础" class="headerlink" title="1. JSON基础"></a>1. JSON基础</h2><p>json用于解析json类型格式响应，这是非常普遍的，在异步加载的网页中，很多后端数据通过json格式传到前端进行渲染，得到浏览器显示的HTML文件。比如微博。</p><h2 id="2-Python字典处理JSON"><a href="#2-Python字典处理JSON" class="headerlink" title="2. Python字典处理JSON"></a>2. Python字典处理JSON</h2><p>Python字典和Java对象很相似，Json（JavaScript Object Notation）也可以通过python字典进行处理。</p><p><code>comment_json = json.loads(response.text)</code></p><h2 id="3-Python字典语法"><a href="#3-Python字典语法" class="headerlink" title="3. Python字典语法"></a>3. Python字典语法</h2><p>这个很简单…</p><p>额..还是记一下吧</p><pre><code class="python">user = &#123;    &#39;uid&#39;: &#39;&#39;    &#39;username&#39;: &#39;&#39;    &#39;password&#39;: &#39;&#39;    &#39;friends&#39;: []&#125;</code></pre><p>dict[“xxx”]:取字典中xxx</p><h1 id="三-BS4"><a href="#三-BS4" class="headerlink" title="三. BS4"></a>三. BS4</h1><h2 id="1-bs4基础"><a href="#1-bs4基础" class="headerlink" title="1. bs4基础"></a>1. bs4基础</h2><h2 id="2-引入bs4"><a href="#2-引入bs4" class="headerlink" title="2. 引入bs4"></a>2. 引入bs4</h2><p><code>from bs4 import BeautifulSoup</code></p><h2 id="3-bs4语法"><a href="#3-bs4语法" class="headerlink" title="3. bs4语法"></a>3. bs4语法</h2><pre><code class="python">soup = BeautifulSoup(resp.content, &#39;html.parser&#39;)tag_div = soup.find_all(&quot;div&quot;,class_=&#39;result c-container xpath-log new-pmd&#39;)link = i.get(&#39;mu&#39;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
            <tag> Xpath </tag>
            
            <tag> bs4 </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客（四）：优雅的写一篇文章</title>
      <link href="/2023/09/08/blog_posts/"/>
      <url>/2023/09/08/blog_posts/</url>
      
        <content type="html"><![CDATA[<p><em>你需要先了解…</em></p><p><em>有关此文章…</em></p><h1 id="一-MarkDown-MD基础"><a href="#一-MarkDown-MD基础" class="headerlink" title="一. MarkDown&#x2F;MD基础"></a>一. MarkDown&#x2F;MD基础</h1><p>如果你需要向博客上传文章，将MD文档放置到blog&#x2F;hexo&#x2F;source&#x2F;_posts目录下即可。</p><p>类似于WORD文档，MD同样适用于写作和笔记。MD依赖于键盘输入控制文章的排版格式，不需要鼠标意味着你能拥抱更快的写作速度。不必担心的是，MD比WORD要简单的多。</p><p>如果你需要学习，下面是一些MarkDown语法。</p><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h2><pre><code># 一级标题</code></pre><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><pre><code>## 二级标题</code></pre><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><pre><code>### 三级标题</code></pre><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><pre><code>#### 四级标题</code></pre><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><pre><code>##### 五级标题</code></pre><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><pre><code>###### 六级标题</code></pre><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="2-正文"><a href="#2-正文" class="headerlink" title="2. 正文"></a>2. 正文</h2><p>正文</p><pre><code>正文</code></pre><p><strong>加粗</strong></p><pre><code>**加粗**</code></pre><p><em>斜体</em></p><pre><code>*斜体*</code></pre><p><em><strong>加粗&amp;斜体</strong></em></p><pre><code>***加粗&amp;斜体***</code></pre><h2 id="3-图片-链接"><a href="#3-图片-链接" class="headerlink" title="3. 图片&amp;链接"></a>3. 图片&amp;链接</h2><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>复制图片以后在文档的合适位置粘贴。</p><p><img src="/img/blog_posts/1694181786100.jpeg" alt="Alt text"></p><p>当然你可以更改括号中的图片位置，MD文件会识别同目录下的图片。</p><p>如果你把这些图片放在下层的一个目录进行收录，那么请更改括号中的路径。</p><p>另外，你也可以在括号中放置图片的网页链接。</p><hr><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.baidu.com/">百度</a></p><pre><code>[百度](https://www.baidu.com/)</code></pre><h2 id="4-代码"><a href="#4-代码" class="headerlink" title="4. 代码"></a>4. 代码</h2><pre><code class="Python">    print(Hello MarkDown!)</code></pre><pre><code>```Python    print(Hello MarkDown!)```</code></pre><p>你可以在 <strong>&#96;&#96;&#96;</strong> 后面指定代码所使用的语言，当然也可以不指定。</p><h1 id="二-MarkDown美化"><a href="#二-MarkDown美化" class="headerlink" title="二. MarkDown美化"></a>二. MarkDown美化</h1><p>butterfly提供了MD的额外样式。你可以引用这些标注放在MD文档的开头。</p><p>下面是本篇文章的头：</p><pre><code>---title: 博客：优雅的写一篇文章date: 2023-9-8updated:tags: [博客,hexo,butterfly,md]categories: 博客keywords:description:top_img: /img/cover/0.jpgcomments:cover: /img/cover/0.jpgtoc:toc_number:toc_style_simple:copyright:copyright_author:copyright_author_href:copyright_url:copyright_info:mathjax:katex:aplayer:highlight_shrink:aside:abcjs:---</code></pre><p>你可以通过网络了解其他标注的作用。</p><h1 id="三-问题？"><a href="#三-问题？" class="headerlink" title="三. 问题？"></a>三. 问题？</h1><h2 id="1-MD文档中的图片放置？"><a href="#1-MD文档中的图片放置？" class="headerlink" title="1. MD文档中的图片放置？"></a>1. MD文档中的图片放置？</h2><p>当你向MD文件中复制一张图片时，这张图片会被复制到MD的同级目录下。</p><p>建议你在目录blog\hexo\source\img\xxx下存放你的文章xxx，同时更改MD文件中的图片路径。</p><pre><code>![Alt text](img/xxx/liangyue.jpg)</code></pre><p><em><strong>Tips：</strong></em></p><p>更换大量图片路径是枯燥且费时的。</p><p>如果你使用VSCode编辑MD，那么使用’Ctrl+F’对图片路径进行批量更换是个不错的方法。</p><h2 id="2-博客文章的封面图片？"><a href="#2-博客文章的封面图片？" class="headerlink" title="2. 博客文章的封面图片？"></a>2. 博客文章的封面图片？</h2><p>你可以将封面图片放置在以下目录：blog\hexo\themes\butterfly\source\img</p><p>然后在MD文件中更改以下配置</p><pre><code>top_img: /img/xxx.jpgcover: /img/xxx.jpg</code></pre><p>里面存放了一些网页配置的图片：网站背景图片；头像；404页面；默认顶图。</p><p>如果可以，建议你新建一个cover目录，保存封面图片。<br>然后更改一下路径</p><pre><code>top_img: /img/cover/0.jpgcover: /img/cover/0.jpg</code></pre><h2 id="3-MD侧边预览"><a href="#3-MD侧边预览" class="headerlink" title="3. MD侧边预览"></a>3. MD侧边预览</h2><p>如果你使用VScode编辑MD，右上角打开侧边预览</p><p><img src="/img/blog_posts/image.png" alt="Alt text"></p><h2 id="4-如果你有任何问题？"><a href="#4-如果你有任何问题？" class="headerlink" title="4. 如果你有任何问题？"></a>4. 如果你有任何问题？</h2><p>欢迎你给我留言</p><p>同时希望你能通过搜索引擎和GPT解决大部分问题</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> Hexo </tag>
            
            <tag> Butterfly </tag>
            
            <tag> VScode </tag>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫（一）：请求&amp;响应</title>
      <link href="/2023/09/08/spider_request/"/>
      <url>/2023/09/08/spider_request/</url>
      
        <content type="html"><![CDATA[<p><em>你需要先了解…</em></p><p><em>关于此文章…</em></p><h1 id="一-Requests-概述"><a href="#一-Requests-概述" class="headerlink" title="一. Requests-概述"></a>一. Requests-概述</h1><p>Request是Python的第三方库，用于网络请求并接收返回的数据，你需要在Python的虚拟环境中安装使用。</p><ul><li><p>Request帮助你发送网络请求，同时你可以自定义Request携带的参数。</p></li><li><p>另外，Request模块接收响应请求的数据，并把Response作为函数的返回。</p></li><li><p>如果你想实现一个爬虫，对返回的网页文件进行Xpath&#x2F;正则表达式解析，并将你需要的内容存储即可。</p></li></ul><h1 id="二-Request基础"><a href="#二-Request基础" class="headerlink" title="二. Request基础"></a>二. Request基础</h1><h2 id="1-下载-安装"><a href="#1-下载-安装" class="headerlink" title="1. 下载&amp;安装"></a>1. 下载&amp;安装</h2><pre><code class="cmd">pip/pip3 install requests</code></pre><h2 id="2-Request库"><a href="#2-Request库" class="headerlink" title="2. Request库"></a>2. Request库</h2><h3 id="关于request"><a href="#关于request" class="headerlink" title="关于request"></a>关于request</h3><p>request支持各种HTTP方法，同时你可以指定请求所携带的内容。</p><ul><li>获取响应文件</li></ul><pre><code class="Python">response = request.get(url)</code></pre><ul><li>带上请求头headers</li></ul><pre><code class="Python">response = request.get(url, headers = headers)</code></pre><ul><li>伪装浏览器代理，避免反爬虫<br>*如果你向<a href="https://www.douban.com/%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%93%8D%E5%BA%94%E7%A0%81%E4%B8%BA418%EF%BC%8C">https://www.douban.com/发送请求，响应码为418，</a></li></ul><pre><code class="Python">headers = &#123;    &#39;user-agent&#39;:    &#39;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Mobile Safari/537.36 Edg/116.0.1938.69&#39;    &#125;</code></pre><h3 id="关于response"><a href="#关于response" class="headerlink" title="关于response"></a>关于response</h3><p>你可以定义参数response（或者其他名字）接收request的返回。</p><ul><li>返回响应状态码</li></ul><pre><code class="Python">status_code = response.status_code</code></pre><ul><li>返回网页HTML文件</li></ul><pre><code class="Python">content = response.content</code></pre><h3 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a>了解更多</h3><ul><li><a href="https://www.runoob.com/python3/python-requests.html">菜鸟教程</a></li></ul><h1 id="三-代码实例"><a href="#三-代码实例" class="headerlink" title="三. 代码实例"></a>三. 代码实例</h1><pre><code class="python">    import requests    url = &#39;https://www.baidu.com&#39;    response = requests.get(url)    if(response.status_code == 200):        print(response.content)    else:        print(response.status_code)</code></pre><h1 id="四-问题？"><a href="#四-问题？" class="headerlink" title="四. 问题？"></a>四. 问题？</h1><h2 id="1-response-text-response-content返回中文？"><a href="#1-response-text-response-content返回中文？" class="headerlink" title="1. response.text&#x2F;response.content返回中文？"></a>1. response.text&#x2F;response.content返回中文？</h2><p>你可以使用 <em><strong>response.content.decode(‘utf-8’)</strong></em> 使得content正常的显示中文内容。</p><p>另外， <em><strong>response.text</strong></em> 使用推测的解码格式（ISO-8859-1），相当于 <em><strong>response.content.decode(response.encoding)</strong></em> 。</p><h2 id="2-418-I’m-a-teapot？"><a href="#2-418-I’m-a-teapot？" class="headerlink" title="2. 418 | I’m a teapot？"></a>2. 418 | I’m a teapot？</h2><p>大概：服务器表示我是一个茶壶，需要咖啡的话别找我。</p><p>当然，具体意思需要结合实际场景。</p><p>如果某些网站反爬虫，那么如果你不表示你的代理是浏览器的话，你也会收到418。</p><p>解决方案也很简单，使用 <em><strong>headers{‘user-agent’:’xxx’}</strong></em> 来声称你使用浏览器代理访问网站。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
            <tag> Requests </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发（二）-SpringBoot</title>
      <link href="/2023/09/08/web_springboot/"/>
      <url>/2023/09/08/web_springboot/</url>
      
        <content type="html"><![CDATA[<p><em>你需要先了解…</em></p><p><em>有关此文章…</em></p><h1 id="一-新建SpringBoot项目"><a href="#一-新建SpringBoot项目" class="headerlink" title="一. 新建SpringBoot项目"></a>一. 新建SpringBoot项目</h1><h2 id="1-IDEA新建SpringBoot项目"><a href="#1-IDEA新建SpringBoot项目" class="headerlink" title="1. IDEA新建SpringBoot项目"></a>1. IDEA新建SpringBoot项目</h2><p>(参考文章)[<a href="https://blog.csdn.net/qq_43006591/article/details/106137465]">https://blog.csdn.net/qq_43006591/article/details/106137465]</a></p><h1 id="二-SpringBoot框架解析"><a href="#二-SpringBoot框架解析" class="headerlink" title="二. SpringBoot框架解析"></a>二. SpringBoot框架解析</h1><h2 id="1-idea"><a href="#1-idea" class="headerlink" title="1. .idea"></a>1. .idea</h2><h2 id="2-mvn"><a href="#2-mvn" class="headerlink" title="2. .mvn"></a>2. .mvn</h2><h2 id="3-src"><a href="#3-src" class="headerlink" title="3. src"></a>3. src</h2><h3 id="main"><a href="#main" class="headerlink" title="&#x2F;main"></a>&#x2F;main</h3><ul><li>&#x2F;resource&#x2F;static<br>存放CSS，JS以及图片等</li><li>&#x2F;resource&#x2F;templates<br>存放Web页面</li><li>application.properties&#x2F;application.yml<br>用于存放程序的各种依赖模块的配置信息，比如 服务端口，数据库连接配置等</li><li>&#x2F;main&#x2F;java&#x2F;com.example.xxx<br>存放java源码</li><li>&#x2F;main&#x2F;java&#x2F;Application.java<br>SpringBoot 程序执行的入口，执行该程序中的 main 方法，启动当前SpringBoot项目。</li></ul><h3 id="test"><a href="#test" class="headerlink" title="&#x2F;test"></a>&#x2F;test</h3><p>与mian目录结构类似，没有resource目录。</p><p>存放测试代码。</p><h2 id="4-target"><a href="#4-target" class="headerlink" title="4. target"></a>4. target</h2><p>如果你想测试某个单元，在这里启动它。</p><h2 id="5-gitignore"><a href="#5-gitignore" class="headerlink" title="5. gitignore"></a>5. gitignore</h2><p>使用版本控制工具 git 的时候，设置一些忽略提交的内容</p><h2 id="6-xxx-iml"><a href="#6-xxx-iml" class="headerlink" title="6. xxx.iml"></a>6. xxx.iml</h2><p>intellij idea的工程配置文件，里面是当前project的一些配置信息</p><h2 id="7-HELP-md"><a href="#7-HELP-md" class="headerlink" title="7. HELP.md"></a>7. HELP.md</h2><p>项目的帮助文档，相当于记事本</p><h2 id="8-mvnw"><a href="#8-mvnw" class="headerlink" title="8. mvnw"></a>8. mvnw</h2><p>主要是用于当用户使用maven的命令时，发现本地的maven版本与.mvn文件夹下的maven-wrapper.properties文件中的maven版本不一致，就会下载maven-wrapper.properties文件中的maven版本，然后来执行maven命令，用于Linux环境</p><h2 id="9-mvnw-cmd"><a href="#9-mvnw-cmd" class="headerlink" title="9. mvnw.cmd"></a>9. mvnw.cmd</h2><p>同上，用于Windows环境</p><h2 id="10-pom-xml"><a href="#10-pom-xml" class="headerlink" title="10. pom.xml"></a>10. pom.xml</h2><p>maven依赖的配置</p><h1 id="三-了解更多"><a href="#三-了解更多" class="headerlink" title="三. 了解更多"></a>三. 了解更多</h1><p>(SpringBoot官网)[<a href="https://spring.io/projects/spring-boot]">https://spring.io/projects/spring-boot]</a></p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> web开发 </tag>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫：写在前面</title>
      <link href="/2023/09/07/spider_pre/"/>
      <url>/2023/09/07/spider_pre/</url>
      
        <content type="html"><![CDATA[<p><em>如果你有任何问题，在评论提出</em></p><h2 id="1-爬虫？"><a href="#1-爬虫？" class="headerlink" title="1. 爬虫？"></a>1. 爬虫？</h2><p>爬虫（Spider）常常用于批量获取网络数据资源。</p><p>依托于大数据时代，爬虫在互联网中的地位逐渐凸显，以下是爬虫一些具体应用。</p><ul><li>爬取社交媒体的热点事件评论可以帮助我们分析舆论倾向。</li><li>爬取资源（图片&#x2F;音乐&#x2F;视频）分享到互联网，做一个资源（图片&#x2F;音乐&#x2F;视频）网站。</li><li>爬取数据可以作为机器学习的数据集，像情感分析模型，AI绘画模型都会依赖大量数据集。</li><li>当然，如果你尝试编写爬虫，相信你会对Web有新的理解同时提高你的python编程能力。</li></ul><h2 id="2-爬虫学习基础？"><a href="#2-爬虫学习基础？" class="headerlink" title="2. 爬虫学习基础？"></a>2. 爬虫学习基础？</h2><p>如果你对Web和HTTP协议没有基本的了解并且没有什么python编程基础，我相信这些都不是什么问题，爬虫并没有那么困难。</p><p>人生的困难和挫折就像薛定谔的猫。当你尝试阅读这篇博客，编写代码并坚持下去，心里成见的大山也变为了晴空万里的草原。</p><p>你什么都不会，你开始你将什么都会。</p><h2 id="3-爬虫的一些理解"><a href="#3-爬虫的一些理解" class="headerlink" title="3. 爬虫的一些理解"></a>3. 爬虫的一些理解</h2><p>这一部分有一定的局限性，你可以参考。</p><ul><li>爬虫或者网络爬虫依靠于Web的HTTP协议，学习爬虫可以让你更加理解Web</li><li>爬虫一般经历三个步骤：向服务器发送请求获取响应文件；分析响应文件提取关键内容；保存内容到本地。</li><li>只要你能在浏览器上看到的，你就能够爬取。因为服务器将数据给你后才能在浏览器显示，所以爬虫也能够请求获取这个数据。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发（一）-Maven</title>
      <link href="/2023/09/07/web_maven/"/>
      <url>/2023/09/07/web_maven/</url>
      
        <content type="html"><![CDATA[<p><em>你需要先了解…</em></p><p><em>关于此文章…</em></p><h1 id="一-Maven基础"><a href="#一-Maven基础" class="headerlink" title="一. Maven基础"></a>一. Maven基础</h1><p>Maven用于项目管理，包括以下功能：</p><ul><li><p>依赖管理：依赖指我们项目中使用的第三方Jar包。<br> 在项目构建过程中，需要引入大量依赖，maven帮助你自动导入以及这个依赖所依赖的依赖。另外，maven帮助你管理依赖的版本。</p></li><li><p>简化项目构建：maven提供标准化的Java项目结构,通过Maven你可以快速创建Java项目。</p></li></ul><h1 id="二-Maven实现"><a href="#二-Maven实现" class="headerlink" title="二. Maven实现"></a>二. Maven实现</h1><h2 id="1-Maven下载-安装"><a href="#1-Maven下载-安装" class="headerlink" title="1. Maven下载&amp;安装"></a>1. Maven下载&amp;安装</h2><p> (参考文章)[<a href="https://blog.csdn.net/u012660464/article/details/114113349]">https://blog.csdn.net/u012660464/article/details/114113349]</a></p><h2 id="2-Maven构建项目"><a href="#2-Maven构建项目" class="headerlink" title="2. Maven构建项目"></a>2. Maven构建项目</h2><h2 id="3-pom-xml"><a href="#3-pom-xml" class="headerlink" title="3. pom.xml"></a>3. pom.xml</h2>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> web开发 </tag>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发-写在前面</title>
      <link href="/2023/09/06/web_pre/"/>
      <url>/2023/09/06/web_pre/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> web开发 </tag>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
            <tag> jwt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ChatGPT</title>
      <link href="/2023/08/25/ai_chatgpt/"/>
      <url>/2023/08/25/ai_chatgpt/</url>
      
        <content type="html"><![CDATA[<h2 id="国内接口"><a href="#国内接口" class="headerlink" title="国内接口"></a>国内接口</h2><ul><li><a href="https://c.binjie.fun/">ALchatOS</a></li></ul><h2 id="ChatGPT官网"><a href="#ChatGPT官网" class="headerlink" title="ChatGPT官网"></a>ChatGPT官网</h2><p>…</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> ChatGPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI绘画</title>
      <link href="/2023/08/25/ai_aipainting/"/>
      <url>/2023/08/25/ai_aipainting/</url>
      
        <content type="html"><![CDATA[<h1 id="在线AI绘画"><a href="#在线AI绘画" class="headerlink" title="在线AI绘画"></a>在线AI绘画</h1><h2 id="网址：LiblibAI·哩布哩布AI-中国领先原创AI模型分享社区"><a href="#网址：LiblibAI·哩布哩布AI-中国领先原创AI模型分享社区" class="headerlink" title="网址：LiblibAI·哩布哩布AI-中国领先原创AI模型分享社区"></a>网址：<a href="LiblibAI%C2%B7%E5%93%A9%E5%B8%83%E5%93%A9%E5%B8%83AI-%E4%B8%AD%E5%9B%BD%E9%A2%86%E5%85%88%E5%8E%9F%E5%88%9BAI%E6%A8%A1%E5%9E%8B%E5%88%86%E4%BA%AB%E7%A4%BE%E5%8C%BA">LiblibAI·哩布哩布AI-中国领先原创AI模型分享社区</a></h2><h2 id="教程："><a href="#教程：" class="headerlink" title="教程："></a>教程：</h2><h3 id="1-进入绘画页面"><a href="#1-进入绘画页面" class="headerlink" title="1. 进入绘画页面"></a>1. 进入绘画页面</h3><p>点击网址，来到在线 AI 绘画首页。登录你的账号（QQ 就行）。点击右上角<em><strong>在线Stable Diffusion</strong></em>，进入在线绘画页面。</p><p><img src="/img/ai_%E5%9C%A8%E7%BA%BFAI%E7%BB%98%E7%94%BB/image.png" alt="Alt text"></p><p><img src="/img/ai_%E5%9C%A8%E7%BA%BFAI%E7%BB%98%E7%94%BB/image-1.png" alt="Alt text"></p><h3 id="2-选择模型"><a href="#2-选择模型" class="headerlink" title="2. 选择模型"></a>2. 选择模型</h3><p>在首页中选择一个模型，这里选择<em><strong>麦橘写实</strong></em>。<em>不同的模型适用于不同的类型的图画创作。</em></p><p><img src="/img/ai_%E5%9C%A8%E7%BA%BFAI%E7%BB%98%E7%94%BB/image-2.png" alt="Alt text"></p><h3 id="3-复制图片参数"><a href="#3-复制图片参数" class="headerlink" title="3. 复制图片参数"></a>3. 复制图片参数</h3><p>点击模型进入页面查看图片<em><strong>详细信息</strong></em>，这里是图片生成的一些参数，<em><strong>复制</strong></em>就行。</p><p><img src="/img/ai_%E5%9C%A8%E7%BA%BFAI%E7%BB%98%E7%94%BB/image-3.png" alt="Alt text"></p><p><img src="/img/ai_%E5%9C%A8%E7%BA%BFAI%E7%BB%98%E7%94%BB/image-4.png" alt="Alt text"></p><h3 id="4-填写参数绘画"><a href="#4-填写参数绘画" class="headerlink" title="4. 填写参数绘画"></a>4. 填写参数绘画</h3><p>返回绘画页面，<em><strong>Stable Diffusion 模型选择麦橘写实</strong></em>，<em><strong>粘贴</strong></em>刚才复制的的信息。</p><p><img src="/img/ai_%E5%9C%A8%E7%BA%BFAI%E7%BB%98%E7%94%BB/image-9.png" alt="Alt text"></p><p><em>如果你想生成多张图片，修改以下内容。</em></p><p><img src="/img/ai_%E5%9C%A8%E7%BA%BFAI%E7%BB%98%E7%94%BB/image-5.png" alt="Alt text"></p><h3 id="5-耐心等待生成图片"><a href="#5-耐心等待生成图片" class="headerlink" title="5. 耐心等待生成图片"></a>5. 耐心等待生成图片</h3><p>点击<em><strong>生成图片</strong></em>，耐心等待就好了。下面是图片展示，AI绘画并不一定完美，可以 PS等工具完善。</p><p><img src="/img/ai_%E5%9C%A8%E7%BA%BFAI%E7%BB%98%E7%94%BB/image-6.png" alt="Alt text"></p><p><img src="/img/ai_%E5%9C%A8%E7%BA%BFAI%E7%BB%98%E7%94%BB/image-7.png" alt="Alt text"></p><p><img src="/img/ai_%E5%9C%A8%E7%BA%BFAI%E7%BB%98%E7%94%BB/image-8.png" alt="Alt text"></p><h3 id="6-最后"><a href="#6-最后" class="headerlink" title="6.最后"></a>6.最后</h3><p>恭喜你，已经学会了基础的绘图。接下来，选择你喜欢的模型，慢慢了解并调节各种参数，绘画出你喜欢的图片吧！</p><p>对了，上面介绍了文生图模式，图生图模式一样有趣。赶快试试吧，你就是下一个 AI 调教大师。</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哩布哩布 </tag>
            
            <tag> AI </tag>
            
            <tag> AI绘画 </tag>
            
            <tag> 在线AI绘画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客（二）：美化你的个人博客</title>
      <link href="/2023/08/22/blog_butterfly/"/>
      <url>/2023/08/22/blog_butterfly/</url>
      
        <content type="html"><![CDATA[<p><em>此文章将会指引你使用butterfly美化你的hexo博客</em></p><h1 id="一-部署butterfly主题"><a href="#一-部署butterfly主题" class="headerlink" title="一. 部署butterfly主题"></a>一. 部署butterfly主题</h1><h2 id="1-butterfly主题"><a href="#1-butterfly主题" class="headerlink" title="1. butterfly主题"></a>1. butterfly主题</h2><p>butterfly是hexo框架下的一个主题。</p><p>butterfly主题：</p><p><img src="/img/blog_butterfly/image.png" alt="Alt text"></p><p>相比于原生的hexo博客样式，我相信你肯定更喜欢butterfly。</p><p>了解更多？<a href="https://butterfly.js.org/">butterfly</a></p><h2 id="2-下载butterfly主题"><a href="#2-下载butterfly主题" class="headerlink" title="2. 下载butterfly主题"></a>2. 下载butterfly主题</h2><p>参考文档：<a href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安裝文檔(一) 快速開始</a></p><p>在myblog目录下输入命令安装butterfly：</p><pre><code>git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</code></pre><h2 id="3-安装插件"><a href="#3-安装插件" class="headerlink" title="3. 安装插件"></a>3. 安装插件</h2><p>安装pug和stylus渲染器：</p><pre><code>npm install hexo-renderer-pug hexo-renderer-stylus --save</code></pre><h2 id="4-应用主题"><a href="#4-应用主题" class="headerlink" title="4. 应用主题"></a>4. 应用主题</h2><p>修改配置文件_config.yml：</p><pre><code>theme: butterfly</code></pre><h2 id="5-升级建议"><a href="#5-升级建议" class="headerlink" title="5. 升级建议"></a>5. 升级建议</h2><p>为了減少升级主题带来的不便，我们可以把主题文件夹中的 _config.yml 重命名为 _config.butterfly.yml，复制到 Hexo 根目录下与_config.yml同级。</p><p>Hexo会自动合并主题中的_config.yml和 _config.butterfly.yml ，如果存在同名配置，会使用_config.butterfly.yml的配置，其优先度较高。所以像和博客网址相关联的固定资料可以设置在_config.yml中，比如博客的标题、作者信息和邮箱等等资料，而和主题样式相关的配置放在 _config.butterfly.yml 中，那么在将来你想换一个主题是很方便的。</p><h1 id="二-美化主题"><a href="#二-美化主题" class="headerlink" title="二. 美化主题"></a>二. 美化主题</h1><h2 id="1-图片-图标"><a href="#1-图片-图标" class="headerlink" title="1. 图片&amp;图标"></a>1. 图片&amp;图标</h2><h3 id="（1）网站图标"><a href="#（1）网站图标" class="headerlink" title="（1）网站图标"></a>（1）网站图标</h3><p><strong>.config.butterfly.yml配置：</strong></p><pre><code>    # Favicon（網站圖標）    favicon: /img/favicon.jpg</code></pre><p>将网站图标favicon.jpg放置在此目录：blog\hexo\themes\butterfly\source\img</p><hr><p><strong>效果图：</strong></p><p><img src="/img/blog_butterfly/favicon.jpg" alt="Alt text"></p><p><img src="/img/blog_butterfly/image-5.png" alt="Alt text"></p><h3 id="（2）-网站背景图片"><a href="#（2）-网站背景图片" class="headerlink" title="（2） 网站背景图片"></a>（2） 网站背景图片</h3><p><strong>.config.butterfly.yml配置：</strong></p><pre><code># The banner image of home pageindex_img: /img/background.jpg</code></pre><p>将网站背景图片background.jpg放置在此目录：blog\hexo\themes\butterfly\source\img</p><hr><p><strong>效果图：</strong></p><p><img src="/img/blog_butterfly/background.jpg" alt="Alt text"></p><p><img src="/img/blog_butterfly/image-1.png" alt="Alt text"></p><h3 id="（3）-作者头像"><a href="#（3）-作者头像" class="headerlink" title="（3） 作者头像"></a>（3） 作者头像</h3><pre><code># Avatar (頭像)avatar:img: /img/avatar.jpgeffect: false</code></pre><p>将作者头像avatar.jpg放置在此目录：blog\hexo\themes\butterfly\source\img</p><hr><p><strong>效果图：</strong></p><p><img src="/img/blog_butterfly/avatar.jpg" alt="Alt text"></p><p><img src="/img/blog_butterfly/image-2.png" alt="Alt text"></p><h3 id="（4）-菜单顶图"><a href="#（4）-菜单顶图" class="headerlink" title="（4） 菜单顶图"></a>（4） 菜单顶图</h3><pre><code># If the banner of page not setting, it will show the top_imgdefault_top_img: /img/default_top_img.jpg</code></pre><p>将菜单顶图default_top_img.jpg放置在此目录：blog\hexo\themes\butterfly\source\img</p><hr><p><strong>效果图：</strong></p><p><img src="/img/blog_butterfly/default_top_img.jpg" alt="Alt text"></p><p><em>其他菜单页面同样显示默认顶图</em></p><p><img src="/img/blog_butterfly/image-6.png" alt="Alt text"></p><h3 id="（5）-404页面"><a href="#（5）-404页面" class="headerlink" title="（5） 404页面"></a>（5） 404页面</h3><pre><code># Replace Broken Images (替換無法顯示的圖片)error_img:flink: /img/friend_404.gifpost_page: /img/404.jpg# A simple 404 pageerror_404:enable: truesubtitle: &#39;Page Not Found&#39;background: /img/404.jpg</code></pre><p>这里使用默认的设置即可</p><h3 id="（6）-图片懒加载"><a href="#（6）-图片懒加载" class="headerlink" title="（6） 图片懒加载"></a>（6） 图片懒加载</h3><pre><code># Lazyload (圖片懶加載)# https://github.com/verlok/vanilla-lazyloadlazyload:  enable: true  loadingImg: /img/loading.gif  field: site # site/post  placeholder:  blur: false</code></pre><h2 id="2-网站首页"><a href="#2-网站首页" class="headerlink" title="2. 网站首页"></a>2. 网站首页</h2><p><strong>_config.yml配置：</strong></p><pre><code># Sitetitle: 良月的小窝   #网站标题subtitle: &#39;&#39;description: 郎朗晴天   #个性签名keywords:author: 良月    #博客作者language: zh-CN    #网站语言为简体中文timezone: Asia/Shanghai     #Shanghai是中国时区</code></pre><p><strong>_config.butterfly.yml配置：</strong></p><pre><code># the subtitle on homepage (主頁subtitle)subtitle:enable: true# Typewriter Effect (开启打字效果)effect: true# loop (循環打字)loop: true# source調用第三方服務# source: false 關閉調用# source: 1  調用搏天api的隨機語錄（簡體）# source: 2  調用一言網的一句話（簡體）# source: 3  調用一句網（簡體）# source: 4  調用今日詩詞（簡體）# subtitle 會先顯示 source , 再顯示 sub 的內容source: false# 如果有英文逗号&#39; , &#39;,请使用转义字元 &amp;#44;# 如果有英文双引号&#39; &quot; &#39;,请使用转义字元 &amp;quot;# 开头不允許转义字元，如需要，请把整個句子用双引号包住# 如果关闭打字效果，subtitle只会现示sub的第一行文字sub:    - BY 良月    - 山野渐染暮春色，碧落微醺残阳曦。    - 碎花飘落云海地，琐事淡没扶摇时。    - 凡人入梦蝴蝶语，天官醉酒云云归。    - 众生皆苦非尘世，你我逍遥不自知。</code></pre><h2 id="3-侧边栏"><a href="#3-侧边栏" class="headerlink" title="3. 侧边栏"></a>3. 侧边栏</h2><h3 id="个人资料"><a href="#个人资料" class="headerlink" title="个人资料"></a>个人资料</h3><p><strong>Follow Me：</strong></p><pre><code>card_author:    enable: true    description:    button:    enable: true    icon: fab fa-github    text: Follow Me    link: https://github.com/Yangcheneee    #GitHub个人主页</code></pre><p><strong>社交媒体：</strong></p><pre><code># Social Settings (社交圖標設置)# formal:#   icon: link || the description || colorsocial:fab fa-github: https://github.com/Yangcheneee || Githubfab fa-qq:  tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=2657761647&amp;website=www.oicqzone.com || QQfas fa-envelope-open-text: mailto:2657761647@qq.com || Email</code></pre><p><strong>效果图：</strong></p><p><img src="/img/blog_butterfly/image-11.png" alt="Alt text"></p><h3 id="公告"><a href="#公告" class="headerlink" title="公告"></a>公告</h3><p><strong>.config.butterfly.yml配置：</strong></p><pre><code>card_announcement:    enable: true    content: 欢迎来到我的个人博客</code></pre><p><strong>效果图：</strong></p><p><img src="/img/blog_butterfly/image-13.png" alt="Alt text"></p><h3 id="网站咨询"><a href="#网站咨询" class="headerlink" title="网站咨询"></a>网站咨询</h3><p><strong>.config.butterfly.yml配置：</strong></p><pre><code>card_webinfo:    enable: true    post_count: true    last_push_date: true    sort_order: # Don&#39;t modify the setting unless you know how it works</code></pre><p><strong>效果图：</strong></p><p><img src="/img/blog_butterfly/image-14.png" alt="Alt text"></p><h2 id="4-导航菜单"><a href="#4-导航菜单" class="headerlink" title="4. 导航菜单"></a>4. 导航菜单</h2><p><strong>预览：</strong></p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/img/blog_butterfly/image-3.png" alt="Alt text"></h2><p><strong>_config.butterfly.yml配置：</strong></p><pre><code># Menu 目錄menu:主页: / || fas fa-home博文 || fa fa-graduation-cap:     分类: /categories/ || fa fa-archive 标签: /tags/ || fa fa-tags 归档: /archives/ || fa fa-folder-open生活 || fas fa-list: 分享: /shuoshuo/ || fa fa-comments 相册: /photos/ || fa fa-camera-retro 音乐: /music/ || fa fa-music 影视: /movies/ || fas fa-video友链: /link/ || fa fa-link留言板: /messageboard/ || fa fa-paper-plane关于笔者: /about/ || fas fa-heart  </code></pre><h2 id="5-本地搜索功能"><a href="#5-本地搜索功能" class="headerlink" title="5. 本地搜索功能"></a>5. 本地搜索功能</h2><p><strong>预览：</strong></p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="/img/blog_butterfly/image-4.png" alt="Alt text"></h2><p><strong>安装搜索插件：</strong></p><pre><code>npm install hexo-generator-search --save</code></pre><p><strong>_config.butterfly.yml配置：</strong></p><pre><code># Local searchlocal_search:  enable: true  labels:    input_placeholder: Search for Posts    hits_empty: &quot;We didn&#39;t find any results for the search: $&#123;query&#125;&quot; # 如果没有查到内容相关内容显示</code></pre><h2 id="6-博文：分类-标签-归档"><a href="#6-博文：分类-标签-归档" class="headerlink" title="6. 博文：分类|标签|归档"></a>6. 博文：分类|标签|归档</h2><h3 id="创建分类界面"><a href="#创建分类界面" class="headerlink" title="创建分类界面"></a>创建分类界面</h3><pre><code>hexo new page categories</code></pre><p>打开.&#x2F;source&#x2F;categories&#x2F;index.md</p><pre><code>---title: 分类date: 2023-08-20 20:20:51type: &quot;categories&quot;comments: false---</code></pre><h3 id="创建标签页面"><a href="#创建标签页面" class="headerlink" title="创建标签页面"></a>创建标签页面</h3><pre><code>hexo new page tags</code></pre><p>打开.&#x2F;source&#x2F;tags&#x2F;index.md</p><pre><code>---title: 标签date: 2023-08-20 20:20:16type: &quot;tags&quot;comments: falseorderby: randomorder: 1---</code></pre><h3 id="创建归档界面"><a href="#创建归档界面" class="headerlink" title="创建归档界面"></a>创建归档界面</h3><p>默认创建…</p><h2 id="7-生活：分享-相册-音乐-影视"><a href="#7-生活：分享-相册-音乐-影视" class="headerlink" title="7.生活：分享|相册|音乐|影视"></a>7.生活：分享|相册|音乐|影视</h2><p>待更新…</p><h2 id="8-友情链接页面"><a href="#8-友情链接页面" class="headerlink" title="8. 友情链接页面"></a>8. 友情链接页面</h2><p>创建友情链接页面：</p><pre><code>hexo new page link</code></pre><p>打开source&#x2F;link&#x2F;index.md文件：</p><pre><code>---title: 友情链接date: 2023-08-20 22:17:49type: &quot;link&quot;comments: false---</code></pre><p>添加友情链接：</p><p>在Hexo博客目录中的 source&#x2F;_data（如果没有 _data 文件夾，请自行创建），创建一个文件 link.yml</p><pre><code>- class_name: 友情链接  class_desc: 执子之手，与子偕老。  link_list:    - name: Hexo      link: https://hexo.io/zh-tw/      avatar: https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg      descr: 快速、簡單且強大的網誌框架- class_name: 网站  class_desc: 值得推荐的网站  link_list:    - name: Youtube      link: https://www.youtube.com/      avatar: https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png      descr: 視頻網站    - name: Weibo      link: https://www.weibo.com/      avatar: https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png      descr: 中國最大社交分享平台    - name: Twitter      link: https://twitter.com/      avatar: https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png      descr: 社交分享平台</code></pre><h2 id="9-留言板-评论"><a href="#9-留言板-评论" class="headerlink" title="9. 留言板&amp;评论"></a>9. 留言板&amp;评论</h2><p>创建留言板界面：</p><pre><code>hexo new page messageboard</code></pre><p>打开.&#x2F;source&#x2F;messageboard&#x2F;index.md：</p><pre><code>---title: 留言板date: 2023-08-20 20:21:06types: &quot;messageboard&quot;---</code></pre><h2 id="10-关于笔者"><a href="#10-关于笔者" class="headerlink" title="10. 关于笔者"></a>10. 关于笔者</h2><p>创建关于笔者界面：</p><pre><code>hexo new page about</code></pre><p>打开.&#x2F;source&#x2F;about&#x2F;index.md：</p><pre><code>---title: 关于我date: 2023-08-21 03:20:56type: &quot;about&quot;comments: false---</code></pre><h2 id="11-博文"><a href="#11-博文" class="headerlink" title="11. 博文"></a>11. 博文</h2><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><h3 id="文章分享"><a href="#文章分享" class="headerlink" title="文章分享"></a>文章分享</h3><p><strong>_config.butterfly.yml配置：</strong></p><pre><code># Share.js# https://github.com/overtrue/share.jssharejs:enable: truesites: wechat,qq,weibo</code></pre><hr><p><strong>效果图：</strong></p><p><img src="/img/blog_butterfly/image-7.png" alt="Alt text"></p><h2 id="13-音乐播放器"><a href="#13-音乐播放器" class="headerlink" title="13. 音乐播放器"></a>13. 音乐播放器</h2><pre><code>Inject:bottom:- &#39;&lt;div class=&quot;aplayer no-destroy&quot; data-id=&quot;8674547170&quot; data-server=&quot;netease&quot; data-type=&quot;playlist&quot; data-fixed=&quot;true&quot; data-autoplay=&quot;true&quot; data-lrcType=&quot;-1&quot;&gt; &lt;/div&gt;&#39;# - &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt;</code></pre><h2 id="14-背景美化"><a href="#14-背景美化" class="headerlink" title="14. 背景美化"></a>14. 背景美化</h2><pre><code># Mouse click effects: fireworks (鼠標點擊效果: 煙火特效)fireworks:  enable: true  zIndex: 9999 # -1 or 9999  mobile: false# Typewriter Effect (打字效果)# https://github.com/disjukr/activate-power-modeactivate_power_mode:  enable: true  colorful: true # open particle animation (冒光特效)  shake: false #  open shake (抖動特效)  mobile: true# canvas_nest# https://github.com/hustcc/canvas-nest.jscanvas_nest:  enable: true  color: &#39;0,0,255&#39; #color of lines, default: &#39;0,0,0&#39;; RGB values: (R,G,B).(note: use &#39;,&#39; to separate.)  opacity: 0.7 # the opacity of line (0~1), default: 0.5.  zIndex: -1 # z-index property of the background, default: -1.  count: 99 # the number of lines, default: 99.  mobile: false</code></pre>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> nodejs </tag>
            
            <tag> npm </tag>
            
            <tag> Hexo </tag>
            
            <tag> Butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客（一）：从零开始搭建你的个人博客</title>
      <link href="/2023/08/21/blog_hexo/"/>
      <url>/2023/08/21/blog_hexo/</url>
      
        <content type="html"><![CDATA[<p><em>此文章将会指引你搭建hexo框架的博客，并将其部署到Git Hub上。</em></p><h1 id="一-环境搭建"><a href="#一-环境搭建" class="headerlink" title="一. 环境搭建"></a>一. 环境搭建</h1><h2 id="1-安装Nodejs（npm）"><a href="#1-安装Nodejs（npm）" class="headerlink" title="1. 安装Nodejs（npm）"></a>1. 安装Nodejs（npm）</h2><p>下载链接：<a href="https://nodejs.org/en">Nodejs官方网站</a></p><p>这里直接选择官方推荐的稳定版本：Recommend For Most Users。</p><p><img src="/img/blog_hexo/image.png" alt="Alt text"></p><p>安装过程一路回车就好，默认选项不需要任何额外的操作。</p><p>安装完成以后，打开cmd。输入命令：<em><strong>node -v</strong></em>，若返回nodejs版本信息则安装成功。</p><p>nodejs内置npm。输入命令<em><strong>npm -v</strong></em>，返回npm版本信息则安装成功。</p><p><img src="/img/blog_hexo/image-1.png" alt="Alt text"></p><h2 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2. 安装Git"></a>2. 安装Git</h2><p><a href="https://git-scm.com/download/win">Git下载网址</a></p><p>下载标注的版本。</p><p><img src="/img/blog_hexo/image-2.png" alt="Alt text"></p><p>安装一路回车就好。</p><h1 id="二-本地部署你的博客"><a href="#二-本地部署你的博客" class="headerlink" title="二. 本地部署你的博客"></a>二. 本地部署你的博客</h1><h2 id="1-安装Hexo，新建hexo框架项目"><a href="#1-安装Hexo，新建hexo框架项目" class="headerlink" title="1. 安装Hexo，新建hexo框架项目"></a>1. 安装Hexo，新建hexo框架项目</h2><p>打开cmd输入命令：<em><strong>npm install -g hexo-cli</strong></em>，等待安装完成即可。</p><p>安装完成以后输入命令：<em><strong>hexo -v</strong></em>查看版本，返回结果则安装成功。</p><p>选择一个用于放置博客文件的文件夹，在此目录下使用命令：<em><strong>hexo init myblog</strong></em>，新建你的博客项目。你可以看到在你的文件夹下多了一个myblog的项目。</p><p>输入命令：<em><strong>cd myblog</strong></em>进入myblog项目，安装npm：<em><strong>npm install</strong></em>即可。</p><h2 id="2-在本地启动你的项目"><a href="#2-在本地启动你的项目" class="headerlink" title="2. 在本地启动你的项目"></a>2. 在本地启动你的项目</h2><p>在你的项目根目录下输入命令：<em><strong>hexo g</strong></em>生成博客网站的文件。</p><p>然后输入命令：<em><strong>hexo server</strong></em>启动你的博客。</p><p>接下来，你可以输入网址：<a href="http://localhost/4000">http://localhost/4000</a> 以访问你的个人博客。</p><p>像这样：</p><p><img src="/img/blog_hexo/image-5.png" alt="Alt text"></p><p>当然，如果你想停止你的博客服务，输入命令：<em><strong>Ctrl C</strong></em>即可。</p><h1 id="四-GiHub搭建博客"><a href="#四-GiHub搭建博客" class="headerlink" title="四. GiHub搭建博客"></a>四. GiHub搭建博客</h1><p>如果你没有GitHub账号，请前往官网注册：<a href="https://github.com/">GitHub官网</a> </p><h2 id="1-新建Pages类型仓库"><a href="#1-新建Pages类型仓库" class="headerlink" title="1. 新建Pages类型仓库"></a>1. 新建Pages类型仓库</h2><p><img src="/img/blog_hexo/image-3.png" alt="Alt text"></p><p><strong>你的仓库名（Repository name）必须是：xxx.github.io（xxx是你GitHub的用户名）</strong></p><p>下面的选项选择Public。</p><p><img src="/img/blog_hexo/image-4.png" alt="Alt text"></p><h2 id="2-安装hexo上传插件"><a href="#2-安装hexo上传插件" class="headerlink" title="2. 安装hexo上传插件"></a>2. 安装hexo上传插件</h2><p>输入命令：<em><strong>npm install hexo-deployer-git –save</strong></em></p><p>这个插件使用git上传hexo生成的网页文件。</p><h2 id="3-修改hexo配置文件指定仓库路径"><a href="#3-修改hexo配置文件指定仓库路径" class="headerlink" title="3. 修改hexo配置文件指定仓库路径"></a>3. 修改hexo配置文件指定仓库路径</h2><p>你可以在目录blog\hexo下找到 <strong>_config.yml</strong> 文件，修改以下配置。</p><p>如果你需要在文档快速定位以下内容，使用 <strong>Ctrl+F</strong> 查找 <strong>Deployment</strong> ，你可以定位文档中所有出现Deployment的地方。</p><pre><code># Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:type: &#39;git&#39;repo: https://github.com/Yangcheneee/Yangcheneee.github.io.gitbranch: main</code></pre><p><em>这里将 <strong>yangcheneee</strong> 修改为你的GitHub用户名即可</em></p><h2 id="4-部署博客到对应仓库"><a href="#4-部署博客到对应仓库" class="headerlink" title="4. 部署博客到对应仓库"></a>4. 部署博客到对应仓库</h2><p>输入命令：<em><strong>hexo clean</strong></em>清除之前生成的博客文件</p><p>输入命令：<em><strong>hexo generate</strong></em>（<em><strong>hexo g</strong></em>）生成博客的静态网页文件</p><p>输入命令：<em><strong>hexo deploy</strong></em>（<em><strong>hexo d</strong></em>）将生成的博客文件推送到github仓库</p><p>将博客文件上传到GitHub仓库时，需要进行身份验证，在这个过程中保持登录GitHub，根据提示完成验证即可。</p><p>接下来访问网站：<a href="http://xxx.github.io/">http://xxx.github.io</a> （xxx为你的用户名）即可。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> nodejs </tag>
            
            <tag> npm </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
            <tag> hexo </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客：写在前面</title>
      <link href="/2023/08/21/blog_pre/"/>
      <url>/2023/08/21/blog_pre/</url>
      
        <content type="html"><![CDATA[<p><em>如果你有任何问题，在评论提出</em></p><h2 id="1-博客？"><a href="#1-博客？" class="headerlink" title="1. 博客？"></a>1. 博客？</h2><p>一些好看的博客：<a href="https://butterfly.js.org/link/#%E7%A4%BA%E4%BE%8B">这里</a></p><p>我的个人博客：<a href="https://yangcheneee.github.io/">良月的小窝</a></p><p><img src="/img/blog_pre/image.png" alt="Alt text"></p><p>你可以通过这个系列文章做出与我相似的个人博客，当然或许更好。</p><h2 id="2-个人博客有啥用？"><a href="#2-个人博客有啥用？" class="headerlink" title="2. 个人博客有啥用？"></a>2. 个人博客有啥用？</h2><ul><li><p>个人博客主要用于记录你的学习笔记，简单来说博客是一个在线记事本。</p></li><li><p>除此之外，个人博客可以用于知识分享，其他人可以通过网络访问你的博客。</p></li><li><p>抑或是用于满足好奇心，抑或是喜欢漂亮的博客页面……</p></li><li><p>总之，搭建你的个人博客并不需要太多理由，只是去做也是一种乐趣！</p></li></ul><h2 id="3-搭建个人博客难吗？"><a href="#3-搭建个人博客难吗？" class="headerlink" title="3. 搭建个人博客难吗？"></a>3. 搭建个人博客难吗？</h2><p>一点都不难！</p><p>你可以不写任何代码，只是安装一些文件并配置它们就可以搭建属于你的个人博客。</p><h2 id="4-如何搭建我的个人博客？"><a href="#4-如何搭建我的个人博客？" class="headerlink" title="4. 如何搭建我的个人博客？"></a>4. 如何搭建我的个人博客？</h2><p>我采用GitHub Pages搭建hexo框架的butterfly主题博客，这是一种简单的方式。</p><p>大概流程：下载框架和主题文件；修改配置以美化你的博客界面；生成网页静态文件上传到Git Hub仓库使得其他人可以访问。</p><p>如果你感兴趣，我很乐意继续讲下去。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
